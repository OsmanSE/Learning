C# Useful Resources (tutorialsteacher.com)
https://www.tutorialsteacher.com/csharp/csharp-useful-resources

C# Strings
In C#, a string is a series of characters that is used to represent text. It can be a character, a word or a long passage surrounded with the double quotes ". The following are string literals.
Example: String Literals
"S"
"String"
"This is a string."
C# provides the String data type to store string literals. A variable of the string type can be declared and assign string literal, as shown below.
Example: String Type Variables
string ch = "S";
string word = "String";
string text = "This is a string.";
Try it
The maximum size of a String object in memory is 2GB or about 1 billion characters. However, practically it will be less depending upon CPU and memory of the computer.
 
Skip Ad
There two ways to declare a string variable in C#. Using System.String class and using string keyword. Both are the same and make no difference. Learn string vs String for more info.
Example: String and string
string str1 = "Hello"; // uses string keyword
 
String str2 = "Hello"; // uses System.String class
Try it
In C#, a string is a collection or an array of characters. So, string can be created using a char array or accessed like a char array.
Example: String as char Array
char[] chars = {'H','e','l','l','o'};

string str1 = new string(chars);  
String str2 = new String(chars); 

foreach (char c in str1)
{
    Console.WriteLine(c);
}
Try it
Special Characters
A text in the real world can include any character. In C#, because a string is surrounded with double quotes, it cannot include " in a string. The following will give a compile-time error.
Example: Invalid String
string text = "This is a "string" in C#.";
C# includes escaping character \ (backslash) before these special characters to include in a string.
Use backslash \ before double quotes and some special characters such as \,\n,\r,\t, etc. to include it in a string.
Example: Escape Char \
string text = "This is a \"string\" in C#.";
string str = "xyzdef\\rabc";
string path = "\\\\mypc\\ shared\\project";
Try it
Verbatim Strings
It is tedious to prefix \ to include every special characters. Verbatim string in C# allows a special characters and line brakes. Verbatim string can be created by prefixing @ symbol before double quotes.
Example: Escape Sequence
string str = @"xyzdef\rabc";
string path = @"\\mypc\shared\project";
string email = @"test@test.com";
Try it
The @ symbol can also be used to declare a multi-line string.
Example: Multi-line String
string str1 = "this is a \n" + 
        "multi line \n" + 
        "string";
		
// Verbatim string
string str2 = @"this is a 
        multi line 
        string";
Try it
Please note that you cannot use a backslash to allow " in a varbatim string. If you wish to include @, then use double double-quotes "" to include " in a verbatim string.
string text = "This is a \"string\" in C#."; // valid
string text = @"This is a "string." in C#."; // error
string text = @"This is a \"string\" in C#."; // error
string text = @"This is a ""string"" in C#."; // valid
String Concatenation
Multiple strings can be concatenated with + operator.
Example: String Concatenation
string name = "Mr." + "James " + "Bond" + ", Code: 007";
 
string firstName = "James";
string lastName = "Bond";
string code = "007";
 
string agent = "Mr." + firstName + " " + lastName + ", Code: " + code;
Try it
A String is immutable in C#. It means it is read-only and cannot be changed once created in the memory. Each time you concatenate strings, .NET CLR will create a new memory location for the concatenated string. So, it is recommended to use StringBuilder instead of string if you concatenate more than five strings.
String Interpolation
String interpolation is a better way of concatenating strings. We use + sign to concatenate string variables with static strings.
C# 6 includes a special character $ to identify an interpolated string. An interpolated string is a mixture of static string and string variable where string variables should be in {} brackets.
Example: String Interpolation
string firstName = "James";
string lastName = "Bond";
string code = "007";
 
string fullName = $"Mr. {firstName} {lastName}, Code: {code}";
Try it
In the above example of interpolation, $ indicates the interpolated string, and {} includes string variable to be incorporated with a string.
Use two braces, "{{" or "}}" to include { or } in a string.
Working with Date and Time in C#
C# includes DateTime struct to work with dates and times.
To work with date and time in C#, create an object of the DateTime struct using the new keyword. The following creates a DateTime object with the default value.
Example: Create DateTime Object
DateTime dt = new DateTime(); // assigns default value 01/01/0001 00:00:00
The default and the lowest value of a DateTime object is January 1, 0001 00:00:00 (midnight). The maximum value can be December 31, 9999 11:59:59 P.M.
Use different constructors of the DateTime struct to assign an initial value to a DateTime object.
Example: Set Date & Time
//assigns default value 01/01/0001 00:00:00
DateTime dt1 = new DateTime(); 

//assigns year, month, day
DateTime dt2 = new DateTime(2015, 12, 31); 

//assigns year, month, day, hour, min, seconds
DateTime dt3 = new DateTime(2015, 12, 31, 5, 10, 20);
 
//assigns year, month, day, hour, min, seconds, UTC timezone
DateTime dt4 = new DateTime(2015, 12, 31, 5, 10, 20, DateTimeKind.Utc);
Try it
In the above example, we specified a year, a month, and a day in the constructor. The year can be from 0001 to 9999, and the Month can be from 1 to 12, and the day can be from 1 to 31. Setting any other value out of these ranges will result in a run-time exception.
Example: Invalid Date
DateTime dt = new DateTime(2015, 12, 32); //throws exception: day out of range
Use different DateTime constructors to set date, time, time zone, calendar, and culture.
Ticks
Ticks is a date and time expressed in the number of 100-nanosecond intervals that have elapsed since January 1, 0001, at 00:00:00.000 in the Gregorian calendar. The following initializes a DateTime object with the number of ticks.
Example: Ticks
DateTime dt = new DateTime(636370000000000000); 
DateTime.MinValue.Ticks;  //min value of ticks
DateTime.MaxValue.Ticks; // max value of ticks
Try it
DateTime Static Fields
The DateTime struct includes static fields, properties, and methods. The following example demonstrates important static fields and properties.
Example: Static Fields
DateTime currentDateTime = DateTime.Now;  //returns current date and time
DateTime todaysDate = DateTime.Today; // returns today's date
DateTime currentDateTimeUTC = DateTime.UtcNow;// returns current UTC date and time

DateTime maxDateTimeValue = DateTime.MaxValue; // returns max value of DateTime
DateTime minDateTimeValue = DateTime.MinValue; // returns min value of DateTime
Try it
TimeSpan
TimeSpan is a struct that is used to represent time in days, hour, minutes, seconds, and milliseconds.
Example: TimeSpan
DateTime dt = new DateTime(2015, 12, 31);
           
TimeSpan ts = new TimeSpan(25,20,55);
 
DateTime newDate = dt.Add(ts);

Console.WriteLine(newDate);//1/1/2016 1:20:55 AM
Try it
Subtraction of two dates results in TimeSpan.
Example: Subtract Dates
DateTime dt1 = new DateTime(2015, 12, 31); 
DateTime dt2 = new DateTime(2016, 2, 2);
TimeSpan result = dt2.Subtract(dt1);//33.00:00:00
Try it
Operators
The DateTime struct overloads +, -, ==, !=, >, <, <=, >= operators to ease out addition, subtraction, and comparison of dates. These make it easy to work with dates.
Example: Operators
DateTime dt1 = new DateTime(2015, 12, 20);
DateTime dt2 = new DateTime(2016, 12, 31, 5, 10, 20); 
TimeSpan time = new TimeSpan(10, 5, 25, 50);

Console.WriteLine(dt2 + time); // 1/10/2017 10:36:10 AM
Console.WriteLine(dt2 - dt1); //377.05:10:20
Console.WriteLine(dt1 == dt2); //False
Console.WriteLine(dt1 != dt2); //True
Console.WriteLine(dt1 > dt2); //False
Console.WriteLine(dt1 < dt2); //True
Console.WriteLine(dt1 >= dt2); //False
Console.WriteLine(dt1 <= dt2);//True
Try it
Convert String to DateTime
A valid date and time string can be converted to a DateTime object using Parse(), ParseExact(), TryParse() and TryParseExact() methods.
The Parse() and ParseExact() methods will throw an exception if the specified string is not a valid representation of a date and time. So, it's recommended to use TryParse() or TryParseExact() method because they return false if a string is not valid.
Example:
var str = "5/12/2020";
DateTime dt;
            
var isValidDate = DateTime.TryParse(str, out dt);

if(isValidDate)
    Console.WriteLine(dt);
else
    Console.WriteLine($"{str} is not a valid date string");

C# - Struct
________________________________________
Updated on: June 25, 2020
________________________________________
In C#, struct is the value type data type that represents data structures. It can contain a parameterized constructor, static constructor, constants, fields, methods, properties, indexers, operators, events, and nested types.
struct can be used to hold small data values that do not require inheritance, e.g. coordinate points, key-value pairs, and complex data structure.
Structure Declaration
A structure is declared using struct keyword. The default modifier is internal for the struct and its members.
The following example declares a structure Coordinate for the graph.
Example: Structure
struct Coordinate
{
    public int x;
    public int y;
}
2.5M
96
Entity Framework Core Quiz
A struct object can be created with or without the new operator, same as primitive type variables.
Example: Create Structure
struct Coordinate
{
    public int x;
    public int y;
}

Coordinate point = new Coordinate();
Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
Above, an object of the Coordinate structure is created using the new keyword. It calls the default parameterless constructor of the struct, which initializes all the members to their default value of the specified data type.
If you declare a variable of struct type without using new keyword, it does not call any constructor, so all the members remain unassigned. Therefore, you must assign values to each member before accessing them, otherwise, it will give a compile-time error.
Example: Create Structure Without new Keyword
struct Coordinate
{
    public int x;
    public int y;
}

Coordinate point;
Console.Write(point.x); // Compile time error  

point.x = 10;
point.y = 20;
Console.Write(point.x); //output: 10  
Console.Write(point.y); //output: 20  
Try it
Constructors in Structure
A struct cannot contain a parameterless constructor. It can only contain parameterized constructors or a static constructor.
Example: Parameterized Constructor in Struct
struct Coordinate
{
    public int x;
    public int y;

    public Coordinate(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

Coordinate point = new Coordinate(10, 20);

Console.WriteLine(point.x); //output: 10  
Console.WriteLine(point.y); //output: 20  
Try it
You must include all the members of the struct in the parameterized constructor and assign parameters to members; otherwise C# compiler will give a compile-time error if any member remains unassigned.
Methods and Properties in Structure
A struct can contain properties, auto-implemented properties, methods, etc., same as classes.
Example: Methods and Properties in Struct
struct Coordinate
{
    public int x { get; set; }
    public int y { get; set; }

    public void SetOrigin()
    {
        this.x = 0;
        this.y = 0;
    }
}

Coordinate point = Coordinate();
point.SetOrigin();

Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
The following struct includes the static method.
Example: Static Constructor in Struct
struct Coordinate
{
    public int x;
    public int y;

    public Coordinate(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static Coordinate GetOrigin()
    {
        return new Coordinate();
    }
}

Coordinate point = Coordinate.GetOrigin();

Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
Events in Structure
A struct can contain events to notify subscribers about some action. The following struct contains an event.
Example: Event in Structure
struct Coordinate
{
    private int _x, _y;

    public int x 
    {
        get{
            return _x;
        }

        set{
            _x = value;
            CoordinatesChanged(_x);
        }
    }

    public int y
    {
        get{
            return _y;
        }

        set{
            _y = value;
            CoordinatesChanged(_y);
        }
    }

    public event Action<int> CoordinatesChanged;
}
The above structure contains CoordinatesChanged event, which will be raised when x or y coordinate changes. The following example demonstrates the handling of the CoordinatesChanged event.
Example: Handle Structure Events
class Program
{
    static void Main(string[] args)
    {

        Coordinate point = new Coordinate();
        
        point.CoordinatesChanged += StructEventHandler;
        point.x = 10;
        point.y = 20;
    }

    static void StructEventHandler(int point)
    {
        Console.WriteLine("Coordinate changed to {0}", point);
    }
}
Try it
struct is a value type, so it is faster than a class object. Use struct whenever you want to just store the data. Generally, structs are good for game programming. However, it is easier to transfer a class object than a struct. So do not use struct when you are passing data across the wire or to other classes.
Summary
•	struct can include constructors, constants, fields, methods, properties, indexers, operators, events & nested types.
•	struct cannot include a parameterless constructor or a destructor.
•	struct can implement interfaces, same as class.
•	struct cannot inherit another structure or class, and it cannot be the base of a class.
•	struct members cannot be specified as abstract, sealed, virtual, or protected.
16 Structs
•	Article
•	06/08/2023
•	6 contributors
Feedback
In this article
1.	16.1 General
2.	16.2 Struct declarations
3.	16.3 Struct members
4.	16.4 Class and struct differences
16.1 General
Structs are similar to classes in that they represent data structures that can contain data members and function members. However, unlike classes, structs are value types and do not require heap allocation. A variable of a struct type directly contains the data of the struct, whereas a variable of a class type contains a reference to the data, the latter known as an object.
Note: Structs are particularly useful for small data structures that have value semantics. Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs. Key to these data structures is that they have few data members, that they do not require use of inheritance or reference semantics, rather they can be conveniently implemented using value semantics where assignment copies the value instead of the reference. end note
As described in §8.3.5, the simple types provided by C#, such as int, double, and bool, are, in fact, all struct types.
16.2 Struct declarations
16.2.1 General
A struct_declaration is a type_declaration (§14.7) that declares a new struct:
ANTLRCopy
struct_declaration
    : attributes? struct_modifier* 'ref'? 'partial'? 'struct'
      identifier type_parameter_list? struct_interfaces?
      type_parameter_constraints_clause* struct_body ';'?
    ;
A struct_declaration consists of an optional set of attributes (§22), followed by an optional set of struct_modifiers (§16.2.2), followed by an optional ref modifier (§16.2.3), followed by an optional partial modifier (§15.2.7), followed by the keyword struct and an identifier that names the struct, followed by an optional type_parameter_list specification (§15.2.3), followed by an optional struct_interfaces specification (§16.2.5), followed by an optional type_parameter_constraints-clauses specification (§15.2.5), followed by a struct_body (§16.2.6), optionally followed by a semicolon.
A struct declaration shall not supply a type_parameter_constraints_clauses unless it also supplies a type_parameter_list.
A struct declaration that supplies a type_parameter_list is a generic struct declaration. Additionally, any struct nested inside a generic class declaration or a generic struct declaration is itself a generic struct declaration, since type arguments for the containing type shall be supplied to create a constructed type (§8.4).
A struct declaration that includes a ref keyword shall not have a struct_interfaces part.
16.2.2 Struct modifiers
A struct_declaration may optionally include a sequence of struct_modifiers:
ANTLRCopy
struct_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'readonly'
    | unsafe_modifier   // unsafe code support
    ;
unsafe_modifier (§23.2) is only available in unsafe code (§23).
It is a compile-time error for the same modifier to appear multiple times in a struct declaration.
Except for readonly, the modifiers of a struct declaration have the same meaning as those of a class declaration (§15.2.2).
The readonly modifier indicates that the struct_declaration declares a type whose instances are immutable.
A readonly struct has the following constraints:
•	Each of its instance fields shall also be declared readonly.
•	None of its instance properties shall have a set_accessor_declaration (§15.7.3).
•	It shall not declare any field-like events (§15.8.2).
When an instance of a readonly struct is passed to a method, its this is treated like an in argument/parameter, which disallows write access to any instance fields (except by constructors).
16.2.3 Ref modifier
The ref modifier indicates that the struct_declaration declares a type whose instances are allocated on the execution stack. These types are are called ref struct types. The ref modifier declares that instances may contain ref-like fields, and shall not be copied out of its safe-context (§16.4.12). The rules for determining the safe context of a ref struct are described in §16.4.12.
It is a compile-time error if a ref struct type is used in any of the following contexts:
•	As the element type of an array.
•	As the declared type of a field of a class or a struct that does not have the ref modifier.
•	Being boxed to System.ValueType or System.Object.
•	As a type argument.
•	As the type of a tuple element.
•	An async method.
•	An iterator.
•	There is no conversion from a ref struct type to the type object or the type System.ValueType.
•	A ref struct type shall not be declared to implement any interface.
•	An instance method declared in object or in System.ValueType but not overridden in a ref struct type shall not be called with a receiver of that ref struct type.
•	An instance method of a ref struct type shall not be captured by method group conversion to a delegate type.
•	A ref struct shall not be captured by a lambda expression or a local function.
Note: A ref struct shall not declare async instance methods nor use a yield return or yield break statement within an instance method, because the implicit this parameter cannot be used in those contexts. end note
These constraints ensure that a variable of ref struct type does not refer to stack memory that is no longer valid, or to variables that are no longer valid.
16.2.4 Partial modifier
The partial modifier indicates that this struct_declaration is a partial type declaration. Multiple partial struct declarations with the same name within an enclosing namespace or type declaration combine to form one struct declaration, following the rules specified in §15.2.7.
16.2.5 Struct interfaces
A struct declaration may include a struct_interfaces specification, in which case the struct is said to directly implement the given interface types. For a constructed struct type, including a nested type declared within a generic type declaration (§15.3.9.7), each implemented interface type is obtained by substituting, for each type_parameter in the given interface, the corresponding type_argument of the constructed type.
ANTLRCopy
struct_interfaces
    : ':' interface_type_list
    ;
The handling of interfaces on multiple parts of a partial struct declaration (§15.2.7) are discussed further in §15.2.4.3.
Interface implementations are discussed further in §18.6.
16.2.6 Struct body
The struct_body of a struct defines the members of the struct.
ANTLRCopy
struct_body
    : '{' struct_member_declaration* '}'
    ;
16.3 Struct members
The members of a struct consist of the members introduced by its struct_member_declarations and the members inherited from the type System.ValueType.
ANTLRCopy
struct_member_declaration
    : constant_declaration
    | field_declaration
    | method_declaration
    | property_declaration
    | event_declaration
    | indexer_declaration
    | operator_declaration
    | constructor_declaration
    | static_constructor_declaration
    | type_declaration
    | fixed_size_buffer_declaration   // unsafe code support
    ;
fixed_size_buffer_declaration (§23.8.2) is only available in unsafe code (§23).
Note: All kinds of class_member_declarations except finalizer_declaration are also struct_member_declarations. end note
Except for the differences noted in §16.4, the descriptions of class members provided in §15.3 through §15.12 apply to struct members as well.
16.4 Class and struct differences
16.4.1 General
Structs differ from classes in several important ways:
•	Structs are value types (§16.4.2).
•	All struct types implicitly inherit from the class System.ValueType (§16.4.3).
•	Assignment to a variable of a struct type creates a copy of the value being assigned (§16.4.4).
•	The default value of a struct is the value produced by setting all fields to their default value (§16.4.5).
•	Boxing and unboxing operations are used to convert between a struct type and certain reference types (§16.4.6).
•	The meaning of this is different within struct members (§16.4.7).
•	Instance field declarations for a struct are not permitted to include variable initializers (§16.4.8).
•	A struct is not permitted to declare a parameterless instance constructor (§16.4.9).
•	A struct is not permitted to declare a finalizer.
16.4.2 Value semantics
Structs are value types (§8.3) and are said to have value semantics. Classes, on the other hand, are reference types (§8.2) and are said to have reference semantics.
A variable of a struct type directly contains the data of the struct, whereas a variable of a class type contains a reference to an object that contains the data. When a struct B contains an instance field of type A and A is a struct type, it is a compile-time error for A to depend on B or a type constructed from B. A struct X directly depends on a struct Y if X contains an instance field of type Y. Given this definition, the complete set of structs upon which a struct depends is the transitive closure of the directly depends on relationship.
Example:
C#Copy
struct Node
{
    int data;
    Node next; // error, Node directly depends on itself
}
is an error because Node contains an instance field of its own type. Another example
C#Copy
struct A { B b; }
struct B { C c; }
struct C { A a; }
is an error because each of the types A, B, and C depend on each other.
end example
With classes, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With structs, the variables each have their own copy of the data (except in the case of in, out and ref parameter variables), and it is not possible for operations on one to affect the other. Furthermore, except when explicitly nullable (§8.3.12), it is not possible for values of a struct type to be null.
Note: If a struct contains a field of reference type then the contents of the object referenced can be altered by other operations. However the value of the field itself, i.e., which object it references, cannot be changed through a mutation of a different struct value. end note
Example: Given the following
C#Copy
struct Point
{
    public int x, y;

    public Point(int x, int y) 
    {
        this.x = x;
        this.y = y;
    }
}

class A
{
    static void Main()
    {
        Point a = new Point(10, 10);
        Point b = a;
        a.x = 100;
        Console.WriteLine(b.x);
    }
}
the output is 10. The assignment of a to b creates a copy of the value, and b is thus unaffected by the assignment to a.x. Had Point instead been declared as a class, the output would be 100 because a and b would reference the same object.
end example
16.4.3 Inheritance
All struct types implicitly inherit from the class System.ValueType, which, in turn, inherits from class object. A struct declaration may specify a list of implemented interfaces, but it is not possible for a struct declaration to specify a base class.
Struct types are never abstract and are always implicitly sealed. The abstract and sealed modifiers are therefore not permitted in a struct declaration.
Since inheritance isn’t supported for structs, the declared accessibility of a struct member cannot be protected, private protected, or protected internal.
Function members in a struct cannot be abstract or virtual, and the override modifier is allowed only to override methods inherited from System.ValueType.
16.4.4 Assignment
Assignment to a variable of a struct type creates a copy of the value being assigned. This differs from assignment to a variable of a class type, which copies the reference but not the object identified by the reference.
Similar to an assignment, when a struct is passed as a value parameter or returned as the result of a function member, a copy of the struct is created. A struct may be passed by reference to a function member using an in, out, or ref parameter.
When a property or indexer of a struct is the target of an assignment, the instance expression associated with the property or indexer access shall be classified as a variable. If the instance expression is classified as a value, a compile-time error occurs. This is described in further detail in §12.21.2.
16.4.5 Default values
As described in §9.3, several kinds of variables are automatically initialized to their default value when they are created. For variables of class types and other reference types, this default value is null. However, since structs are value types that cannot be null, the default value of a struct is the value produced by setting all value type fields to their default value and all reference type fields to null.
Example: Referring to the Point struct declared above, the example
C#Copy
Point[] a = new Point[100];
initializes each Point in the array to the value produced by setting the x and y fields to zero.
end example
The default value of a struct corresponds to the value returned by the default constructor of the struct (§8.3.3). Unlike a class, a struct is not permitted to declare a parameterless instance constructor. Instead, every struct implicitly has a parameterless instance constructor, which always returns the value that results from setting all fields to their default values.
Note: Structs should be designed to consider the default initialization state a valid state. In the example
C#Copy
struct KeyValuePair
{
    string key;
    string value;

    public KeyValuePair(string key, string value)
    {
        if (key == null || value == null)
        {
            throw new ArgumentException();
        }

        this.key = key;
        this.value = value;
    }
}
the user-defined instance constructor protects against null values only where it is explicitly called. In cases where a KeyValuePair variable is subject to default value initialization, the key and value fields will be null, and the struct should be prepared to handle this state.
end note
16.4.6 Boxing and unboxing
A value of a class type can be converted to type object or to an interface type that is implemented by the class simply by treating the reference as another type at compile-time. Likewise, a value of type object or a value of an interface type can be converted back to a class type without changing the reference (but, of course, a run-time type check is required in this case).
Since structs are not reference types, these operations are implemented differently for struct types. When a value of a struct type is converted to certain reference types (as defined in §10.2.9), a boxing operation takes place. Likewise, when a value of certain reference types (as defined in §10.3.7) is converted back to a struct type, an unboxing operation takes place. A key difference from the same operations on class types is that boxing and unboxing copies the struct value either into or out of the boxed instance.
Note: Thus, following a boxing or unboxing operation, changes made to the unboxed struct are not reflected in the boxed struct. end note
For further details on boxing and unboxing, see §10.2.9 and §10.3.7.
16.4.7 Meaning of this
The meaning of this in a struct differs from the meaning of this in a class, as described in §12.8.13. When a struct type overrides a virtual method inherited from System.ValueType (such as Equals, GetHashCode, or ToString), invocation of the virtual method through an instance of the struct type does not cause boxing to occur. This is true even when the struct is used as a type parameter and the invocation occurs through an instance of the type parameter type.
Example:
C#Copy
struct Counter
{
    int value;
    public override string ToString() 
    {
        value++;
        return value.ToString();
    }
}

class Program
{
    static void Test<T>() where T : new()
    {
        T x = new T();
        Console.WriteLine(x.ToString());
        Console.WriteLine(x.ToString());
        Console.WriteLine(x.ToString());
    }

    static void Main() => Test<Counter>();
}
The output of the program is:
ConsoleCopy
1
2
3
Although it is bad style for ToString to have side effects, the example demonstrates that no boxing occurred for the three invocations of x.ToString().
end example
Similarly, boxing never implicitly occurs when accessing a member on a constrained type parameter when the member is implemented within the value type. For example, suppose an interface ICounter contains a method Increment, which can be used to modify a value. If ICounter is used as a constraint, the implementation of the Increment method is called with a reference to the variable that Increment was called on, never a boxed copy.
Example:
C#Copy
interface ICounter
{
    void Increment();
}

struct Counter : ICounter
{
    int value;

    public override string ToString() => value.ToString();

    void ICounter.Increment() => value++;
}

class Program
{
    static void Test<T>() where T : ICounter, new()
    {
        T x = new T();
        Console.WriteLine(x);
        x.Increment();              // Modify x
        Console.WriteLine(x);
        ((ICounter)x).Increment();  // Modify boxed copy of x
        Console.WriteLine(x);
    }

    static void Main() => Test<Counter>();
}
The first call to Increment modifies the value in the variable x. This is not equivalent to the second call to Increment, which modifies the value in a boxed copy of x. Thus, the output of the program is:
ConsoleCopy
0
1
1
end example
16.4.8 Field initializers
As described in §16.4.5, the default value of a struct consists of the value that results from setting all value type fields to their default value and all reference type fields to null. For this reason, a struct does not permit instance field declarations to include variable initializers. This restriction applies only to instance fields. Static fields of a struct are permitted to include variable initializers.
Example: The following
C#Copy
struct Point
{
    public int x = 1; // Error, initializer not permitted
    public int y = 1; // Error, initializer not permitted
}
is in error because the instance field declarations include variable initializers.
end example
16.4.9 Constructors
Unlike a class, a struct is not permitted to declare a parameterless instance constructor. Instead, every struct implicitly has a parameterless instance constructor, which always returns the value that results from setting all value type fields to their default value and all reference type fields to null (§8.3.3). A struct can declare instance constructors having parameters.
Example: Given the following
C#Copy
struct Point
{
    int x, y;

    public Point(int x, int y) 
    {
        this.x = x;
        this.y = y;
    }
}

class A
{
    static void Main()
    {
        Point p1 = new Point();
        Point p2 = new Point(0, 0);
    }
}
the statements both create a Point with x and y initialized to zero.
end example
A struct instance constructor is not permitted to include a constructor initializer of the form base(argument_list), where argument_list is optional.
The this parameter of a struct instance constructor corresponds to an out parameter of the struct type. As such, this shall be definitely assigned (§9.4) at every location where the constructor returns. Similarly, it cannot be read (even implicitly) in the constructor body before being definitely assigned.
If the struct instance constructor specifies a constructor initializer, that initializer is considered a definite assignment to this that occurs prior to the body of the constructor. Therefore, the body itself has no initialization requirements.
Example: Consider the instance constructor implementation below:
C#Copy
struct Point
{
    int x, y;

    public int X
    {
        set { x = value; }
    }

    public int Y 
    {
        set { y = value; }
    }

    public Point(int x, int y) 
    {
        X = x; // error, this is not yet definitely assigned
        Y = y; // error, this is not yet definitely assigned
    }
}
No instance function member (including the set accessors for the properties X and Y) can be called until all fields of the struct being constructed have been definitely assigned. Note, however, that if Point were a class instead of a struct, the instance constructor implementation would be permitted. There is one exception to this, and that involves automatically implemented properties (§15.7.4). The definite assignment rules (§12.21.2) specifically exempt assignment to an auto-property of a struct type within an instance constructor of that struct type: such an assignment is considered a definite assignment of the hidden backing field of the auto-property. Thus, the following is allowed:
C#Copy
struct Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x; // allowed, definitely assigns backing field
        Y = y; // allowed, definitely assigns backing field
   }
}
end example]
16.4.10 Static constructors
Static constructors for structs follow most of the same rules as for classes. The execution of a static constructor for a struct type is triggered by the first of the following events to occur within an application domain:
•	A static member of the struct type is referenced.
•	An explicitly declared constructor of the struct type is called.
Note: The creation of default values (§16.4.5) of struct types does not trigger the static constructor. (An example of this is the initial value of elements in an array.) end note
16.4.11 Automatically implemented properties
Automatically implemented properties (§15.7.4) use hidden backing fields, which are only accessible to the property accessors.
Note: This access restriction means that constructors in structs containing automatically implemented properties often need an explicit constructor initializer where they would not otherwise need one, to satisfy the requirement of all fields being definitely assigned before any function member is invoked or the constructor returns. end note
16.4.12 Safe context constraint
16.4.12.1 General
At compile-time, each expression is associated with a context where that instance and all its fields can be safely accessed, its safe-context. The safe-context is a context, enclosing an expression, which it is safe for the value to escape to.
Any expression whose compile-time type is not a ref struct has a safe-context of caller-context.
A default expression, for any type, has safe-context of caller-context.
For any non-default expression whose compile-time type is a ref struct has a safe-context defined by the following sections.
The safe-context records which context a value may be copied into. Given an assignment from an expression E1 with a safe-context S1, to an expression E2 with safe-context S2, it is an error if S2 is a wider context than S1.
There are three different safe-context values, the same as the ref-safe-context values defined for reference variables (§9.7.2): declaration-block, function-member, and caller-context. The safe-context of an expression constrains its use as follows:
•	For a return statement return e1, the safe-context of e1 shall be caller-context.
•	For an assignment e1 = e2 the safe-context of e2 shall be at least as wide a context as the safe-context of e1.
For a method invocation if there is a ref or out argument of a ref struct type (including the receiver unless the type is readonly), with safe-context S1, then no argument (including the receiver) may have a narrower safe-context than S1.
16.4.12.2 Parameter safe context
A formal parameter of a ref struct type, including the this parameter of an instance method, has a safe-context of caller-context.
16.4.12.3 Local variable safe context
A local variable of a ref struct type has a safe-context as follows:
•	If the variable is an iteration variable of a foreach loop, then the variable’s safe-context is the same as the safe-context of the foreach loop’s expression.
•	Otherwise if the variable’s declaration has an initializer then the variable’s safe-context is the same as the safe-context of that initializer.
•	Otherwise the variable is uninitialized at the point of declaration and has a safe-context of caller-context.
16.4.12.4 Field safe context
A reference to a field e.F, where the type of F is a ref struct type, has a safe-context that is the same as the safe-context of e.
16.4.12.5 Operators
The application of a user-defined operator is treated as a method invocation (§16.4.12.6).
For an operator that yields a value, such as e1 + e2 or c ? e1 : e2, the safe-context of the result is the narrowest context among the safe-contexts of the operands of the operator. As a consequence, for a unary operator that yields a value, such as +e, the safe-context of the result is the safe-context of the operand.
Note: The first operand of a conditional operator is a bool, so its safe-context is caller-context. It follows that the resulting safe-context is the narrowest safe-context of the second and third operand. end note
16.4.12.6 Method and property invocation
A value resulting from a method invocation e1.M(e2, ...) or property invocation e.P has safe-context of the smallest of the following contexts:
•	caller-context.
•	The safe-context of all argument expressions (including the receiver).
A property invocation (either get or set) is treated as a method invocation of the underlying method by the above rules.
16.4.12.7 stackalloc
The result of a stackalloc expression has safe-context of function-member.
16.4.12.8 Constructor invocations
A new expression that invokes a constructor obeys the same rules as a method invocation that is considered to return the type being constructed.
In addition the safe-context is the smallest of the safe-contexts of all arguments and operands of all object initializer expressions, recursively, if any initializer is present.
Note: These rules rely on Span<T> not having a constructor of the following form:
C#Copy
public Span<T>(ref T p)
Such a constructor makes instances of Span<T> used as fields indistinguishable from a ref field. The safety rules described in this document depend on ref fields not being a valid construct in C# or .NET. end note
Choosing Between Class and Struct
•	Article
•	10/03/2023
•	16 contributors
Feedback
 Note
This content is reprinted by permission of Pearson Education, Inc. from Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition. That edition was published in 2008, and the book has since been fully revised in the third edition. Some of the information on this page may be out-of-date.
One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type). Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.
The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated. Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.
Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap. Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type. Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays. In addition, in a majority of cases value type arrays exhibit much better locality of reference.
The next difference is related to memory usage. Value types get boxed when cast to a reference type or one of the interfaces they implement. They get unboxed when cast back to the value type. Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application. In contrast, no such boxing occurs as reference types are cast. (For more information, see Boxing and Unboxing).
Next, reference type assignments copy the reference, whereas value type assignments copy the entire value. Therefore, assignments of large reference types are cheaper than assignments of large value types.
Finally, reference types are passed by reference, whereas value types are passed by value. Changes to an instance of a reference type affect all references pointing to the instance. Value type instances are copied when they are passed by value. When an instance of a value type is changed, it of course does not affect any of its copies. Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users. Therefore, value types should be immutable.
As a rule of thumb, the majority of types in a framework should be classes. There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.
✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.
❌ AVOID defining a struct unless the type has all of the following characteristics:
•	It logically represents a single value, similar to primitive types (int, double, etc.).
•	It has an instance size under 16 bytes.
•	It is immutable.
•	It will not have to be boxed frequently.
In all other cases, you should define your types as classes.
C# Enumerations Type - Enum
In C#, an enum (or enumeration type) is used to assign constant names to a group of numeric integer values. It makes constant values more readable, for example, WeekDays.Monday is more readable then number 0 when referring to the day in a week.
An enum is defined using the enum keyword, directly inside a namespace, class, or structure. All the constant names can be declared inside the curly brackets and separated by a comma. The following defines an enum for the weekdays.
Example: Define an Enum
enum WeekDays
{
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}
Above, the WeekDays enum declares members in each line separated by a comma.
Enum Values
If values are not assigned to enum members, then the compiler will assign integer values to each member starting with zero by default. The first member of an enum will be 0, and the value of each successive enum member is increased by 1.
Example: Default Enum Values
enum WeekDays
{
    Monday,     // 0
    Tuesday,    // 1
    Wednesday,  // 2
    Thursday,   // 3
    Friday,     // 4
    Saturday,   // 5
    Sunday      // 6
}
You can assign different values to enum member. A change in the default value of an enum member will automatically assign incremental values to the other members sequentially.
Example: Assign Values to Enum Members
enum Categories
{
    Electronics,    // 0
    Food,           // 1
    Automotive = 6, // 6
    Arts,           // 7
    BeautyCare,     // 8
    Fashion         // 9
}
You can even assign different values to each member.
Example: Assign Values to Enum Members
enum Categories
{
    Electronics = 1,  
    Food = 5, 
    Automotive = 6, 
    Arts = 10, 
    BeautyCare = 11, 
    Fashion = 15,
    WomanFashion = 15
}
The enum can be of any numeric data type such as byte, sbyte, short, ushort, int, uint, long, or ulong. However, an enum cannot be a string type.
Specify the type after enum name as : type. The following defines the byte enum.
Example: byte Enum
enum Categories: byte
{
    Electronics = 1,  
    Food = 5, 
    Automotive = 6, 
    Arts = 10, 
    BeautyCare = 11, 
    Fashion = 15
}
Access an Enum
An enum can be accessed using the dot syntax: enum.member
Example: Access Enum
enum WeekDays
{
    Monday, 
    Tuesday,
    Wednesday,
    Thursday, 
    Friday, 
    Saturday,
    Sunday 
}

Console.WriteLine(WeekDays.Monday); // Monday
Console.WriteLine(WeekDays.Tuesday); // Tuesday
Console.WriteLine(WeekDays.Wednesday); // Wednesday
Console.WriteLine(WeekDays.Thursday); // Thursday
Console.WriteLine(WeekDays.Friday); // Friday
Console.WriteLine(WeekDays.Saturday); // Saturday
Console.WriteLine(WeekDays.Sunday); // Sunday
Conversion
Explicit casting is required to convert from an enum type to its underlying integral type.
Example: Enum Conversion
enum WeekDays
{
    Monday, 
    Tuesday,
    Wednesday,
    Thursday, 
    Friday, 
    Saturday,
    Sunday 
}

Console.WriteLine(WeekDays.Friday); //output: Friday 
int day = (int) WeekDays.Friday; // enum to int conversion
Console.WriteLine(day); //output: 4 
		
var wd = (WeekDays) 5; // int to enum conversion
Console.WriteLine(wd);//output: Saturday 

C# - StringBuilder
________________________________________
Updated on: June 26, 2020
________________________________________
In C#, the string type is immutable. It means a string cannot be changed once created. For example, a new string, "Hello World!" will occupy a memory space on the heap. Now, by changing the initial string "Hello World!" to "Hello World! from Tutorials Teacher" will create a new string object on the memory heap instead of modifying an original string at the same memory address. This behavior would hinder the performance if the original string changed multiple times by replacing, appending, removing, or inserting new strings in the original string.
 Memory Allocation for String Object
2.5M
96
Entity Framework Core Quiz
To solve this problem, C# introduced the StringBuilder in the System.Text namespace. The StringBuilder doesn't create a new object in the memory but dynamically expands memory to accommodate the modified string.
 Memory Allocation for StringBuilder Object
Creating a StringBuilder Object
You can create an object of the StringBuilder class using the new keyword and passing an initial string. The following example demonstrates creating StringBuilder objects.
Example: StringBuilder
using System.Text; // include at the top
            
StringBuilder sb = new StringBuilder(); //string will be appended later
//or
StringBuilder sb = new StringBuilder("Hello World!");
Optionally, you can also specify the maximum capacity of the StringBuilder object using overloaded constructors, as shown below.
Example: StringBuilder
StringBuilder sb = new StringBuilder(50); //string will be appended later
//or
StringBuilder sb = new StringBuilder("Hello World!", 50);
Above, C# allocates a maximum of 50 spaces sequentially on the memory heap. This capacity will automatically be doubled once it reaches the specified capacity. You can also use the capacity or length property to set or retrieve the StringBuilder object's capacity.
You can iterate the using for loop to get or set a character at the specified index.
Example: StringBuilder Iteration
StringBuilder sb = new StringBuilder("Hello World!");

for(int i = 0; i < sb.Length; i++)
    Console.Write(sb[i]); // output: Hello World!
Try it
Retrieve String from StringBuilder
The StringBuilder is not the string. Use the ToString() method to retrieve a string from the StringBuilder object.
Example: Retrieve String from StringBuilder
StringBuilder sb = new StringBuilder("Hello World!");

var greet = sb.ToString(); //returns "Hello World!"
Add/Append String to StringBuilder
Use the Append() method to append a string at the end of the current StringBuilder object. If a StringBuilder does not contain any string yet, it will add it. The AppendLine() method append a string with the newline character at the end.
Example: Adding or Appending Strings in StringBuilder
StringBuilder sb = new StringBuilder();
sb.Append("Hello ");
sb.AppendLine("World!");
sb.AppendLine("Hello C#");
Console.WriteLine(sb);
Try it
Output:
Hello World!
Hello C#.
Append Formated String to StringBuilder
Use the AppendFormat() method to format an input string into the specified format and append it.
Example: AppendFormat()
StringBuilder sbAmout = new StringBuilder("Your total amount is ");
sbAmout.AppendFormat("{0:C} ", 25);

Console.WriteLine(sbAmout);//output: Your total amount is $ 25.00
Try it
Insert String into StringBuilder
Use the Insert() method inserts a string at the specified index in the StringBuilder object.
Example: Insert()
StringBuilder sb = new StringBuilder("Hello World!");
sb.Insert(5," C#"); 

Console.WriteLine(sb); //output: Hello C# World!
Try it
Remove String in StringBuilder
Use the Remove() method to remove a string from the specified index and up to the specified length.
Example: Remove()
StringBuilder sb = new StringBuilder("Hello World!",50);
sb.Remove(6, 7);

Console.WriteLine(sb); //output: Hello
Try it
Replace String in StringBuilder
Use the Replace() method to replace all the specified string occurrences with the specified replacement string.
Example: Replace()
StringBuilder sb = new StringBuilder("Hello World!");
sb.Replace("World", "C#");

Console.WriteLine(sb);//output: Hello C#!
Try it
  Points to Remember :
1.	StringBuilder is mutable.
2.	StringBuilder performs faster than string when appending multiple string values.
3.	Use StringBuilder when you need to append more than three or four strings.
4.	Use the Append() method to add or append strings to the StringBuilder object.
5.	Use the ToString() method to retrieve a string from the StringBuilder object.
6.	C# - Anonymous Type
7.	________________________________________
8.	Updated on: May 2, 2020
9.	________________________________________
10.	In C#, an anonymous type is a type (class) without any name that can contain public read-only properties only. It cannot contain other members, such as fields, methods, events, etc.
11.	You create an anonymous type using the new operator with an object initializer syntax. The implicitly typed variable- var is used to hold the reference of anonymous types.
12.	The following example demonstrates creating an anonymous type variable student that contains three properties named Id, FirstName, and LastName.
13.	Example: Anonymous Type
14.	var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
15.	2.5M
16.	96
17.	Entity Framework Core Quiz
18.	The properties of anonymous types are read-only and cannot be initialized with a null, anonymous function, or a pointer type. The properties can be accessed using dot (.) notation, same as object properties. However, you cannot change the values of properties as they are read-only.
19.	Example: Access Anonymous Type
20.	var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
21.	Console.WriteLine(student.Id); //output: 1
22.	Console.WriteLine(student.FirstName); //output: James
23.	Console.WriteLine(student.LastName); //output: Bond
24.	
25.	student.Id = 2;//Error: cannot chage value
26.	student.FirstName = "Steve";//Error: cannot chage value
27.	Try it
28.	An anonymous type's property can include another anonymous type.
29.	Example: Nested Anonymous Type
30.	var student = new { 
31.	                    Id = 1, 
32.	                    FirstName = "James", 
33.	                    LastName = "Bond",
34.	                    Address = new { Id = 1, City = "London", Country = "UK" }
35.	                };
36.	You can create an array of anonymous types also.
37.	Example: Array of Anonymous Types
38.	var students = new[] {
39.	            new { Id = 1, FirstName = "James", LastName = "Bond" },
40.	            new { Id = 2, FirstName = "Steve", LastName = "Jobs" },
41.	            new { Id = 3, FirstName = "Bill", LastName = "Gates" }
42.	    };
43.	An anonymous type will always be local to the method where it is defined. It cannot be returned from the method. However, an anonymous type can be passed to the method as object type parameter, but it is not recommended. If you need to pass it to another method, then use struct or class instead of an anonymous type.
44.	Mostly, anonymous types are created using the Select clause of a LINQ queries to return a subset of the properties from each object in the collection.
45.	Example: LINQ Query returns an Anonymous Type
46.	class Program
47.	{
48.	    static void Main(string[] args)
49.	    {
50.	        IList<Student> studentList = new List<Student>() { 
51.	            new Student() { StudentID = 1, StudentName = "John", age = 18 },
52.	            new Student() { StudentID = 2, StudentName = "Steve",  age = 21 },
53.	            new Student() { StudentID = 3, StudentName = "Bill",  age = 18 },
54.	            new Student() { StudentID = 4, StudentName = "Ram" , age = 20  },
55.	            new Student() { StudentID = 5, StudentName = "Ron" , age = 21 } 
56.	        };
57.	
58.	        var students = from s in studentList
59.	                       select new { Id = s.StudentID, Name = s.StudentName };
60.	
61.	        foreach(var stud in students)
62.	            Console.WriteLine(stud.Id + "-" + stud.Name);
63.	    }
64.	}
65.	
66.	public class Student
67.	{
68.	    public int StudentID { get; set; }
69.	    public string StudentName { get; set; }
70.	    public int age { get; set; }
71.	}
72.	Try it
73.	Output:
74.	1-John
2-Steve
3-Bill
4-Ram
5-Ron
75.	In the above example, a select clause in the LINQ query selects only StudentID and StudentName properties and renames it to Id and Name, respectively. Thus, it is useful in saving memory and unnecessary code. The query result collection includes only StudentID and StudentName properties, as shown in the following debug view.
76.	Visual Studio supports IntelliSense for anonymous types, as shown below.
77.	 Anonymous Type Intellisense Support in Visual Studio
78.	Internally, all the anonymous types are directly derived from the System.Object class. The compiler generates a class with some auto-generated name and applies the appropriate type to each property based on the value expression. Although your code cannot access it. Use GetType() method to see the name.
79.	Example: Internal Name of an Anonymous Type
80.	static void Main(string[] args)
81.	{
82.	    var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
83.	    Console.WriteLine(student.GetType().ToString());
84.	}

C# - Anonymous Type
________________________________________
Updated on: May 2, 2020
________________________________________
In C#, an anonymous type is a type (class) without any name that can contain public read-only properties only. It cannot contain other members, such as fields, methods, events, etc.
You create an anonymous type using the new operator with an object initializer syntax. The implicitly typed variable- var is used to hold the reference of anonymous types.
The following example demonstrates creating an anonymous type variable student that contains three properties named Id, FirstName, and LastName.
Example: Anonymous Type
var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
2.5M
96
Entity Framework Core Quiz
The properties of anonymous types are read-only and cannot be initialized with a null, anonymous function, or a pointer type. The properties can be accessed using dot (.) notation, same as object properties. However, you cannot change the values of properties as they are read-only.
Example: Access Anonymous Type
var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
Console.WriteLine(student.Id); //output: 1
Console.WriteLine(student.FirstName); //output: James
Console.WriteLine(student.LastName); //output: Bond

student.Id = 2;//Error: cannot chage value
student.FirstName = "Steve";//Error: cannot chage value
Try it
An anonymous type's property can include another anonymous type.
Example: Nested Anonymous Type
var student = new { 
                    Id = 1, 
                    FirstName = "James", 
                    LastName = "Bond",
                    Address = new { Id = 1, City = "London", Country = "UK" }
                };
You can create an array of anonymous types also.
Example: Array of Anonymous Types
var students = new[] {
            new { Id = 1, FirstName = "James", LastName = "Bond" },
            new { Id = 2, FirstName = "Steve", LastName = "Jobs" },
            new { Id = 3, FirstName = "Bill", LastName = "Gates" }
    };
An anonymous type will always be local to the method where it is defined. It cannot be returned from the method. However, an anonymous type can be passed to the method as object type parameter, but it is not recommended. If you need to pass it to another method, then use struct or class instead of an anonymous type.
Mostly, anonymous types are created using the Select clause of a LINQ queries to return a subset of the properties from each object in the collection.
Example: LINQ Query returns an Anonymous Type
class Program
{
    static void Main(string[] args)
    {
        IList<Student> studentList = new List<Student>() { 
            new Student() { StudentID = 1, StudentName = "John", age = 18 },
            new Student() { StudentID = 2, StudentName = "Steve",  age = 21 },
            new Student() { StudentID = 3, StudentName = "Bill",  age = 18 },
            new Student() { StudentID = 4, StudentName = "Ram" , age = 20  },
            new Student() { StudentID = 5, StudentName = "Ron" , age = 21 } 
        };

        var students = from s in studentList
                       select new { Id = s.StudentID, Name = s.StudentName };

        foreach(var stud in students)
            Console.WriteLine(stud.Id + "-" + stud.Name);
    }
}

public class Student
{
    public int StudentID { get; set; }
    public string StudentName { get; set; }
    public int age { get; set; }
}
Try it
Output:
1-John
2-Steve
3-Bill
4-Ram
5-Ron
In the above example, a select clause in the LINQ query selects only StudentID and StudentName properties and renames it to Id and Name, respectively. Thus, it is useful in saving memory and unnecessary code. The query result collection includes only StudentID and StudentName properties, as shown in the following debug view.
Visual Studio supports IntelliSense for anonymous types, as shown below.
 Anonymous Type Intellisense Support in Visual Studio
Internally, all the anonymous types are directly derived from the System.Object class. The compiler generates a class with some auto-generated name and applies the appropriate type to each property based on the value expression. Although your code cannot access it. Use GetType() method to see the name.
Example: Internal Name of an Anonymous Type
static void Main(string[] args)
{
    var student = new { Id = 1, FirstName = "James", LastName = "Bond" };
    Console.WriteLine(student.GetType().ToString());
}

C# - Dynamic Types
C# 4.0 (.NET 4.5) introduced a new type called dynamic that avoids compile-time type checking. A dynamic type escapes type checking at compile-time; instead, it resolves type at run time.
A dynamic type variables are defined using the dynamic keyword.
Example: dynamic Variable
dynamic MyDynamicVar = 1;
The compiler compiles dynamic types into object types in most cases. However, the actual type of a dynamic type variable would be resolved at run-time.
Example: dynamic Type at run-time
dynamic MyDynamicVar = 1;

Console.WriteLine(MyDynamicVar.GetType());
Output:
System.Int32
1.6M
JavaScript Quiz
Next
Stay
Dynamic types change types at run-time based on the assigned value. The following example shows how a dynamic variable changes type based on assigned value.
Example: dynamic
static void Main(string[] args)
{
    dynamic MyDynamicVar = 100;
    Console.WriteLine("Value: {0}, Type: {1}", MyDynamicVar, MyDynamicVar.GetType());

    MyDynamicVar = "Hello World!!";
    Console.WriteLine("Value: {0}, Type: {1}", MyDynamicVar, MyDynamicVar.GetType());

    MyDynamicVar = true;
    Console.WriteLine("Value: {0}, Type: {1}", MyDynamicVar, MyDynamicVar.GetType());

    MyDynamicVar = DateTime.Now;
    Console.WriteLine("Value: {0}, Type: {1}", MyDynamicVar, MyDynamicVar.GetType());
}
Try it
Output:
Value: 100, Type: System.Int32
Value: Hello World!!, Type: System.String
Value: True, Type: System.Boolean
Value: 01-01-2014, Type: System.DateTime
The dynamic type variables is converted to other types implicitly.
Example: dynamic Type Conversion
dynamic d1 = 100;
int i = d1;
		
d1 = "Hello";
string greet = d1;
		
d1 = DateTime.Now;
DateTime dt = d1;
Methods and Parameters
If you assign a class object to the dynamic type, then the compiler would not check for correct methods and properties name of a dynamic type that holds the custom class object. Consider the following example.
Example: Calling Methods
class Program
{
    static void Main(string[] args)
    {
        dynamic stud = new Student();

        stud.DisplayStudentInfo(1, "Bill");// run-time error, no compile-time error
        stud.DisplayStudentInfo("1");// run-time error, no compile-time error
        stud.FakeMethod();// run-time error, no compile-time error
    }
}

public class Student
{
    public void DisplayStudentInfo(int id)
    {
    }
}
Try it
In the above example, the C# compiler does not check for the number of parameters, parameters type, or non-existent. It validates these things at run-time, and if it is not valid, then throws a run-time exception. Note that Visual Studio IntelliSense is not supported for the dynamic types. Note that Visual Studio IntelliSense is not supported for the dynamic types.
The dynamic language runtime (DLR) API provides the infrastructure that supports the dynamic type in C#. For more information about the DLR, visit Dynamic Language Runtime Overview.
C# - Nullable Types
As you know, a value type cannot be assigned a null value. For example, int i = null will give you a compile time error.
C# 2.0 introduced nullable types that allow you to assign null to value type variables. You can declare nullable types using Nullable<t> where T is a type.
Example: Nullable type
Nullable<int> i = null;
A nullable type can represent the correct range of values for its underlying value type, plus an additional null value. For example, Nullable<int> can be assigned any value from -2147483648 to 2147483647, or a null value.
The Nullable types are instances of System.Nullable<T> struct. Think it as something like the following structure.
Example: Nullable struct
[Serializable]
public struct Nullable<T> where T : struct
{        
    public bool HasValue { get; }
      
    public T Value { get; }
        
    // other implementation
}
A nullable of type int is the same as an ordinary int plus a flag that says whether the int has a value or not (is null or not). All the rest is compiler magic that treats "null" as a valid value.
Example: HasValue
static void Main(string[] args)
{
    Nullable<int> i = null;

    if (i.HasValue)
        Console.WriteLine(i.Value); // or Console.WriteLine(i)
    else
        Console.WriteLine("Null");
}
Try it
Output:
Null
The HasValue returns true if the object has been assigned a value; if it has not been assigned any value or has been assigned a null value, it will return false.
Accessing the value using NullableType.value will throw a runtime exception if nullable type is null or not assigned any value. For example, i.Value will throw an exception if i is null:
 Invalid use of Nullable Type
Use the GetValueOrDefault() method to get an actual value if it is not null and the default value if it is null. For example:
Example: GetValueOrDefault()
static void Main(string[] args)
{
    Nullable<int> i = null;

    Console.WriteLine(i.GetValueOrDefault()); 
}
Try it
Shorthand Syntax for Nullable Types
You can use the '?' operator to shorthand the syntax e.g. int?, long? instead of using Nullable<T>.
Example: Shorthand syntax for Nullable types
int? i = null;
double? D = null;
?? Operator
Use the '??' operator to assign a nullable type to a non-nullable type.
Example: ?? operator with Nullable Type
int? i = null;
            
int j = i ?? 0;

Console.WriteLine(j);
Try it
Output:
0
In the above example, i is a nullable int and if you assign it to the non-nullable int j then it will throw a runtime exception if i is null. So to mitigate the risk of an exception, we have used the '??' operator to specify that if i is null then assign 0 to j.
Assignment Rules
A nullable type has the same assignment rules as a value type. It must be assigned a value before using it if nullable types are declared in a function as local variables. If it is a field of any class then it will have a null value by default.
For example, the following nullable of int type is declared and used without assigning any value. The compiler will give "Use of unassigned local variable 'i'" error:
 Unassigned nullable type-error
In the following example, a nullable of int type is a field of the class, so it will not give any error.
Example: Nullable type as Class Field
class MyClass
{
    public Nullable<int> i;
}
class Program
{
    static void Main(string[] args)
    {
        MyClass mycls = new MyClass();

        if(mycls.i == null)
            Console.WriteLine("Null");
    }
}
Try it
Output:
Null
Nullable Helper Class
Null is considered to be less than any value. So comparison operators won't work against null. Consider the following example where i is neither less than j, greater than j nor equal to j:
Example: Nullable Type Comparison
static void Main(string[] args)
{
    int? i = null;
    int j = 10;


    if (i < j)
        Console.WriteLine("i < j");
    else if( i > 10)
        Console.WriteLine("i > j");
    else if( i == 10)
        Console.WriteLine("i == j");
    else
        Console.WriteLine("Could not compare");
}
Try it
Output:
Could not compare
Nullable static class is a helper class for Nullable types. It provides a compare method to compare nullable types. It also has a GetUnderlyingType method that returns the underlying type argument of nullable types.
Example: Helper Class
static void Main(string[] args)
{
    int? i = null;
    int j = 10;

    if (Nullable.Compare<int>(i, j) < 0)
        Console.WriteLine("i < j");
    else if (Nullable.Compare<int>(i, j) > 0)
        Console.WriteLine("i > j");
    else
        Console.WriteLine("i = j");
} 

Try it
Output:
i < j
Characteristics of Nullable Types
1.	Nullable types can only be used with value types.
2.	The Value property will throw an InvalidOperationException if value is null; otherwise it will return the value.
3.	The HasValue property returns true if the variable contains a value, or false if it is null.
4.	You can only use == and != operators with a nullable type. For other comparison use the Nullable static class.
5.	Nested nullable types are not allowed. Nullable<Nullable<int>> i; will give a compile time error.
  Points to Remember :
1.	Nullable<T> type allows assignment of null to value types.
2.	? operator is a shorthand syntax for Nullable types.
3.	Use value property to get the value of nullable type.
4.	Use HasValue property to check whether value is assigned to nullable type or not.
5.	Static Nullable class is a helper class to compare nullable types.
Value Type and Reference Type
In C#, these data types are categorized based on how they store their value in the memory. C# includes the following categories of data types:
1.	Value type
2.	Reference type
3.	Pointer type
Value Type
A data type is a value type if it holds a data value within its own memory space. It means the variables of these data types directly contain values.
 All the value types derive from System.ValueType, which in-turn, derives from System.Object.
For example, consider integer variable int i = 100;
The system stores 100 in the memory space allocated for the variable i. The following image illustrates how 100 is stored at some hypothetical location in the memory (0x239110) for 'i':
 Memory Allocation of Value Type Variable
The following data types are all of value type:
•	bool
•	byte
•	char
•	decimal
•	double
•	enum
•	float
•	int
•	long
•	sbyte
•	short
•	struct
•	uint
•	ulong
•	ushort
Passing Value Type Variables
When you pass a value-type variable from one method to another, the system creates a separate copy of a variable in another method. If value got changed in the one method, it wouldn't affect the variable in another method.
Example: Passing Value Type Variables
static void ChangeValue(int x)
{
    x =  200;

    Console.WriteLine(x);
}

static void Main(string[] args)
{
    int i = 100;

    Console.WriteLine(i);
    
    ChangeValue(i);
    
    Console.WriteLine(i);
}
Try it
Output:
100
200
100
In the above example, variable i in the Main() method remains unchanged even after we pass it to the ChangeValue() method and change it's value there.
Reference Type
Unlike value types, a reference type doesn't store its value directly. Instead, it stores the address where the value is being stored. In other words, a reference type contains a pointer to another memory location that holds the data.
For example, consider the following string variable:
string s = "Hello World!!";
The following image shows how the system allocates the memory for the above string variable.
 Memory Allocation of Reference Type Variable
As you can see in the above image, the system selects a random location in memory (0x803200) for the variable s. The value of a variable s is 0x600000, which is the memory address of the actual data value. Thus, reference type stores the address of the location where the actual value is stored instead of the value itself.
The followings are reference type data types:
•	String
•	Arrays (even if their elements are value types)
•	Class
•	Delegate
Passing Reference Type Variables
When you pass a reference type variable from one method to another, it doesn't create a new copy; instead, it passes the variable's address. So, If we change the value of a variable in a method, it will also be reflected in the calling method.
Example: Passing Reference Type Variable
static void ChangeReferenceType(Student std2)
{
    std2.StudentName = "Steve";
}

static void Main(string[] args)
{
    Student std1 = new Student();
    std1.StudentName = "Bill";
    
    ChangeReferenceType(std1);

    Console.WriteLine(std1.StudentName);
}
Try it
Output:
Steve
In the above example, we pass the Student object std1 to the ChangeReferenceType() method. Here, it actually pass the memory address of std1. Thus, when the ChangeReferenceType() method changes StudentName, it is actually changing StudentName of std1 object, because std1 and std2 are both pointing to the same address in memory.
String is a reference type, but it is immutable. It means once we assigned a value, it cannot be changed. If we change a string value, then the compiler creates a new string object in the memory and point a variable to the new memory location. So, passing a string value to a function will create a new variable in the memory, and any change in the value in the function will not be reflected in the original value, as shown below.
Example: Passing String
static void ChangeReferenceType(string name)
{
    name = "Steve";
}

static void Main(string[] args)
{
    string name = "Bill";
    
    ChangeReferenceType(name);

    Console.WriteLine(name);
}
Try it
Output:
Bill
Null
The default value of a reference type variable is null when they are not initialized. Null means not refering to any object.
 Null Reference Type
A value type variable cannot be null because it holds value, not a memory address. C# 2.0 introduced nullable types, using which you can assign null to a value type variable or declare a value type variable without assigning a value to it.
C# Questions & Answers
Start C# Skill Test

C# - Interface
In the human world, a contract between the two or more humans binds them to act as per the contract. In the same way, an interface includes the declarations of related functionalities. The entities that implement the interface must provide the implementation of declared functionalities.
In C#, an interface can be defined using the interface keyword. An interface can contain declarations of methods, properties, indexers, and events. However, it cannot contain instance fields.
The following interface declares some basic functionalities for the file operations.
Example: C# Interface
interface IFile
{
    void ReadFile();
    void WriteFile(string text);
}
The above declares an interface named IFile. (It is recommended to start an interface name with the letter "I" at the beginning of an interface so that it is easy to know that this is an interface and not a class.) The IFile interface contains two methods, ReadFile() and WriteFile(string).
 Note:
•	An interface can contain declarations of methods, properties, indexers, and events.
•	Default interface methods with implementation body are supported from C# 8.0.
•	An interface cannot contain constructors and fields.
•	Interface members are by default abstract and public.
•	You cannot apply access modifiers to interface members. Although, C# 8.0 onwards, you may use private, protected, internal, public, virtual, abstract, sealed, static, extern, and partial modifiers on certain conditions.
 
Skip Ad
Implementing an Interface
A class or a Struct can implement one or more interfaces using colon :. On impmenting an interface, you must override all the members of an interface.
Syntax:
class ClassName : InterfaceName
{

}
For example, the following FileInfo class implements the IFile interface, so it should override all the members of IFile.
Example: Interface Implementation
interface IFile
{
    void ReadFile();
    void WriteFile(string text);
}

class FileInfo : IFile
{
    public void ReadFile()
    {
        Console.WriteLine("Reading File");
    }

    public void WriteFile(string text)
    {
        Console.WriteLine("Writing to file");
    }
}
In the above example, the FileInfo class implements the IFile interface. It overrides all the members of the IFile interface with public access modifier. The FileInfo class can also contain members other than interface members.
 Note:
Interface members must be implemented with the public modifier; otherwise, the compiler will give compile-time errors.
You can create an object of the class and assign it to a variable of an interface type, as shown below.
Example: Interface Implementation
public class Program
{
    public static void Main()
    {
        IFile file1 = new FileInfo();
        FileInfo file2 = new FileInfo();
		
        file1.ReadFile(); 
        file1.WriteFile("content"); 

        file2.ReadFile(); 
        file2.WriteFile("content"); 
    }
}
Try it
Above, we created objects of the FileInfo class and assign it to IFile type variable and FileInfo type variable. When interface implemented implicitly, you can access IFile members with the IFile type variables as well as FileInfo type variable.
Explicit Implementation
An interface can be implemented explicitly using <InterfaceName>.<MemberName>. Explicit implementation is useful when class is implementing multiple interfaces; thereby, it is more readable and eliminates the confusion. It is also useful if interfaces have the same method name coincidently.
 Note:
Do not use public modifier with an explicit implementation. It will give a compile-time error.
Example: Explicit Implementation
interface IFile
{
    void ReadFile();
    void WriteFile(string text);
}
    
class FileInfo : IFile
{
    void IFile.ReadFile()
    {
        Console.WriteLine("Reading File");
    }

    void IFile.WriteFile(string text)
    {
        Console.WriteLine("Writing to file");
    }
}
When you implement an interface explicitly, you can access interface members only through the instance of an interface type.
Example: Explicit Implementation
interface IFile
{
    void ReadFile();
    void WriteFile(string text);
}

class FileInfo : IFile
{
    void IFile.ReadFile()
    {
        Console.WriteLine("Reading File");
    }

    void IFile.WriteFile(string text)
    {
        Console.WriteLine("Writing to file");
    }

    public void Search(string text)
    {
        Console.WriteLine("Searching in file");
    }
}

public class Program
{
    public static void Main()
    {
        IFile file1 = new FileInfo();
        FileInfo file2 = new FileInfo();
		
        file1.ReadFile(); 
        file1.WriteFile("content"); 
        //file1.Search("text to be searched")//compile-time error 
        
        file2.Search("text to be searched");
        //file2.ReadFile(); //compile-time error 
        //file2.WriteFile("content"); //compile-time error 
    }
}
Try it
In the above example, file1 object can only access members of IFile, and file2 can only access members of FileInfo class. This is the limitation of explicit implementation.
Implementing Multiple Interfaces
A class or struct can implement multiple interfaces. It must provide the implementation of all the members of all interfaces.
Example: Implement Multiple Interfaces
interface IFile
{
    void ReadFile();
}

interface IBinaryFile
{
    void OpenBinaryFile();
    void ReadFile();
}

class FileInfo : IFile, IBinaryFile
{
    void IFile.ReadFile()
    {
        Console.WriteLine("Reading Text File");
    }

    void IBinaryFile.OpenBinaryFile()
    {
        Console.WriteLine("Opening Binary File");
    }

    void IBinaryFile.ReadFile()
    {
        Console.WriteLine("Reading Binary File");
    }

    public void Search(string text)
    {
        Console.WriteLine("Searching in File");
    }
}

public class Program
{
    public static void Main()
    {
        IFile file1 = new FileInfo();
        IBinaryFile file2 = new FileInfo();
        FileInfo file3 = new FileInfo();
		
        file1.ReadFile(); 
        //file1.OpenBinaryFile(); //compile-time error 
        //file1.SearchFile("text to be searched"); //compile-time error 
        
        file2.OpenBinaryFile();
        file2.ReadFile();
        //file2.SearchFile("text to be searched"); //compile-time error 
    
        file3.Search("text to be searched");
        //file3.ReadFile(); //compile-time error 
        //file3.OpenBinaryFile(); //compile-time error 
    }
}
Try it
Above, the FileInfo implements two interfaces IFile and IBinaryFile explicitly. It is recommended to implement interfaces explicitly when implementing multiple interfaces to avoid confusion and more readability.
Default Interface Methods
Till now, we learned that interface can contain method declarations only. C# 8.0 added support for virtual extension methods in interface with concrete implementations.
The virtual interface methods are also called default interface methods that do not need to be implemented in a class or struct.
Example: Default Interface Methods
interface IFile
{
    void ReadFile();
    void WriteFile(string text);

    void DisplayName()
    {
        Console.WriteLine("IFile");
    }
}
In the above IFile interface, the DisplayName() is the default method. The implementation will remain same for all the classes that implements the IFile interface. Note that a class does not inherit default methods from its interfaces; so, you cannot access it using the class instance.
Example: Interface Implementation
class FileInfo : IFile
{
    public void ReadFile()
    {
        Console.WriteLine("Reading File");
    }

    public void WriteFile(string text)
    {
        Console.WriteLine("Writing to file");
    }
}

public class Program
{
    public static void Main()
    {
        IFile file1 = new FileInfo();
        file1.ReadFile(); 
        file1.WriteFile("content"); 
        file1.DisplayName();

        FileInfo file2 = new FileInfo();
        //file2.DisplayName(); //compile-time error 
    }
}
Try it
Learn more on Default interface methods.
Modifiers in Interfaces
C# 8.0 allows private, protected, internal, public, virtual, abstract, sealed, static, extern, and partial modifiers in an interface.
•	The default access level for all interface members is public.
•	An interface member whose declaration includes a body is a virtual member unless the sealed or private modifier is used.
•	A private or sealed function member of an interface must have implementation body.
•	Interfaces may declare static members which can be accessed by interface name.
Modifiers in interfaces
The syntax for an interface is relaxed to permit modifiers on its members. The following are permitted: private, protected, internal, public, virtual, abstract, sealed, static, extern, and partial.
TODO: check what other modifiers exist.
An interface member whose declaration includes a body is a virtual member unless the sealed or private modifier is used. The virtual modifier may be used on a function member that would otherwise be implicitly virtual. Similarly, although abstract is the default on interface members without bodies, that modifier may be given explicitly. A non-virtual member may be declared using the sealed keyword.
It is an error for a private or sealed function member of an interface to have no body. A private function member may not have the modifier sealed.
Access modifiers may be used on interface members of all kinds of members that are permitted. The access level public is the default but it may be given explicitly.
Open Issue: We need to specify the precise meaning of the access modifiers such as protected and internal, and which declarations do and do not override them (in a derived interface) or implement them (in a class that implements the interface).
Interfaces may declare static members, including nested types, methods, indexers, properties, events, and static constructors. The default access level for all interface members is public.
Interfaces may not declare instance constructors, destructors, or fields.
Closed Issue: Should operator declarations be permitted in an interface? Probably not conversion operators, but what about others? Decision: Operators are permitted except for conversion, equality, and inequality operators.
Closed Issue: Should new be permitted on interface member declarations that hide members from base interfaces? Decision: Yes.
Closed Issue: We do not currently permit partial on an interface or its members. That would require a separate proposal. Decision: Yes. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#permit-partial-in-interface
Explicit implementation in interfaces
Explicit implementations allow the programmer to provide a most specific implementation of a virtual member in an interface where the compiler or runtime would not otherwise find one. An implementation declaration is permitted to explicitly implement a particular base interface method by qualifying the declaration with the interface name (no access modifier is permitted in this case). Implicit implementations are not permitted.
C#Copy
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    void IA.M() { WriteLine("IB.M"); } // Explicit implementation
}
interface IC : IA
{
    void M() { WriteLine("IC.M"); } // Creates a new M, unrelated to `IA.M`. Warning
}
Explicit implementations in interfaces may not be declared sealed.
Public virtual function members in an interface may only be implemented in a derived interface explicitly (by qualifying the name in the declaration with the interface type that originally declared the method, and omitting an access modifier). The member must be accessible where it is implemented.
Reabstraction
A virtual (concrete) method declared in an interface may be reabstracted in a derived interface
C#Copy
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    abstract void IA.M();
}
class C : IB { } // error: class 'C' does not implement 'IA.M'.
The abstract modifier is required in the declaration of IB.M, to indicate that IA.M is being reabstracted.
This is useful in derived interfaces where the default implementation of a method is inappropriate and a more appropriate implementation should be provided by implementing classes.
Open Issue: Should reabstraction be permitted?
The most specific implementation rule
We require that every interface and class have a most specific implementation for every virtual member among the implementations appearing in the type or its direct and indirect interfaces. The most specific implementation is a unique implementation that is more specific than every other implementation. If there is no implementation, the member itself is considered the most specific implementation.
One implementation M1 is considered more specific than another implementation M2 if M1 is declared on type T1, M2 is declared on type T2, and either
1.	T1 contains T2 among its direct or indirect interfaces, or
2.	T2 is an interface type but T1 is not an interface type.
For example:
C#Copy
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    void IA.M() { WriteLine("IB.M"); }
}
interface IC : IA
{
    void IA.M() { WriteLine("IC.M"); }
}
interface ID : IB, IC { } // error: no most specific implementation for 'IA.M'
abstract class C : IB, IC { } // error: no most specific implementation for 'IA.M'
abstract class D : IA, IB, IC // ok
{
    public abstract void M();
}

The most specific implementation rule ensures that a conflict (i.e. an ambiguity arising from diamond inheritance) is resolved explicitly by the programmer at the point where the conflict arises.
Because we support explicit reabstractions in interfaces, we could do so in classes as well
C#Copy
abstract class E : IA, IB, IC // ok
{
    abstract void IA.M();
}
Open issue: should we support explicit interface abstract implementations in classes?
In addition, it is an error if in a class declaration the most specific implementation of some interface method is an abstract implementation that was declared in an interface. This is an existing rule restated using the new terminology.
C#Copy
interface IF
{
    void M();
}
abstract class F : IF { } // error: 'F' does not implement 'IF.M'
It is possible for a virtual property declared in an interface to have a most specific implementation for its get accessor in one interface and a most specific implementation for its set accessor in a different interface. This is considered a violation of the most specific implementation rule.
static and private methods
Because interfaces may now contain executable code, it is useful to abstract common code into private and static methods. We now permit these in interfaces.
Closed issue: Should we support private methods? Should we support static methods? Decision: YES
Open issue: should we permit interface methods to be protected or internal or other access? If so, what are the semantics? Are they virtual by default? If so, is there a way to make them non-virtual?
Open issue: If we support static methods, should we support (static) operators?
Base interface invocations
Code in a type that derives from an interface with a default method can explicitly invoke that interface's "base" implementation.
C#Copy
interface I0
{
   void M() { Console.WriteLine("I0"); }
}
interface I1 : I0
{
   override void M() { Console.WriteLine("I1"); }
}
interface I2 : I0
{
   override void M() { Console.WriteLine("I2"); }
}
interface I3 : I1, I2
{
   // an explicit override that invoke's a base interface's default method
   void I0.M() { I2.base.M(); }
}

An instance (nonstatic) method is permitted to invoke the implementation of an accessible instance method in a direct base interface nonvirtually by naming it using the syntax base(Type).M. This is useful when an override that is required to be provided due to diamond inheritance is resolved by delegating to one particular base implementation.
C#Copy
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    override void IA.M() { WriteLine("IB.M"); }
}
interface IC : IA
{
    override void IA.M() { WriteLine("IC.M"); }
}

class D : IA, IB, IC
{
    void IA.M() { base(IB).M(); }
}
When a virtual or abstract member is accessed using the syntax base(Type).M, it is required that Type contains a unique most specific override for M.
Binding base clauses
Interfaces now contain types. These types may be used in the base clause as base interfaces. When binding a base clause, we may need to know the set of base interfaces to bind those types (e.g. to lookup in them and to resolve protected access). The meaning of an interface's base clause is thus circularly defined. To break the cycle, we add a new language rules corresponding to a similar rule already in place for classes.
While determining the meaning of the interface_base of an interface, the base interfaces are temporarily assumed to be empty. Intuitively this ensures that the meaning of a base clause cannot recursively depend on itself.
We used to have the following rules:
"When a class B derives from a class A, it is a compile-time error for A to depend on B. A class directly depends on its direct base class (if any) and directly depends on the class within which it is immediately nested (if any). Given this definition, the complete set of classes upon which a class depends is the reflexive and transitive closure of the directly depends on relationship."
It is a compile-time error for an interface to directly or indirectly inherit from itself. The base interfaces of an interface are the explicit base interfaces and their base interfaces. In other words, the set of base interfaces is the complete transitive closure of the explicit base interfaces, their explicit base interfaces, and so on.
We are adjusting them as follows:
When a class B derives from a class A, it is a compile-time error for A to depend on B. A class directly depends on its direct base class (if any) and directly depends on the type within which it is immediately nested (if any).
When an interface IB extends an interface IA, it is a compile-time error for IA to depend on IB. An interface directly depends on its direct base interfaces (if any) and directly depends on the type within which it is immediately nested (if any).
Given these definitions, the complete set of types upon which a type depends is the reflexive and transitive closure of the directly depends on relationship.
Effect on existing programs
The rules presented here are intended to have no effect on the meaning of existing programs.
Example 1:
C#Copy
interface IA
{
    void M();
}
class C: IA // Error: IA.M has no concrete most specific override in C
{
    public static void M() { } // method unrelated to 'IA.M' because static
}
Example 2:
C#Copy
interface IA
{
    void M();
}
class Base: IA
{
    void IA.M() { }
}
class Derived: Base, IA // OK, all interface members have a concrete most specific override
{
    private void M() { } // method unrelated to 'IA.M' because private
}
The same rules give similar results to the analogous situation involving default interface methods:
C#Copy
interface IA
{
    void M() { }
}
class Derived: IA // OK, all interface members have a concrete most specific override
{
    private void M() { } // method unrelated to 'IA.M' because private
}
Closed issue: confirm that this is an intended consequence of the specification. Decision: YES
Runtime method resolution
Closed Issue: The spec should describe the runtime method resolution algorithm in the face of interface default methods. We need to ensure that the semantics are consistent with the language semantics, e.g. which declared methods do and do not override or implement an internal method.
CLR support API
In order for compilers to detect when they are compiling for a runtime that supports this feature, libraries for such runtimes are modified to advertise that fact through the API discussed in https://github.com/dotnet/corefx/issues/17116. We add
C#Copy
namespace System.Runtime.CompilerServices
{
    public static class RuntimeFeature
    {
        // Presence of the field indicates runtime support
        public const string DefaultInterfaceImplementation = nameof(DefaultInterfaceImplementation);
    }
}
Open issue: Is that the best name for the CLR feature? The CLR feature does much more than just that (e.g. relaxes protection constraints, supports overrides in interfaces, etc). Perhaps it should be called something like "concrete methods in interfaces", or "traits"?
Further areas to be specified
•	[ ] It would be useful to catalog the kinds of source and binary compatibility effects caused by adding default interface methods and overrides to existing interfaces.
Drawbacks
This proposal requires a coordinated update to the CLR specification (to support concrete methods in interfaces and method resolution). It is therefore fairly "expensive" and it may be worth doing in combination with other features that we also anticipate would require CLR changes.
Alternatives
None.
Unresolved questions
•	Open questions are called out throughout the proposal, above.
•	See also https://github.com/dotnet/csharplang/issues/406 for a list of open questions.
•	The detailed specification must describe the resolution mechanism used at runtime to select the precise method to be invoked.
•	The interaction of metadata produced by new compilers and consumed by older compilers needs to be worked out in detail. For example, we need to ensure that the metadata representation that we use does not cause the addition of a default implementation in an interface to break an existing class that implements that interface when compiled by an older compiler. This may affect the metadata representation that we can use.
•	The design must consider interoperation with other languages and existing compilers for other languages.
Resolved Questions
Abstract Override
The earlier draft spec contained the ability to "reabstract" an inherited method:
C#Copy
interface IA
{
    void M();
}
interface IB : IA
{
    override void M() { }
}
interface IC : IB
{
    override void M(); // make it abstract again
}
My notes for 2017-03-20 showed that we decided not to allow this. However, there are at least two use cases for it:
1.	The Java APIs, with which some users of this feature hope to interoperate, depend on this facility.
2.	Programming with traits benefits from this. Reabstraction is one of the elements of the "traits" language feature (https://en.wikipedia.org/wiki/Trait_(computer_programming)). The following is permitted with classes:
C#Copy
public abstract class Base
{
    public abstract void M();
}
public abstract class A : Base
{
    public override void M() { }
}
public abstract class B : A
{
    public override abstract void M(); // reabstract Base.M
}
Unfortunately this code cannot be refactored as a set of interfaces (traits) unless this is permitted. By the Jared principle of greed, it should be permitted.
Closed issue: Should reabstraction be permitted? [YES] My notes were wrong. The LDM notes say that reabstraction is permitted in an interface. Not in a class.
Virtual Modifier vs Sealed Modifier
From Aleksey Tsingauz:
We decided to allow modifiers explicitly stated on interface members, unless there is a reason to disallow some of them. This brings an interesting question around virtual modifier. Should it be required on members with default implementation?
We could say that:
•	if there is no implementation and neither virtual, nor sealed are specified, we assume the member is abstract.
•	if there is an implementation and neither abstract, nor sealed are specified, we assume the member is virtual.
•	sealed modifier is required to make a method neither virtual, nor abstract.
Alternatively, we could say that virtual modifier is required for a virtual member. I.e, if there is a member with implementation not explicitly marked with virtual modifier, it is neither virtual, nor abstract. This approach might provide better experience when a method is moved from a class to an interface:
•	an abstract method stays abstract.
•	a virtual method stays virtual.
•	a method without any modifier stays neither virtual, nor abstract.
•	sealed modifier cannot be applied to a method that is not an override.
What do you think?
Closed Issue: Should a concrete method (with implementation) be implicitly virtual? [YES]
Decisions: Made in the LDM 2017-04-05:
1.	non-virtual should be explicitly expressed through sealed or private.
2.	sealed is the keyword to make interface instance members with bodies non-virtual
3.	We want to allow all modifiers in interfaces
4.	Default accessibility for interface members is public, including nested types
5.	private function members in interfaces are implicitly sealed, and sealed is not permitted on them.
6.	Private classes (in interfaces) are permitted and can be sealed, and that means sealed in the class sense of sealed.
7.	Absent a good proposal, partial is still not allowed on interfaces or their members.
Binary Compatibility 1
When a library provides a default implementation
C#Copy
interface I1
{
    void M() { Impl1 }
}
interface I2 : I1
{
}
class C : I2
{
}
We understand that the implementation of I1.M in C is I1.M. What if the assembly containing I2 is changed as follows and recompiled
C#Copy
interface I2 : I1
{
    override void M() { Impl2 }
}
but C is not recompiled. What happens when the program is run? An invocation of (C as I1).M()
1.	Runs I1.M
2.	Runs I2.M
3.	Throws some kind of runtime error
Decision: Made 2017-04-11: Runs I2.M, which is the unambiguously most specific override at runtime.
Event accessors (closed)
Closed Issue: Can an event be overridden "piecewise"?
Consider this case:
C#Copy
public interface I1
{
    event T e1;
}
public interface I2 : I1
{
    override event T
    {
        add { }
        // error: "remove" accessor missing
    }
}
This "partial" implementation of the event is not permitted because, as in a class, the syntax for an event declaration does not permit only one accessor; both (or neither) must be provided. You could accomplish the same thing by permitting the abstract remove accessor in the syntax to be implicitly abstract by the absence of a body:
C#Copy
public interface I1
{
    event T e1;
}
public interface I2 : I1
{
    override event T
    {
        add { }
        remove; // implicitly abstract
    }
}
Note that this is a new (proposed) syntax. In the current grammar, event accessors have a mandatory body.
Closed Issue: Can an event accessor be (implicitly) abstract by the omission of a body, similarly to the way that methods in interfaces and property accessors are (implicitly) abstract by the omission of a body?
Decision: (2017-04-18) No, event declarations require both concrete accessors (or neither).
Reabstraction in a Class (closed)
Closed Issue: We should confirm that this is permitted (otherwise adding a default implementation would be a breaking change):
C#Copy
interface I1
{
    void M() { }
}
abstract class C : I1
{
    public abstract void M(); // implement I1.M with an abstract method in C
}
Decision: (2017-04-18) Yes, adding a body to an interface member declaration shouldn't break C.
Sealed Override (closed)
The previous question implicitly assumes that the sealed modifier can be applied to an override in an interface. This contradicts the draft specification. Do we want to permit sealing an override? Source and binary compatibility effects of sealing should be considered.
Closed Issue: Should we permit sealing an override?
Decision: (2017-04-18) Let's not allowed sealed on overrides in interfaces. The only use of sealed on interface members is to make them non-virtual in their initial declaration.
Diamond inheritance and classes (closed)
The draft of the proposal prefers class overrides to interface overrides in diamond inheritance scenarios:
We require that every interface and class have a most specific override for every interface method among the overrides appearing in the type or its direct and indirect interfaces. The most specific override is a unique override that is more specific than every other override. If there is no override, the method itself is considered the most specific override.
One override M1 is considered more specific than another override M2 if M1 is declared on type T1, M2 is declared on type T2, and either
1.	T1 contains T2 among its direct or indirect interfaces, or
2.	T2 is an interface type but T1 is not an interface type.
The scenario is this
C#Copy
interface IA
{
    void M();
}
interface IB : IA
{
    override void M() { WriteLine("IB"); }
}
class Base : IA
{
    void IA.M() { WriteLine("Base"); }
}
class Derived : Base, IB // allowed?
{
    static void Main()
    {
        IA a = new Derived();
        a.M();           // what does it do?
    }
}
We should confirm this behavior (or decide otherwise)
Closed Issue: Confirm the draft spec, above, for most specific override as it applies to mixed classes and interfaces (a class takes priority over an interface). See https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#diamonds-with-classes.
Interface methods vs structs (closed)
There are some unfortunate interactions between default interface methods and structs.
C#Copy
interface IA
{
    public void M() { }
}
struct S : IA
{
}
Note that interface members are not inherited:
C#Copy
var s = default(S);
s.M(); // error: 'S' does not contain a member 'M'
Consequently, the client must box the struct to invoke interface methods
C#Copy
IA s = default(S); // an S, boxed
s.M(); // ok
Boxing in this way defeats the principal benefits of a struct type. Moreover, any mutation methods will have no apparent effect, because they are operating on a boxed copy of the struct:
C#Copy
interface IB
{
    public void Increment() { P += 1; }
    public int P { get; set; }
}
struct T : IB
{
    public int P { get; set; } // auto-property
}

T t = default(T);
Console.WriteLine(t.P); // prints 0
(t as IB).Increment();
Console.WriteLine(t.P); // prints 0
Closed Issue: What can we do about this:
1.	Forbid a struct from inheriting a default implementation. All interface methods would be treated as abstract in a struct. Then we may take time later to decide how to make it work better.
2.	Come up with some kind of code generation strategy that avoids boxing. Inside a method like IB.Increment, the type of this would perhaps be akin to a type parameter constrained to IB. In conjunction with that, to avoid boxing in the caller, non-abstract methods would be inherited from interfaces. This may increase compiler and CLR implementation work substantially.
3.	Not worry about it and just leave it as a wart.
4.	Other ideas?
Decision: Not worry about it and just leave it as a wart. See https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#structs-and-default-implementations.
Base interface invocations (closed)
The draft spec suggests a syntax for base interface invocations inspired by Java: Interface.base.M(). We need to select a syntax, at least for the initial prototype. My favorite is base<Interface>.M().
Closed Issue: What is the syntax for a base member invocation?
Decision: The syntax is base(Interface).M(). See https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#base-invocation. The interface so named must be a base interface, but does not need to be a direct base interface.
Open Issue: Should base interface invocations be permitted in class members?
Decision: Yes. https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#base-invocation
Overriding non-public interface members (closed)
In an interface, non-public members from base interfaces are overridden using the override modifier. If it is an "explicit" override that names the interface containing the member, the access modifier is omitted.
Closed Issue: If it is an "implicit" override that does not name the interface, does the access modifier have to match?
Decision: Only public members may be implicitly overridden, and the access must match. See https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-18.md#dim-implementing-a-non-public-interface-member-not-in-list.
Open Issue: Is the access modifier required, optional, or omitted on an explicit override such as override void IB.M() {}?
Open Issue: Is override required, optional, or omitted on an explicit override such as void IB.M() {}?
How does one implement a non-public interface member in a class? Perhaps it must be done explicitly?
C#Copy
interface IA
{
    internal void MI();
    protected void MP();
}
class C : IA
{
    // are these implementations?
    internal void MI() {}
    protected void MP() {}
}
Closed Issue: How does one implement a non-public interface member in a class?
Decision: You can only implement non-public interface members explicitly. See https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-18.md#dim-implementing-a-non-public-interface-member-not-in-list.
Decision: No override keyword permitted on interface members. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#does-an-override-in-an-interface-introduce-a-new-member
Binary Compatibility 2 (closed)
Consider the following code in which each type is in a separate assembly
C#Copy
interface I1
{
    void M() { Impl1 }
}
interface I2 : I1
{
    override void M() { Impl2 }
}
interface I3 : I1
{
}
class C : I2, I3
{
}
We understand that the implementation of I1.M in C is I2.M. What if the assembly containing I3 is changed as follows and recompiled
C#Copy
interface I3 : I1
{
    override void M() { Impl3 }
}
but C is not recompiled. What happens when the program is run? An invocation of (C as I1).M()
1.	Runs I1.M
2.	Runs I2.M
3.	Runs I3.M
4.	Either 2 or 3, deterministically
5.	Throws some kind of runtime exception
Decision: Throw an exception (5). See https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#issues-in-default-interface-methods.
Permit partial in interface? (closed)
Given that interfaces may be used in ways analogous to the way abstract classes are used, it may be useful to declare them partial. This would be particularly useful in the face of generators.
Proposal: Remove the language restriction that interfaces and members of interfaces may not be declared partial.
Decision: Yes. See https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#permit-partial-in-interface.
Main in an interface? (closed)
Open Issue: Is a static Main method in an interface a candidate to be the program's entry point?
Decision: Yes. See https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#main-in-an-interface.
Confirm intent to support public non-virtual methods (closed)
Can we please confirm (or reverse) our decision to permit non-virtual public methods in an interface?
C#Copy
interface IA
{
    public sealed void M() { }
}
Semi-Closed Issue: (2017-04-18) We think it is going to be useful, but will come back to it. This is a mental model tripping block.
Decision: Yes. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#confirm-that-we-support-public-non-virtual-methods.
Does an override in an interface introduce a new member? (closed)
There are a few ways to observe whether an override declaration introduces a new member or not.
C#Copy
interface IA
{
    void M(int x) { }
}
interface IB : IA
{
    override void M(int y) { }
}
interface IC : IB
{
    static void M2()
    {
        M(y: 3); // permitted?
    }
    override void IB.M(int z) { } // permitted? What does it override?
}
Open Issue: Does an override declaration in an interface introduce a new member? (closed)
In a class, an overriding method is "visible" in some senses. For example, the names of its parameters take precedence over the names of parameters in the overridden method. It may be possible to duplicate that behavior in interfaces, as there is always a most specific override. But do we want to duplicate that behavior?
Also, it is possible to "override" an override method? [Moot]
Decision: No override keyword permitted on interface members. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#does-an-override-in-an-interface-introduce-a-new-member.
Properties with a private accessor (closed)
We say that private members are not virtual, and the combination of virtual and private is disallowed. But what about a property with a private accessor?
C#Copy
interface IA
{
    public virtual int P
    {
        get => 3;
        private set => { }
    }
}
Is this allowed? Is the set accessor here virtual or not? Can it be overridden where it is accessible? Does the following implicitly implement only the get accessor?
C#Copy
class C : IA
{
    public int P
    {
        get => 4;
        set { }
    }
}
Is the following presumably an error because IA.P.set isn't virtual and also because it isn't accessible?
C#Copy
class C : IA
{
    int IA.P
    {
        get => 4;
        set { }
    }
}
Decision: The first example looks valid, while the last does not. This is resolved analogously to how it already works in C#. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#properties-with-a-private-accessor
Base Interface Invocations, round 2 (closed)
Our previous "resolution" to how to handle base invocations doesn't actually provide sufficient expressiveness. It turns out that in C# and the CLR, unlike Java, you need to specify both the interface containing the method declaration and the location of the implementation you want to invoke.
I propose the following syntax for base calls in interfaces. I’m not in love with it, but it illustrates what any syntax must be able to express:
C#Copy
interface I1 { void M(); }
interface I2 { void M(); }
interface I3 : I1, I2 { void I1.M() { } void I2.M() { } }
interface I4 : I1, I2 { void I1.M() { } void I2.M() { } }
interface I5 : I3, I4
{
    void I1.M()
    {
        base<I3>(I1).M(); // calls I3's implementation of I1.M
        base<I4>(I1).M(); // calls I4's implementation of I1.M
    }
    void I2.M()
    {
        base<I3>(I2).M(); // calls I3's implementation of I2.M
        base<I4>(I2).M(); // calls I4's implementation of I2.M
    }
}
If there is no ambiguity, you can write it more simply
C#Copy
interface I1 { void M(); }
interface I3 : I1 { void I1.M() { } }
interface I4 : I1 { void I1.M() { } }
interface I5 : I3, I4
{
    void I1.M()
    {
        base<I3>.M(); // calls I3's implementation of I1.M
        base<I4>.M(); // calls I4's implementation of I1.M
    }
}
Or
C#Copy
interface I1 { void M(); }
interface I2 { void M(); }
interface I3 : I1, I2 { void I1.M() { } void I2.M() { } }
interface I5 : I3
{
    void I1.M()
    {
        base(I1).M(); // calls I3's implementation of I1.M
    }
    void I2.M()
    {
        base(I2).M(); // calls I3's implementation of I2.M
    }
}
Or
C#Copy
interface I1 { void M(); }
interface I3 : I1 { void I1.M() { } }
interface I5 : I3
{
    void I1.M()
    {
        base.M(); // calls I3's implementation of I1.M
    }
}
Decision: Decided on base(N.I1<T>).M(s), conceding that if we have an invocation binding there may be problem here later on. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-11-14.md#default-interface-implementations
Warning for struct not implementing default method? (closed)
@vancem asserts that we should seriously consider producing a warning if a value type declaration fails to override some interface method, even if it would inherit an implementation of that method from an interface. Because it causes boxing and undermines constrained calls.
Decision: This seems like something more suited for an analyzer. It also seems like this warning could be noisy, since it would fire even if the default interface method is never called and no boxing will ever occur. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#warning-for-struct-not-implementing-default-method
Interface static constructors (closed)
When are interface static constructors run? The current CLI draft proposes that it occurs when the first static method or field is accessed. If there are neither of those then it might never be run??
[2018-10-09 The CLR team proposes "Going to mirror what we do for valuetypes (cctor check on access to each instance method)"]
Decision: Static constructors are also run on entry to instance methods, if the static constructor was not beforefieldinit, in which case static constructors are run before access to the first static field. https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-10-17.md#when-are-interface-static-constructors-run
Design meetings
2017-03-08 LDM Meeting Notes 2017-03-21 LDM Meeting Notes 2017-03-23 meeting "CLR Behavior for Default Interface Methods" 2017-04-05 LDM Meeting Notes 2017-04-11 LDM Meeting Notes 2017-04-18 LDM Meeting Notes 2017-04-19 LDM Meeting Notes 2017-05-17 LDM Meeting Notes 2017-05-31 LDM Meeting Notes 2017-06-14 LDM Meeting Notes 2018-10-17 LDM Meeting Notes 2018-11-14 LDM Meeting Notes
C# Operators
Operators in C# are some special symbols that perform some action on operands. In mathematics, the plus symbol (+) do the sum of the left and right numbers. In the same way, C# includes various operators for different types of operations.
The following example demonstrates the + operator in C#.
Example: + Operator
int x = 5 + 5;
int y = 10 + x;
int z = x + y;
Try it
In the above example, + operator adds two number literals and assign the result to a variable. It also adds the values of two int variables and assigns the result to a variable.
Some operators behave differently based on the type of the operands. For example, + operator concatenates two strings.
Example: + Operator with Strings
string greet1 = "Hello " + "World!";
string greet2 = greeting + name;
Try it
 Note:
There are two types of operators in C#, Unary operators and Binary operators. Unary operators act on single operand, whereas binary operators act on two operands (left-hand side and right-hand side operand of an operator).
C# includes the following categories of operators:
•	Arithmetic operators
•	Assignment operators
•	Comparison operators
•	Equality operators
•	Boolean logical operators
•	Betwise and shift operators
•	Member access operators
•	Type-cast operators
•	Pointer related operators
 
5
Arithmetic Operators
The arithmetic operators perform arithmetic operations on all the numeric type operands such as sbyte, byte, short, ushort, int, uint, long, ulong, float, double, and decimal.
Operator	Name	Description	Example	
+	Addition	Computes the sum of left and right operands.	int x = 5 + 5;	Try it

-	Subtraction	Subtract the right operand from the left operand	int x = 5 - 1;	Try it

*	Multiplication	Multiply left and right operand	int x = 5 * 1;	Try it

/	Division	Divides the left operand by the right operand	int x = 10 / 2;	Try it

%	Remainder	Computes the remainder after dividing its left operand by its right operand	int x = 5 % 2;	Try it

++	Unary increment	Unary increment ++ operator increases its operand by 1	x++	Try it

--	Unary decrement	Unary decrement -- operator decreases its operand by 1	x--	Try it

+	Unary plus	Returns the value of operand	+5	Try it

-	Unary minus	Computes the numeric negation of its operand.	-5	Try it

Assignment Operators
The assignment operator = assigns its right had value to its left-hand variable, property, or indexer. It can also be used with other arithmetic, Boolean logical, and bitwise operators.
Operator	Name	Description	Example	
=	Assignment	Assigns its right had value to its left-hand variable, property or indexer.	x = 10;	Try it

x op= y	Compound assignment	Short form of x =x op y where op = any arithmetic, Boolean logical, and bitwise operator.	x += 5;	Try it

??=	Null-coalescing assignment	C# 8 onwards, ??= assigns value of the right operand only if the left operand is null	x ??= 5;	Try it

Comparison Operators
Comparison operators compre two numeric operands and returns true or false.
Operator	Description	Example	
<	Returns true if the left operand is less than the right operand	x < y;	Try it

>	Returns true if the left operand is greater than the right operand	x > y;	Try it

<=	Returns true if the left operand is less than or equal to the right operand	x <= y	Try it

>=	Returns true if the left operand is greater than or equal to the right operand	x >= y;	Try it

Equality Operators
The equality operator checks whether the two operands are equal or not.
Operator	Description	Example	
==	Returns true if operands are equal otherwise false.	x == y;	Try it

!=	Returns true if operands are not equal otherwise false.	x != y;	Try it

Boolean Logical Operators
The Boolean logical operators perform a logical operation on bool operands.
Operator	Description	Example	
!	Reverses the bool result of bool expression. Returns false if result is true and returns true if result is false.	!false	Try it

&&	Computes the logical AND of its bool operands. Returns true both operands are true, otherwise returns false.	x && y;	Try it

||	Computes the logical OR of its bool operands. Returns true when any one operand is true.	x || y;	Try it

Operator Evaluation & Precedence
Evaluation of the operands in an expression starts from left to right. If multiple operators are used in an expression, then the operators with higher priority are evaluated before the operators with lower priority.
The following table lists operators starting with the higher precedence operators to lower precedence operators.
Operators	Category
x.y, x?.y, x?[y], f(x), a[i], x++, x--, new, typeof, checked, unchecked, default, nameof, delegate, sizeof, stackalloc, x->y	Primary
+x, -x, !x, ~x, ++x, --x, ^x, (T)x, await, &x, *x, true and false	Unary
x..y	Range
x * y, x / y, x % y	Multiplicative
x + y, x � y	Additive
x << y, x >> y	Shift
x < y, x > y, x <= y, x >= y, is, as	Relational and type-testing
x == y, x != y	Equality
x & y	Boolean logical AND
x ^ y	Boolean logical XOR
x | y	Boolean logical OR
x && y	Conditional AND
x || y	Conditional OR
x ?? y	Null-coalescing operator
c ? t : f	Conditional operator
x = y, x += y, x -= y, x *= y, x /= y, x %= y, x &= y, x |= y, x ^= y, x <<= y, x >>= y, x ??= y, =>	Assignment and lambda declaration
The following example demonstrates operator precedence:
Example: Operator Precedence
int a = 5 + 3 * 3;
int b = 5 + 3 * 3 /  2; 
int c = (5 + 3) * 3 /  2; 
int d = (3 * 3) * (3 / 3 + 5);
C# - Partial Classes and Methods
In C#, you can split the implementation of a class, a struct, a method, or an interface in multiple .cs files using the partial keyword. The compiler will combine all the implementation from multiple .cs files when the program is compiled.
Consider the following EmployeeProps.cs and EmployeeMethods.cs files that contain the Employee class.
EmployeeProps.cs
public partial class Employee
{
    public int EmpId { get; set; }
    public string Name { get; set; }
}
EmployeeMethods.cs
public partial class Employee
{
    //constructor
    public Employee(int id, string name){
        this.EmpId = id;
        this.Name = name;
    }

    public void DisplayEmpInfo() {
        Console.WriteLine(this.EmpId + " " this.Name);
    }
}
Above, EmployeeProps.cs contains properties of the Employee class, and EmployeeMethods.cs contains all the methods of the Employee class. These will be compiled as one Employee class.
Example: Combined Class
public class Employee
{
    public int EmpId { get; set; }
    public string Name { get; set; }

    public Employee(int id, string name){
        this.EmpId = id;
        this.Name = name;
    }

    public void DisplayEmpInfo(){
        Console.WriteLine(this.EmpId + " " this.Name );
    }
}
Skip Ad
Rules for Partial Classes
•	All the partial class definitions must be in the same assembly and namespace.
•	All the parts must have the same accessibility like public or private, etc.
•	If any part is declared abstract, sealed or base type then the whole class is declared of the same type.
•	Different parts can have different base types and so the final class will inherit all the base types.
•	The Partial modifier can only appear immediately before the keywords class, struct, or interface.
•	Nested partial types are allowed.
Partial Methods
Partial classes or structs can contain a method that split into two separate .cs files of the partial class or struct. One of the two .cs files must contain a signature of the method, and other file can contain an optional implementation of the partial method. Both declaration and implementation of a method must have the partial keyword.
EmployeeProps.cs
public partial class Employee
{
    public Employee() { 
        GenerateEmpId();
    }
    public int EmpId { get; set; }
    public string Name { get; set; }

    partial void GenerateEmployeeId();

}
EmployeeMethods.cs
public partial class Employee
{
    partial void GenerateEmployeeId()
    {
        this.EmpId = random();
    }
}
Above, EmployeeProps.cs contains the declaration of the partial method GenerateEmployeeId() which is being used in the constructor. EmployeeMethods.cs contains the implementation of the GenerateEmployeeId() method. The following demonstrates creates an object the Employee class which used the partial method.
EmployeeMethods.cs
class Program
{
    static void Main(string[] args)
    {
        var emp = new Employee();
        Console.WriteLine(emp.EmpId); // prints genereted id

        Console.ReadLine();
    }
}
Rules for Partial Methods
•	Partial methods must use the partial keyword and must return void.
•	Partial methods can have in or ref but not out parameters.
•	Partial methods are implicitly private methods, so cannot be virtual.
•	Partial methods can be static methods.
•	Partial methods can be generic.
C# - Static Class, Methods, Constructors, Fields
________________________________________
Updated on: June 28, 2020
________________________________________
In C#, static means something which cannot be instantiated. You cannot create an object of a static class and cannot access static members using an object.
C# classes, variables, methods, properties, operators, events, and constructors can be defined as static using the static modifier keyword.
Static Class
Apply the static modifier before the class name and after the access modifier to make a class static. The following defines a static class with static fields and methods.
Example: C# Static Class
public static class Calculator
{
    private static int _resultStorage = 0;
    
    public static string Type = "Arithmetic";

    public static int Sum(int num1, int num2)
    {
        return num1 + num2;
    }

    public static void Store(int result)
    {
        _resultStorage = result;
    }
}
Above, the Calculator class is a static. All the members of it are also static.
You cannot create an object of the static class; therefore the members of the static class can be accessed directly using a class name like ClassName.MemberName, as shown below.
Example: Accessing Static Members
class Program
{
    static void Main(string[] args)
    {
        var result = Calculator.Sum(10, 25); // calling static method
        Calculator.Store(result); 

        var calcType = Calculator.Type; // accessing static variable
        Calculator.Type = "Scientific"; // assign value to static variable
    }
}
Try it
2.5M
96
Entity Framework Core Quiz
Rules for Static Class
1.	Static classes cannot be instantiated.
2.	All the members of a static class must be static; otherwise the compiler will give an error.
3.	A static class can contain static variables, static methods, static properties, static operators, static events, and static constructors.
4.	A static class cannot contain instance members and constructors.
5.	Indexers and destructors cannot be static
6.	var cannot be used to define static members. You must specify a type of member explicitly after the static keyword.
7.	Static classes are sealed class and therefore, cannot be inherited.
8.	A static class cannot inherit from other classes.
9.	Static class members can be accessed using ClassName.MemberName.
10.	A static class remains in memory for the lifetime of the application domain in which your program resides.
Static Members in Non-static Class
The normal class (non-static class) can contain one or more static methods, fields, properties, events and other non-static members.
It is more practical to define a non-static class with some static members, than to declare an entire class as static.
Static Fields
Static fields in a non-static class can be defined using the static keyword.
Static fields of a non-static class is shared across all the instances. So, changes done by one instance would reflect in others.
Example: Shared Static Fields
public class StopWatch
{
    public static int NoOfInstances = 0;
    
    // instance constructor
    public StopWatch()
    {
        StopWatch.NoOfInstances++;
    }
}

class Program
{
    static void Main(string[] args)
    {
        StopWatch sw1 = new StopWatch();
        StopWatch sw2 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances); //2 
			
        StopWatch sw3 = new StopWatch();
        StopWatch sw4 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances);//4
    }
}
Try it
Static Methods
You can define one or more static methods in a non-static class. Static methods can be called without creating an object. You cannot call static methods using an object of the non-static class.
The static methods can only call other static methods and access static members. You cannot access non-static members of the class in the static methods.
Example: Static Method
class Program
{
    static int counter = 0;
    string name = "Demo Program";

    static void Main(string[] args)
    {
        counter++; // can access static fields
        Display("Hello World!"); // can call static methods

        name = "New Demo Program"; //Error: cannot access non-static members
        SetRootFolder("C:\MyProgram"); //Error: cannot call non-static method
    }

    static void Display(string text)
    {
        Console.WriteLine(text);
    }

    public void SetRootFolder(string path) {  }
}
Rules for Static Methods
1.	Static methods can be defined using the static keyword before a return type and after an access modifier.
2.	Static methods can be overloaded but cannot be overridden.
3.	Static methods can contain local static variables.
4.	Static methods cannot access or call non-static variables unless they are explicitly passed as parameters.
Static Constructors
A non-static class can contain a parameterless static constructor. It can be defined with the static keyword and without access modifiers like public, private, and protected.
The following example demonstrates the difference between static constructor and instance constructor.
Example: Static Constructor vs Instance Constructor
public class StopWatch
{
    // static constructor
    static StopWatch()
    {
        Console.WriteLine("Static constructor called");
    }

    // instance constructor
    public StopWatch()
    {
        Console.WriteLine("Instance constructor called");
    }

    // static method
    public static void DisplayInfo()
    {
        Console.WriteLine("DisplayInfo called");
    }

    // instance method
    public void Start() { }

    // instance method
    public void Stop() {  }
}
Try it
Above, the non-static class StopWatch contains a static constructor and also a non-static constructor.
The static constructor is called only once whenever the static method is used or creating an instance for the first time. The following example shows that the static constructor gets called when the static method called for the first time. Calling the static method second time onwards won't call a static constructor.
Example: Static Constructor Execution
StopWatch.DisplayInfo(); // static constructor called here
StopWatch.DisplayInfo(); // none of the constructors called here
Output:
Static constructor called.
DisplayInfo called
DisplayInfo called
The following example shows that the static constructor gets called when you create an instance for the first time.
Example: Static Constructor Execution
StopWatch sw1 = new StopWatch(); // First static constructor and then instance constructor called 
StopWatch sw2 = new StopWatch();// only instance constructor called 
StopWatch.DisplayInfo();
Output:
Static constructor called
instance constructor called
instance constructor called
DisplayInfo called
Rules for Static Constructors
1.	The static constructor is defined using the static keyword and without using access modifiers public, private, or protected.
2.	A non-static class can contain one parameterless static constructor. Parameterized static constructors are not allowed.
3.	Static constructor will be executed only once in the lifetime. So, you cannot determine when it will get called in an application if a class is being used at multiple places.
4.	A static constructor can only access static members. It cannot contain or access instance members.
Learn more about Static class and static constructor.
 Note:
Static members are stored in a special area in the memory called High-Frequency Heap. Static members of non-static classes are shared across all the instances of the class. So, the changes done by one instance will be reflected in all the other instances.
C# Arrays
________________________________________
Updated on: May 10, 2020
________________________________________
A variable is used to store a literal value, whereas an array is used to store multiple literal values.
An array is the data structure that stores a fixed number of literal values (elements) of the same data type. Array elements are stored contiguously in the memory.
In C#, an array can be of three types: single-dimensional, multidimensional, and jagged array. Here you will learn about the single-dimensional array.
The following figure illustrates an array representation.
 Array Representation
 
Array Declaration and Initialization
An array can be declared using by specifying the type of its elements with square brackets.
Example: Array Declaration
int[] evenNums;  // integer array

string[] cities; // string array
The following declares and adds values into an array in a single statement.
Example: Array Declaration & Initialization
int[] evenNums = new int[5]{ 2, 4, 6, 8, 10 }; 

string[] cities = new string[3]{ "Mumbai", "London", "New York" };
Above, evenNums array can store up to five integers. The number 5 in the square brackets new int[5] specifies the size of an array. In the same way, the size of cities array is three. Array elements are added in a comma-separated list inside curly braces { }.
Arrays type variables can be declared using var without square brackets.
Example: Array Declaration using var
var evenNums = new int[]{ 2, 4, 6, 8, 10}; 

var cities = new string[]{ "Mumbai", "London", "New York" }; 
If you are adding array elements at the time of declaration, then size is optional. The compiler will infer its size based on the number of elements inside curly braces, as shown below.
Example: Short Syntax of Array Declaration
int[] evenNums = { 2, 4, 6, 8, 10}; 

string[] cities = { "Mumbai", "London", "New York" }
The following example demonstrate invalid array declarations.
Example: Invalid Array Creation
//must specify the size 
int[] evenNums = new int[]; 

//number of elements must be equal to the specified size 
int[] evenNums = new int[5] { 2, 4 };

//cannot use var with array initializer
var evenNums = { 2, 4, 6, 8, 10}; 
Late Initialization
It is not necessary to declare and initialize an array in a single statement. You can first declare an array then initialize it later on using the new operator.
Example: Late Initialization
int[] evenNums;

evenNums = new int[5];
// or
evenNums = new int[]{ 2, 4, 6, 8, 10 };
Accessing Array Elements
Array elements can be accessed using an index. An index is a number associated with each array element, starting with index 0 and ending with array size - 1.
The following example add/update and retrieve array elements using indexes.
Example: Access Array Elements using Indexes
int[] evenNums = new int[5];
evenNums[0] = 2;
evenNums[1] = 4;
//evenNums[6] = 12;  //Throws run-time exception IndexOutOfRange

Console.WriteLine(evenNums[0]);  //prints 2
Console.WriteLine(evenNums[1]);  //prints 4
Try it
Note that trying to add more elements than its specified size will result in IndexOutOfRangeException.
Accessing Array using for Loop
Use the for loop to access array elements. Use the length property of an array in conditional expression of the for loop.
Example: Accessing Array Elements using for Loop
int[] evenNums = { 2, 4, 6, 8, 10 };

for(int i = 0; i < evenNums.Length; i++)
            Console.WriteLine(evenNums[i]);  

for(int i = 0; i < evenNums.Length; i++)
    evenNums[i] = evenNums[i] + 10;  // update the value of each element by 10
Try it
Accessing Array using foreach Loop
Use foreach loop to read values of an array elements without using index.
Example: Accessing Array using foreach Loop
int[] evenNums = { 2, 4, 6, 8, 10}; 
string[] cities = { "Mumbai", "London", "New York" }; 

foreach(var item in evenNums)
            Console.WriteLine(item);   

foreach(var city in cities)
            Console.WriteLine(city);  
Try it
LINQ Methods
All the arrays in C# are derived from an abstract base class System.Array.
The Array class implements the IEnumerable interface, so you can LINQ extension methods such as Max(), Min(), Sum(), reverse(), etc. See the list of all extension methods here.
Example: LINQ Methods
int[] nums = new int[5]{ 10, 15, 16, 8, 6 };

nums.Max(); // returns 16
nums.Min(); // returns 6
nums.Sum(); // returns 55
nums.Average(); // returns 55
Try it
The System.Array class also includes methods for creating, manipulating, searching, and sorting arrays. See list of all Array methods here.
Example: Array Methods
int[] nums = new int[5]{ 10, 15, 16, 8, 6 };

Array.Sort(nums); // sorts array 
Array.Reverse(nums); // sorts array in descending order
Array.ForEach(nums, n => Console.WriteLine(n)); // iterates array
Array.BinarySearch(nums, 5);// binary search 
Try it
Passing Array as Argument
An array can be passed as an argument to a method parameter. Arrays are reference types, so the method can change the value of the array elements.
Example: Passing Array as Argument
public static void Main(){
            int[] nums = { 1, 2, 3, 4, 5 };

    UpdateArray(nums); 

            foreach(var item in nums)
            Console.WriteLine(item);   
}
                    
public static void UpdateArray(int[] arr)
{
            for(int i = 0; i < arr.Length; i++)
        arr[i] = arr[i] + 10;   
}
C# - Multidimensional Arrays
C# supports multidimensional arrays up to 32 dimensions. The multidimensional array can be declared by adding commas in the square brackets. For example, [,] declares two-dimensional array, [, ,] declares three-dimensional array, [, , ,] declares four-dimensional array, and so on. So, in a multidimensional array, no of commas = No of Dimensions - 1.
The following declares multidimensional arrays.
Example: Multidimensional Arrays
int[,] arr2d; // two-dimensional array
int[, ,] arr3d; // three-dimensional array
int[, , ,] arr4d ; // four-dimensional array
int[, , , ,] arr5d; // five-dimensional array
Let's understand the two-dimensional array. The following initializes the two-dimensional array.
Example: two-dimensional Array
int[,] arr2d = new int[3,2]{ 
                                {1, 2}, 
                                {3, 4}, 
                                {5, 6} 
                            };

// or 
int[,] arr2d = { 
                    {1, 2}, 
                    {3, 4}, 
                    {5, 6} 
                };
In the above example of a two-dimensional array, [3, 2] defines the no of rows and columns. The first rank denotes the no of rows, and the second rank defines no of columns. The following figure illustrates the two-dimensional array divided into rows and columns.
 Two-dimensional Array
The following access values of the two-dimensional array.
Example: Access two-dimensional Array
int[,] arr2d = new int[3,2]{ 
                                {1, 2}, 
                                {3, 4}, 
                                {5, 6} 
                            };

arr2d[0, 0]; //returns 1
arr2d[0, 1]; //returns 2
arr2d[1, 0]; //returns 3
arr2d[1, 1]; //returns 4
arr2d[2, 0]; //returns 5
arr2d[2, 1]; //returns 6
//arr2d[3, 0]; //throws run-time error as there is no 4th row
Try it
In the above example, the value of a two-dimensional array can be accessed by index no of row and column as [row index, column index]. So, [0, 0] returns the value of the first row and first column and [1, 1] returns the value from the second row and second column.
Now, let's understand the three-dimensional array. The following declares and initializes three-dimensional arrays.
Example: Three-dimensional Array
int[, ,] arr3d1 = new int[1, 2, 2]{
                { { 1, 2}, { 3, 4} }
            };

int[, ,] arr3d2 = new int[2, 2, 2]{
                { {1, 2}, {3, 4} },
                { {5, 6}, {7, 8} }
            };

int[, ,] arr3d3 = new int[2, 2, 3]{
                { { 1, 2, 3}, {4, 5, 6} },
                { { 7, 8, 9}, {10, 11, 12} }
            };

arr3d2[0, 0, 0]; // returns 1 
arr3d2[0, 0, 1]; // returns 2 
arr3d2[0, 1, 0]; // returns 3 
arr3d2[0, 1, 1]; // returns 4 
arr3d2[1, 0, 0]; // returns 5 
arr3d2[1, 0, 1]; // returns 6 
arr3d2[1, 1, 0]; // returns 7 
arr3d2[1, 1, 1]; // returns 8 
Try it
As you can see in the above example, [1, 2, 2] of arr3d1 specifies that it will contain one row of two-dimensional array [2, 2]. arr3d2 specifies dimensions [2, 2, 2], which indicates that it includes two rows of two-dimensional array of [2, 2]. Thus, the first rank indicates the number of rows of inner two-dimensional arrays.
Now, consider the following four-dimensional array.
Example: Four-dimensional Array
int[,,,] arr4d1 = new int[1, 1, 2, 2]{
                { 
                    { { 1, 2}, { 3, 4} }     
                }
            };

arr4d1[0, 0, 0, 0]; // returns 1
arr4d1[0, 0, 0, 1]; // returns 2
arr4d1[0, 0, 1, 0]; // returns 3
arr4d1[0, 0, 1, 1]; // returns 4

int[,,,] arr4d2 = new int[1, 2, 2, 2]{
		{
			{ {1, 2}, {3, 4} },
			{ {5, 6}, {7, 8} }
		}
	};

arr4d2[0, 0, 0, 0]; // returns 1
arr4d2[0, 0, 0, 1]; // returns 2
arr4d2[0, 0, 1, 0]; // returns 3
arr4d2[0, 0, 1, 1]; // returns 4
arr4d2[0, 1, 0, 0]; // returns 5
arr4d2[0, 1, 0, 1]; // returns 6
arr4d2[0, 1, 1, 0]; // returns 7
arr4d2[0, 1, 1, 1]; // returns 8
Try it
In the above example, the four-dimensional array arr4d1 specifies [1, 1, 2, 2], which indicates that it includes one row of the three-dimensional array.
In the same way, you can declare and initialize five-dimensional, six-dimensional array, and up to 32-dimensional arrays in C#.
C# Questions & Answers
Start C# Skill Test
C# Jagged Arrays: An Array of Array
A jagged array is an array of array. Jagged arrays store arrays instead of literal values.
A jagged array is initialized with two square brackets [][]. The first bracket specifies the size of an array, and the second bracket specifies the dimensions of the array which is going to be stored.
The following example declares jagged arrays.
Example: Jagged Arrays
int[][] jArray1 = new int[2][]; // can include two single-dimensional arrays 
int[][,] jArray2 = new int[3][,]; // can include three two-dimensional arrays 
In the above example, jArray1 can store up to two single-dimensional arrays. jArray2 can store up to three two-dimensional, arrays [,] specifies the two-dimensional array.
Example: Jagged Array
int[][] jArray = new int[2][]; 

jArray[0] = new int[3]{1, 2, 3};

jArray[1] = new int[4]{4, 5, 6, 7 };

You can also initialize a jagged array upon declaration like the below.
Example: Jagged Array
int[][] jArray = new int[2][]{
                new int[3]{1, 2, 3},

                new int[4]{4, 5, 6, 7}
            };

jArray[0][0]; //returns 1
jArray[0][1]; //returns 2
jArray[0][2]; //returns 3
jArray[1][0]; //returns 4
jArray[1][1]; //returns 5
jArray[1][2]; //returns 6
jArray[1][3]; //returns 7
Try it
You can access a jagged array using two for loops, as shown below.
Example: Jagged Array
int[][] jArray = new int[2][]{
                new int[3]{1, 2, 3},

                new int[4]{4, 5, 6, 7}
            };

for(int i=0; i<jArray.Length; i++)
{
	for(int j=0; j < (jArray[i]).Length; j++)
		Console.WriteLine(jArray[i][j]);
}
Try it
The following jagged array stores two-dimensional arrays where the second bracket [,] indicates the two-dimensional array.
Example: Jagged Array
int[][,] jArray = new int[2][,];

jArray[0] = new int[3, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };
jArray[1] = new int[2, 2] { { 7, 8 }, { 9, 10 } }; 

jArray[0][1, 1]; //returns 4
                                             
jArray[1][1, 0]; //returns 9
                                             
jArray[1][1, 1]; //returns 10
Try it
If you add one more bracket then it will be array of array of arry.
Example: Jagged Array
int[][][] intJaggedArray = new int[2][][] 
                            {
                                new int[2][]  
                                { 
                                    new int[3] { 1, 2, 3},
                                    new int[2] { 4, 5} 
                                },
                                new int[1][]
                                { 
                                    new int[3] { 7, 8, 9}
                                }
                            };

Console.WriteLine(intJaggedArray[0][0][0]); // 1

Console.WriteLine(intJaggedArray[0][1][1]); // 5
    
Console.WriteLine(intJaggedArray[1][0][2]); // 9
Try it
In the above example of a jagged array, three brackets [][][] means an array of array of array. So, intJaggedArray will contain two elements, which means two arrays. Now, each of these arrays also contains an array (single-dimension). intJaggedArray[0][0][0] points to the first element of first inner array. intJaggedArray[1][0][2] points to the third element of the second inner array. The following figure illustrates this.
 Jagged Array
C# Questions & Answers
Start C# Skill Test
C# Indexers
An indexer is a special type of property that allows a class or a structure to be accessed like an array for its internal collection. C# allows us to define custom indexers, generic indexers, and also overload indexers.
An indexer can be defined the same way as property with this keyword and square brackets [].
Syntax
<return type> this[<parameter type> index]
{
    get{
        // return the value from the specified index of an internal collection
    }
    set{
        // set values at the specified index in an internal collection
    }
}
The following example defines an indexer in the class.
Example: Indexer
class StringDataStore
{
    private string[] strArr = new string[10]; // internal data storage

    public string this[int index]
    {
        get
        {
            if (index < 0 || index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

                return strArr[index];
        }

        set
        {
            if (index < 0 ||  index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

            strArr[index] = value;
        }
    }
}
The above StringDataStore class defines an indexer for its private array strArr. So now, you can use the StringDataStore like an array to add and retrieve string values from strArr, as shown below.
Example: Indexer
StringDataStore strStore = new StringDataStore();

strStore[0] = "One";
strStore[1] = "Two";
strStore[2] = "Three";
strStore[3] = "Four";
        
for(int i = 0; i < 10 ; i++)
    Console.WriteLine(strStore[i]);
Try it
Output:
One
Two
Three
Four
You can use expression-bodied syntax for get and set from C# 7 onwards.
Example: Indexer
class StringDataStore
{
    private string[] strArr = new string[10]; // internal data storage

    public string this[int index]
    {
        get => strArr[index];

        set => strArr[index] = value;
    }
}
Try it
Generic Indexer
Indexer can also be generic. The following generic class includes generic indexer.
Example: Generic Indexer
class DataStore<T>
{
    private T[] store; 

    public DataStore()
    {
        store = new T[10];
    }

    public DataStore(int length)
    {
        store = new T[length];
    }

    public T this[int index]
    {
        get
        {
            if (index < 0 &&  index >= store.Length)
                throw new IndexOutOfRangeException("Index out of range");

                return store[index];
        }

        set
        {
            if (index < 0 ||  index >= store.Length)
                throw new IndexOutOfRangeException("Index out of range");

            store[index] = value;
        }
    }

    public int Length
    {
        get
        {
            return store.Length;
        }
    }
}
Try it
The above generic indexer can be used with any data type. The following example demonstrates the use of generic indexer.
Example:
DataStore<int> grades = new DataStore<int>();
grades[0] = 100;
grades[1] = 25;
grades[2] = 34;
grades[3] = 42;
grades[4] = 12;
grades[5] = 18;
grades[6] = 2;
grades[7] = 95;
grades[8] = 75;
grades[9] = 53;

for (int i = 0; i < grades.Length;i++)
    Console.WriteLine(grades[i]);

DataStore<string> names = new DataStore<string>(5);
names[0] = "Steve";
names[1] = "Bill";
names[2] = "James";
names[3] = "Ram";
names[4] = "Andy";

for (int i = 0; i < names.Length;i++)
    Console.WriteLine(names[i]);
Try it
Overload Indexer
You can be overloaded with the different data types for index. The following example overloads an indexer with int type index as well as string type index.
Example: Override Indexer
class StringDataStore
{
    private string[] strArr = new string[10]; // internal data storage

    // int type indexer
    public string this[int index]
    {
        get
        {
            if (index < 0 || index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

            return strArr[index];
        }

        set
        {
            if (index < 0 || index >= strArr.Length)
                throw new IndexOutOfRangeException("Index out of range");

            strArr[index] = value;
        }
    }

    // string type indexer
    public string this[string name]
    {
        get
        {
            foreach (string str in strArr){
                if(str.ToLower() == name.ToLower())        
                    return str;
                }
                    
            return null;
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        StringDataStore strStore = new StringDataStore();

        strStore[0] = "One";
        strStore[1] = "Two";
        strStore[2] = "Three";
        strStore[3] = "Four";
        
        Console.WriteLine(strStore["one"]);
        Console.WriteLine(strStore["two"]);
        Console.WriteLine(strStore["Three"]);
        Console.WriteLine(strStore["Four"]);
    }
}
Try it
 Note:
Indexer does not allow ref and out paramters.
C# Generics
Generic means the general form, not specific. In C#, generic means not specific to a particular data type.
C# allows you to define generic classes, interfaces, abstract classes, fields, methods, static methods, properties, events, delegates, and operators using the type parameter and without the specific data type. A type parameter is a placeholder for a particular type specified when creating an instance of the generic type.
A generic type is declared by specifying a type parameter in an angle brackets after a type name, e.g. TypeName<T> where T is a type parameter.
Generic Class
Generic classes are defined using a type parameter in an angle brackets after the class name. The following defines a generic class.
Example: Define Generic Class
class DataStore<T>
{
    public T Data { get; set; }
}
Above, the DataStore is a generic class. T is called type parameter, which can be used as a type of fields, properties, method parameters, return types, and delegates in the DataStore class. For example, Data is generic property because we have used a type parameter T as its type instead of the specific data type.
 Note
It is not required to use T as a type parameter. You can give any name to a type parameter. Generally, T is used when there is only one type parameter. It is recommended to use a more readable type parameter name as per requirement like TSession, TKey, TValue etc. Learn more about Type Parameter Naming Guidelines
You can also define multiple type parameters separated by a comma.
Example: Generic Class with Multiple Type Parameters
class KeyValuePair<TKey, TValue>
{
    public TKey Key { get; set; }
    public TValue Value { get; set; }
}
2.5M
96
Entity Framework Core Quiz
Instantiating Generic Class
You can create an instance of generic classes by specifying an actual type in angle brackets. The following creates an instance of the generic class DataStore.
DataStore<string> store = new DataStore<string>();
Above, we specified the string type in the angle brackets while creating an instance. So, T will be replaced with a string type wherever T is used in the entire class at compile-time. Therefore, the type of Data property would be a string.
The following figure illustrates how generics works.
 
You can assign a string value to the Data property. Trying to assign values other than string will result in a compile-time error.
DataStore<string> store = new DataStore<string>();
store.Data = "Hello World!";
//store.Data = 123; //compile-time error
You can specify the different data types for different objects, as shown below.
Example: Generic class
DataStore<string> strStore = new DataStore<string>();
strStore.Data = "Hello World!";
//strStore.Data = 123; // compile-time error

DataStore<int> intStore = new DataStore<int>();
intStore.Data = 100;
//intStore.Data = "Hello World!"; // compile-time error

KeyValuePair<int, string> kvp1 = new KeyValuePair<int, string>();
kvp1.Key = 100;
kvp1.Value = "Hundred";

KeyValuePair<string, string> kvp2 = new KeyValuePair<string, string>();
kvp2.Key = "IT";
kvp2.Value = "Information Technology";
Try it
Generic Class Characteristics
•	A generic class increases the reusability. The more type parameters mean more reusable it becomes. However, too much generalization makes code difficult to understand and maintain.
•	A generic class can be a base class to other generic or non-generic classes or abstract classes.
•	A generic class can be derived from other generic or non-generic interfaces, classes, or abstract classes.
Generic Fields
A generic class can include generic fields. However, it cannot be initialized.
Example: Generic Field
class DataStore<T>
{
    public T data;
}
The following declares a generic array.
Example: Generic Array
class DataStore<T>
{
    public T[] data = new T[10];
}
Generic Methods
A method declared with the type parameters for its return type or parameters is called a generic method.
Example: Generic Methods
class DataStore<T>
{
    private T[] _data = new T[10];
    
    public void AddOrUpdate(int index, T item)
    {
        if(index >= 0 && index < 10)
            _data[index] = item;
    }

    public T GetData(int index)
    {
        if(index >= 0 && index < 10)
            return _data[index];
        else 
            return default(T);
    }
}
Above, the AddorUpdate() and the GetData() methods are generic methods. The actual data type of the item parameter will be specified at the time of instantiating the DataStore<T> class, as shown below.
Example: Generic Methods
DataStore<string> cities = new DataStore<string>();
cities.AddOrUpdate(0, "Mumbai");
cities.AddOrUpdate(1, "Chicago");
cities.AddOrUpdate(2, "London");

DataStore<int> empIds = new DataStore<int>();
empIds.AddOrUpdate(0, 50);
empIds.AddOrUpdate(1, 65);
empIds.AddOrUpdate(2, 89);
Try it
The generic parameter type can be used with multiple parameters with or without non-generic parameters and return type. The followings are valid generic method overloading.
Example: Generic Method Overloading
public void AddOrUpdate(int index, T data) { }
public void AddOrUpdate(T data1, T data2) { }
public void AddOrUpdate<U>(T data1, U data2) { }
public void AddOrUpdate(T data) { }
A non-generic class can include generic methods by specifying a type parameter in angle brackets with the method name, as shown below.
Example: Generic Method in Non-generic Class
class Printer
{
    public void Print<T>(T data)
    {
        Console.WriteLine(data);
    }
}

Printer printer = new Printer();
printer.Print<int>(100);
printer.Print(200); // type infer from the specified value
printer.Print<string>("Hello");
printer.Print("World!"); // type infer from the specified value
Try it
Advantages of Generics
1.	Generics increase the reusability of the code. You don't need to write code to handle different data types.
2.	Generics are type-safe. You get compile-time errors if you try to use a different data type than the one specified in the definition.
3.	Generic has a performance advantage because it removes the possibilities of boxing and unboxing.
4.	C# Generic Constraints
5.	C# allows you to use constraints to restrict client code to specify certain types while instantiating generic types. It will give a compile-time error if you try to instantiate a generic type using a type that is not allowed by the specified constraints.
6.	You can specify one or more constraints on the generic type using the where clause after the generic type name.
7.	Syntax:
8.	GenericTypeName<T> where T  : contraint1, constraint2
9.	The following example demonstrates a generic class with a constraint to reference types when instantiating the generic class.
10.	Example: Declare Generic Constraints
11.	class DataStore<T> where T : class
12.	{
13.	    public T Data { get; set; }
14.	}
15.	Above, we applied the class constraint, which means only a reference type can be passed as an argument while creating the DataStore class object. So, you can pass reference types such as class, interface, delegate, or array type. Passing value types will give a compile-time error, so we cannot pass primitive data types or struct types.
16.	DataStore<string> store = new DataStore<string>(); // valid
17.	DataStore<MyClass> store = new DataStore<MyClass>(); // valid
18.	DataStore<IMyInterface> store = new DataStore<IMyInterface>(); // valid
19.	DataStore<IEnumerable> store = new DataStore<IMyInterface>(); // valid
20.	DataStore<ArrayList> store = new DataStore<ArrayList>(); // valid
21.	//DataStore<int> store = new DataStore<int>(); // compile-time error 
22.	The following table lists the types of generic constraints.
Constraint	Description
class	The type argument must be any class, interface, delegate, or array type.
class?	The type argument must be a nullable or non-nullable class, interface, delegate, or array type.
struct
The type argument must be non-nullable value types such as primitive data types int, char, bool, float, etc.
new()
The type argument must be a reference type which has a public parameterless constructor. It cannot be combined with struct and unmanaged constraints.
notnull	Available C# 8.0 onwards. The type argument can be non-nullable reference types or value types. If not, then the compiler generates a warning instead of an error.
unmanaged	The type argument must be non-nullable unmanged types.

base class name
The type argument must be or derive from the specified base class. The Object, Array, ValueType classes are disallowed as a base class constraint. The Enum, Delegate, MulticastDelegate are disallowed as base class constraint before C# 7.3.
<base class name>?	The type argument must be or derive from the specified nullable or non-nullable base class
<interface name>	The type argument must be or implement the specified interface.
<interface name>?	The type argument must be or implement the specified interface. It may be a nullable reference type, a non-nullable reference type, or a value type
where T: U	The type argument supplied for T must be or derive from the argument supplied for U.
23.	where T : struct
24.	The following example demonstrates the struct constraint that restricts type argument to be non-nullable value type only.
25.	Example: struct Constraints
26.	class DataStore<T> where T : struct
27.	{
28.	    public T Data { get; set; }
29.	}
30.	
31.	DataStore<int> store = new DataStore<int>(); // valid
32.	DataStore<char> store = new DataStore<char>(); // valid
33.	DataStore<MyStruct> store = new DataStore<MyStruct>(); // valid
34.	//DataStore<string> store = new DataStore<string>(); // compile-time error 
35.	//DataStore<IMyInterface> store = new DataStore<IMyInterface>(); // compile-time error 
36.	//DataStore<ArrayList> store = new DataStore<ArrayList>(); // compile-time error 
37.	where T : new()
38.	The following example demonstrates the struct constraint that restricts type argument to be non-nullable value type only.
39.	Example: new() Constraint
40.	class DataStore<T> where T : class, new()
41.	{
42.	    public T Data { get; set; }
43.	}
44.	
45.	DataStore<MyClass> store = new DataStore<MyClass>(); // valid
46.	DataStore<ArrayList> store = new DataStore<ArrayList>(); // valid
47.	//DataStore<string> store = new DataStore<string>(); // compile-time error 
48.	//DataStore<int> store = new DataStore<int>(); // compile-time error 
49.	//DataStore<IMyInterface> store = new DataStore<IMyInterface>(); // compile-time error 
50.	where T : baseclass
51.	The following example demonstrates the base class constraint that restricts type argument to be a derived class of the specified class, abstract class, or an interface.
52.	Example: BaseClass Constraint
53.	class DataStore<T> where T : IEnumerable
54.	{
55.	    public T Data { get; set; }
56.	}
57.	
58.	DataStore<ArrayList> store = new DataStore<ArrayList>(); // valid
59.	DataStore<List> store = new DataStore<List>(); // valid
60.	//DataStore<string> store = new DataStore<string>(); // compile-time error 
61.	//DataStore<int> store = new DataStore<int>(); // compile-time error 
62.	//DataStore<IMyInterface> store = new DataStore<IMyInterface>(); // compile-time error 
63.	//DataStore<MyClass> store = new DataStore<MyClass>(); // compile-time error 
64.	C# Generic & Non-generic Collections
65.	C# includes specialized classes that store series of values or objects are called collections.
66.	There are two types of collections available in C#: non-generic collections and generic collections.
67.	The System.Collections namespace contains the non-generic collection types and System.Collections.Generic namespace includes generic collection types.
68.	In most cases, it is recommended to use the generic collections because they perform faster than non-generic collections and also minimize exceptions by giving compile-time errors.
69.	Generic Collections
70.	C# includes the following generic collection classes in the System.Collections.Generic namespace.
Generic Collections	Description
List<T>
Generic List<T> contains elements of specified type. It grows automatically as you add elements in it.
Dictionary<TKey,TValue>
Dictionary<TKey,TValue> contains key-value pairs.
SortedList<TKey,TValue>
SortedList stores key and value pairs. It automatically adds the elements in ascending order of key by default.
Queue<T>
Queue<T> stores the values in FIFO style (First In First Out). It keeps the order in which the values were added. It provides an Enqueue() method to add values and a Dequeue() method to retrieve values from the collection.
Stack<T>
Stack<T> stores the values as LIFO (Last In First Out). It provides a Push() method to add a value and Pop() & Peek() methods to retrieve values.
Hashset<T>	Hashset<T> contains non-duplicate elements. It eliminates duplicate elements.
71.	Non-generic Collections
Non-generic Collections	Usage
ArrayList
ArrayList stores objects of any type like an array. However, there is no need to specify the size of the ArrayList like with an array as it grows automatically.
SortedList
SortedList stores key and value pairs. It automatically arranges elements in ascending order of key by default. C# includes both, generic and non-generic SortedList collection.
Stack
Stack stores the values in LIFO style (Last In First Out). It provides a Push() method to add a value and Pop() & Peek() methods to retrieve values. C# includes both, generic and non-generic Stack.
Queue
Queue stores the values in FIFO style (First In First Out). It keeps the order in which the values were added. It provides an Enqueue() method to add values and a Dequeue() method to retrieve values from the collection. C# includes generic and non-generic Queue.
Hashtable
Hashtable stores key and value pairs. It retrieves the values by comparing the hash value of the keys.
BitArray	BitArray manages a compact array of bit values, which are represented as Booleans, where true indicates that the bit is on (1) and false indicates the bit is off (0).
C# - ArrayList
In C#, the ArrayList is a non-generic collection of objects whose size increases dynamically. It is the same as Array except that its size increases dynamically.
An ArrayList can be used to add unknown data where you don't know the types and the size of the data.
Create an ArrayList
The ArrayList class included in the System.Collections namespace. Create an object of the ArrayList using the new keyword.
Example: Create an ArrayList
using System.Collections;

ArrayList arlist = new ArrayList(); 
// or 
var arlist = new ArrayList(); // recommended 
C# - List<T>
The List<T> is a collection of strongly typed objects that can be accessed by index and having methods for sorting, searching, and modifying list. It is the generic version of the ArrayList that comes under System.Collections.Generic namespace.
List<T> Characteristics
•	List<T> equivalent of the ArrayList, which implements IList<T>.
•	It comes under System.Collections.Generic namespace.
•	List<T> can contain elements of the specified type. It provides compile-time type checking and doesn't perform boxing-unboxing because it is generic.
•	Elements can be added using the Add(), AddRange() methods or collection-initializer syntax.
•	Elements can be accessed by passing an index e.g. myList[0]. Indexes start from zero.
•	List<T> performs faster and less error-prone than the ArrayList.
Creating a List
The List<T> is a generic collection, so you need to specify a type parameter for the type of data it can store. The following example shows how to create list and add elements.
Example: Adding elements in List
List<int> primeNumbers = new List<int>();
primeNumbers.Add(2); // adding elements using add() method
primeNumbers.Add(3);
primeNumbers.Add(5);
primeNumbers.Add(7);

var cities = new List<string>();
cities.Add("New York");
cities.Add("London");
cities.Add("Mumbai");
cities.Add("Chicago");
cities.Add(null);// nulls are allowed for reference type list

//adding elements using collection-initializer syntax
var bigCities = new List<string>()
                    {
                        "New York",
                        "London",
                        "Mumbai",
                        "Chicago"                    
                    };
Try it
In the above example, List<int> primeNumbers = new List<int>(); creates a list of int type. In the same way, cities and bigCities are string type list. You can then add elements in a list using the Add() method or the collection-initializer syntax.
You can also add elements of the custom classes using the collection-initializer syntax. The following adds objects of the Student class in the List<Student>.
Example: Add Custom Class Objects in List
var students = new List<Student>() { 
                new Student(){ Id = 1, Name="Bill"},
                new Student(){ Id = 2, Name="Steve"},
                new Student(){ Id = 3, Name="Ram"},
                new Student(){ Id = 4, Name="Abdul"}
            };
2.5M
96
Entity Framework Core Quiz
Adding an Array in a List
Use the AddRange() method to add all the elements from an array or another collection to List.
AddRange() signature: void AddRange(IEnumerable<T> collection)
Example: Add Arrays in List
string[] cities = new string[3]{ "Mumbai", "London", "New York" };

var popularCities = new List<string>();

// adding an array in a List
popularCities.AddRange(cities);

var favouriteCities = new List<string>();

// adding a List 
favouriteCities.AddRange(popularCities);
Try it
Accessing a List
A list can be accessed by an index, a for/foreach loop, and using LINQ queries. Indexes of a list start from zero. Pass an index in the square brackets to access individual list items, same as array. Use a foreach or for loop to iterate a List<T> collection.
Example: Accessing List
List<int> numbers = new List<int>() { 1, 2, 5, 7, 8, 10 };
Console.WriteLine(numbers[0]); // prints 1
Console.WriteLine(numbers[1]); // prints 2
Console.WriteLine(numbers[2]); // prints 5
Console.WriteLine(numbers[3]); // prints 7

// using foreach LINQ method
numbers.ForEach(num => Console.WriteLine(num + ", "));//prints 1, 2, 5, 7, 8, 10,

// using for loop
for(int i = 0; i < numbers.Count; i++)
    Console.WriteLine(numbers[i]);
Try it
Accessing a List using LINQ
The List<T> implements the IEnumerable interface. So, we can query a list using LINQ query syntax or method syntax, as shown below.
Example: LINQ Query on List
var students = new List<Student>() { 
                new Student(){ Id = 1, Name="Bill"},
                new Student(){ Id = 2, Name="Steve"},
                new Student(){ Id = 3, Name="Ram"},
                new Student(){ Id = 4, Name="Abdul"}
            };

//get all students whose name is Bill
var result = from s in students
	     where s.Name == "Bill"
	     select s;
		
foreach(var student in result)
    Console.WriteLine(student.Id + ", " + student.Name);
Try it
Insert Elements in List
Use the Insert() method inserts an element into the List<T> collection at the specified index.
Insert() signature:void Insert(int index, T item);
Example: Insert elements into List
var numbers = new List<int>(){ 10, 20, 30, 40 };

numbers.Insert(1, 11);// inserts 11 at 1st index: after 10.

foreach (var num in numbers)
    Console.Write(num);
Try it
Remove Elements from List
Use the Remove() method to remove the first occurrence of the specified element in the List<T> collection. Use the RemoveAt() method to remove an element from the specified index. If no element at the specified index, then the ArgumentOutOfRangeException will be thrown.
Remove() signature: bool Remove(T item)
RemoveAt() signature: void RemoveAt(int index)
Example: Remove elements from List
var numbers = new List<int>(){ 10, 20, 30, 40, 10 };

numbers.Remove(10); // removes the first 10 from a list

numbers.RemoveAt(2); //removes the 3rd element (index starts from 0)

//numbers.RemoveAt(10); //throws ArgumentOutOfRangeException

foreach (var el in intList)
    Console.Write(el); //prints 20 30
Try it
Check Elements in List
Use the Contains() method to determine whether an element is in the List<T> or not.
Example: Contains()
var numbers = new List<int>(){ 10, 20, 30, 40 };
numbers.Contains(10); // returns true
numbers.Contains(11); // returns false
numbers.Contains(20); // returns true
Try it
List<T> Class Hierarchy
The following diagram illustrates the List<T> hierarchy.
 
List<T> Class Properties and Methods
The following table lists the important properties and methods of List<T> class:
Property	Usage
Items	Gets or sets the element at the specified index
Count	Returns the total number of elements exists in the List<T>
Method	Usage
Add	Adds an element at the end of a List<T>.
AddRange	Adds elements of the specified collection at the end of a List<T>.
BinarySearch	Search the element and returns an index of the element.
Clear	Removes all the elements from a List<T>.
Contains	Checks whether the specified element exists or not in a List<T>.
Find	Finds the first element based on the specified predicate function.
Foreach	Iterates through a List<T>.
Insert	Inserts an element at the specified index in a List<T>.
InsertRange	Inserts elements of another collection at the specified index.
Remove	Removes the first occurrence of the specified element.
RemoveAt	Removes the element at the specified index.
RemoveRange	Removes all the elements that match the supplied predicate function.
Sort	Sorts all the elements.
TrimExcess	Sets the capacity to the actual number of elements.
TrueForAll	Determines whether every element in the List<T> matches the conditions defined by the specified predicate.
C# Questions & Answers
Start C# Skill Test
C# - SortedList<TKey, TValue>
The SortedList<TKey, TValue>, and SortedList are collection classes that can store key-value pairs that are sorted by the keys based on the associated IComparer implementation. For example, if the keys are of primitive types, then sorted in ascending order of keys.
C# supports generic and non-generic SortedList. It is recommended to use generic SortedList<TKey, TValue> because it performs faster and less error-prone than the non-generic SortedList.
SortedList Characteristics
•	SortedList<TKey, TValue> is an array of key-value pairs sorted by keys.
•	Sorts elements as soon as they are added. Sorts primitive type keys in ascending order and object keys based on IComparer<T>.
•	Comes under System.Collection.Generic namespace.
•	A key must be unique and cannot be null.
•	A value can be null or duplicate.
•	A value can be accessed by passing associated key in the indexer mySortedList[key]
•	Contains elements of type KeyValuePair<TKey, TValue>
•	It uses less memory than SortedDictionary<TKey,TValue>.
•	It is faster in the retrieval of data once sorted, whereas SortedDictionary<TKey, TValue> is faster in insertion and removing key-value pairs.
2.5M
96
Entity Framework Core Quiz
Creating a SortedList
The following example demonstrates how to create a generic SortedList<TKey, TValue>, and add key-value pairs in it.
Example: Create a SortedList and Add Elements
//SortedList of int keys, string values 
SortedList<int, string> numberNames = new SortedList<int, string>();
numberNames.Add(3, "Three");
numberNames.Add(1, "One");
numberNames.Add(2, "Two");
numberNames.Add(4, null);
numberNames.Add(10, "Ten");
numberNames.Add(5, "Five");

//The following will throw exceptions
//numberNames.Add("Three", 3); //Compile-time error: key must be int type
//numberNames.Add(1, "One"); //Run-time exception: duplicate key
//numberNames.Add(null, "Five");//Run-time exception: key cannot be null
Try it
In the above example, a generic SortedList<TKey, TValue> object is created by specifying the type of keys and values it is going to store. The SortedList<int, string> will store keys of int type and values of string type.
The Add() method is used to add a single key-value pair in a SortedList. Keys cannot be null or duplicate. If found, it will throw a run-time exception. Values can be duplicate and null if the type is nullable.
Use the collection-initializer syntax to initialize a SortedList with multiple key-value pairs at the time of instantiating, as shown below.
//Creating a SortedList of string keys, string values 
//using collection-initializer syntax
SortedList<string,string> cities = new SortedList<string,string>()
                                    {
                                        {"London", "UK"},
                                        {"New York", "USA"},
                                        { "Mumbai", "India"},
                                        {"Johannesburg", "South Africa"}
                                    };
The SortedList rearranges key-value pairs in the ascending order of keys as soon as a key-value pair added. The following example displays all the keys and values using foreach loop.
Example: SortedList Elements Default Sorting Order
SortedList<int,string> numberNames = new SortedList<int,string>()
                                    {
                                        {3, "Three"},
                                        {5, "Five"},
                                        {1, "One"}
                                    };

Console.WriteLine("---Initial key-values--");

foreach(KeyValuePair<int, string> kvp in numberNames)
    Console.WriteLine("key: {0}, value: {1}", kvp.Key , kvp.Value );

numberNames.Add(6, "Six");
numberNames.Add(2, "Two");
numberNames.Add(4, "Four");

Console.WriteLine("---After adding new key-values--");

foreach(var kvp in numberNames)
    Console.WriteLine("key: {0}, value: {1}", kvp.Key , kvp.Value );
Try it
Output:
---Initial key-values--
key: 1, value: One
key: 3, value: Three
key: 5, value: Five
---After adding new key-values--
key: 1, value: One
key: 2, value: Two
key: 3, value: Three
key: 4, value: Four
key: 5, value: Five
key: 6, value: Six
Accessing SortedList
Specify a key in the indexer sortedList[key], to get or set a value in the SortedList.
Example: Access SortedList Values
SortedList<int,string> numberNames = new SortedList<int,string>()
                                    {
                                        {3, "Three"},
                                        {1, "One"},
                                        {2, "Two"}
                                    };

Console.WriteLine(numberNames[1]); //output: One
Console.WriteLine(numberNames[2]); //output: Two
Console.WriteLine(numberNames[3]); //output: Three
//Console.WriteLine(numberNames[10]); //run-time KeyNotFoundException

numberNames[2] = "TWO"; //updates value
numberNames[4] = "Four"; //adds a new key-value if a key does not exists
Try it
Above, numberNames[10] will throw a KeyNotFoundException because specified key 10 does not exist in a sortedlist. To prevent this exception, use ContainsKey() or TryGetValue() methods, as shown below.
Example: ContainsKey() and TryGetValue()
SortedList<int, string> numberNames = new SortedList<int,string>()
                                    {
                                        {3, "Three"},
                                        {1, "One"},
                                        {2, "Two"}
                                    };
if(numberNames.ContainsKey(4)){
    numberNames[4] = "four";
}

int result;
if(numberNames.TryGetValue(4, out result))
    Console.WriteLine("Key: {0}, Value: {1}", 4, result); 
Try it
Output:
Key:4, Value: Four
Use Keys and Values properties if you want to iterate a SortedList using a for loop.
Example: Iterate SortedList using For Loop
SortedList<int, string> numberNames = new SortedList<int,string>()
                                    {
                                        {3, "Three"},
                                        {1, "One"},
                                        {2, "Two"}
                                    };
for (int i = 0; i < numberNames.Count; i++)
{
    Console.WriteLine("key: {0}, value: {1}", numberNames.Keys[i], numberNames.Values[i]);
}
Try it
Output:
key: 1, value: One
key: 2, value: Two
key: 3, value: Three
Remove Elements from SortedList
Use the Remove(key) and RemoveAt(index) methods to remove key-value pairs from a SortedList.
Example: Remove Elements
SortedList<int,string> numberNames = new SortedList<int,string>()
                                    {
                                        {3, "Three"},
                                        {1, "One"},
                                        {2, "Two"},
                                        {5, "Five"},
                                        {4, "Four"}
                                    };
    
numberNames.Remove(1);//removes key 1 pair
numberNames.Remove(10);//removes key 1 pair, no error if not exists

numberNames.RemoveAt(0);//removes key-value pair from index 0 
//numberNames.RemoveAt(10);//run-time exception: ArgumentOutOfRangeException

foreach(var kvp in numberNames)
	Console.WriteLine("key: {0}, value: {1}", kvp.Key , kvp.Value );
Try it
Output:
key: 3, value: Three
key: 4, value: Four
key: 5, value: Five
SortedList Class Hierarchy
The following diagram illustrates the SortedList hierarchy.
 
Learn more about SortedList Methods and Properties on docs.microsoft.com
SortedList<TKey,TValue> Class
•	Reference
Feedback
Definition
Namespace:
System.Collections.Generic
Assembly:
System.dll
Represents a collection of key/value pairs that are sorted by key based on the associated IComparer<T> implementation.
C#Copy
[System.Runtime.InteropServices.ComVisible(false)]
[System.Serializable]
public class SortedList<TKey,TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, System.Collections.Generic.IDictionary<TKey,TValue>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>, System.Collections.IDictionary
Type Parameters
TKey
The type of keys in the collection.
TValue
The type of values in the collection.
Inheritance
Object
SortedList<TKey,TValue>
Derived
System.IdentityModel.Metadata.IndexedProtocolEndpointDictionary
Attributes
ComVisibleAttribute SerializableAttribute
Implements
ICollection<KeyValuePair<TKey,TValue>>  IDictionary<TKey,TValue>  IEnumerable<KeyValuePair<TKey,TValue>>  IEnumerable<T>  IReadOnlyCollection<KeyValuePair<TKey,TValue>>  IReadOnlyDictionary<TKey,TValue>  ICollection  IDictionary  IEnumerable
Examples
The following code example creates an empty SortedList<TKey,TValue> of strings with string keys and uses the Add method to add some elements. The example demonstrates that the Add method throws an ArgumentException when attempting to add a duplicate key.
The example uses the Item[] property (the indexer in C#) to retrieve values, demonstrating that a KeyNotFoundException is thrown when a requested key is not present, and showing that the value associated with a key can be replaced.
The example shows how to use the TryGetValue method as a more efficient way to retrieve values if a program often must try key values that are not in the sorted list, and it shows how to use the ContainsKey method to test whether a key exists before calling the Add method.
The example shows how to enumerate the keys and values in the sorted list and how to enumerate the keys and values alone using the Keys property and the Values property.
Finally, the example demonstrates the Remove method.
C#Copy
using System;
using System.Collections.Generic;

public class Example
{
    public static void Main()
    {
        // Create a new sorted list of strings, with string
        // keys.
        SortedList<string, string> openWith =
            new SortedList<string, string>();

        // Add some elements to the list. There are no
        // duplicate keys, but some of the values are duplicates.
        openWith.Add("txt", "notepad.exe");
        openWith.Add("bmp", "paint.exe");
        openWith.Add("dib", "paint.exe");
        openWith.Add("rtf", "wordpad.exe");

        // The Add method throws an exception if the new key is
        // already in the list.
        try
        {
            openWith.Add("txt", "winword.exe");
        }
        catch (ArgumentException)
        {
            Console.WriteLine("An element with Key = \"txt\" already exists.");
        }

        // The Item property is another name for the indexer, so you
        // can omit its name when accessing elements.
        Console.WriteLine("For key = \"rtf\", value = {0}.",
            openWith["rtf"]);

        // The indexer can be used to change the value associated
        // with a key.
        openWith["rtf"] = "winword.exe";
        Console.WriteLine("For key = \"rtf\", value = {0}.",
            openWith["rtf"]);

        // If a key does not exist, setting the indexer for that key
        // adds a new key/value pair.
        openWith["doc"] = "winword.exe";

        // The indexer throws an exception if the requested key is
        // not in the list.
        try
        {
            Console.WriteLine("For key = \"tif\", value = {0}.",
                openWith["tif"]);
        }
        catch (KeyNotFoundException)
        {
            Console.WriteLine("Key = \"tif\" is not found.");
        }

        // When a program often has to try keys that turn out not to
        // be in the list, TryGetValue can be a more efficient
        // way to retrieve values.
        string value = "";
        if (openWith.TryGetValue("tif", out value))
        {
            Console.WriteLine("For key = \"tif\", value = {0}.", value);
        }
        else
        {
            Console.WriteLine("Key = \"tif\" is not found.");
        }

        // ContainsKey can be used to test keys before inserting
        // them.
        if (!openWith.ContainsKey("ht"))
        {
            openWith.Add("ht", "hypertrm.exe");
            Console.WriteLine("Value added for key = \"ht\": {0}",
                openWith["ht"]);
        }

        // When you use foreach to enumerate list elements,
        // the elements are retrieved as KeyValuePair objects.
        Console.WriteLine();
        foreach( KeyValuePair<string, string> kvp in openWith )
        {
            Console.WriteLine("Key = {0}, Value = {1}",
                kvp.Key, kvp.Value);
        }

        // To get the values alone, use the Values property.
        IList<string> ilistValues = openWith.Values;

        // The elements of the list are strongly typed with the
        // type that was specified for the SortedList values.
        Console.WriteLine();
        foreach( string s in ilistValues )
        {
            Console.WriteLine("Value = {0}", s);
        }

        // The Values property is an efficient way to retrieve
        // values by index.
        Console.WriteLine("\nIndexed retrieval using the Values " +
            "property: Values[2] = {0}", openWith.Values[2]);

        // To get the keys alone, use the Keys property.
        IList<string> ilistKeys = openWith.Keys;

        // The elements of the list are strongly typed with the
        // type that was specified for the SortedList keys.
        Console.WriteLine();
        foreach( string s in ilistKeys )
        {
            Console.WriteLine("Key = {0}", s);
        }

        // The Keys property is an efficient way to retrieve
        // keys by index.
        Console.WriteLine("\nIndexed retrieval using the Keys " +
            "property: Keys[2] = {0}", openWith.Keys[2]);

        // Use the Remove method to remove a key/value pair.
        Console.WriteLine("\nRemove(\"doc\")");
        openWith.Remove("doc");

        if (!openWith.ContainsKey("doc"))
        {
            Console.WriteLine("Key \"doc\" is not found.");
        }
    }
}

/* This code example produces the following output:

An element with Key = "txt" already exists.
For key = "rtf", value = wordpad.exe.
For key = "rtf", value = winword.exe.
Key = "tif" is not found.
Key = "tif" is not found.
Value added for key = "ht": hypertrm.exe

Key = bmp, Value = paint.exe
Key = dib, Value = paint.exe
Key = doc, Value = winword.exe
Key = ht, Value = hypertrm.exe
Key = rtf, Value = winword.exe
Key = txt, Value = notepad.exe

Value = paint.exe
Value = paint.exe
Value = winword.exe
Value = hypertrm.exe
Value = winword.exe
Value = notepad.exe

Indexed retrieval using the Values property: Values[2] = winword.exe

Key = bmp
Key = dib
Key = doc
Key = ht
Key = rtf
Key = txt

Indexed retrieval using the Keys property: Keys[2] = doc

Remove("doc")
Key "doc" is not found.
 */
Remarks
The SortedList<TKey,TValue> generic class is an array of key/value pairs with O(log n) retrieval, where n is the number of elements in the dictionary. In this, it is similar to the SortedDictionary<TKey,TValue> generic class. The two classes have similar object models, and both have O(log n) retrieval. Where the two classes differ is in memory use and speed of insertion and removal:
•	SortedList<TKey,TValue> uses less memory than SortedDictionary<TKey,TValue>.
•	SortedDictionary<TKey,TValue> has faster insertion and removal operations for unsorted data, O(log n) as opposed to O(n) for SortedList<TKey,TValue>.
•	If the list is populated all at once from sorted data, SortedList<TKey,TValue> is faster than SortedDictionary<TKey,TValue>.
Another difference between the SortedDictionary<TKey,TValue> and SortedList<TKey,TValue> classes is that SortedList<TKey,TValue> supports efficient indexed retrieval of keys and values through the collections returned by the Keys and Values properties. It is not necessary to regenerate the lists when the properties are accessed, because the lists are just wrappers for the internal arrays of keys and values. The following code shows the use of the Values property for indexed retrieval of values from a sorted list of strings:
C#Copy
string v = mySortedList.Values[3];
SortedList<TKey,TValue> is implemented as an array of key/value pairs, sorted by the key. Each element can be retrieved as a KeyValuePair<TKey,TValue> object.
Key objects must be immutable as long as they are used as keys in the SortedList<TKey,TValue>. Every key in a SortedList<TKey,TValue> must be unique. A key cannot be null, but a value can be, if the type of values in the list, TValue, is a reference type.
SortedList<TKey,TValue> requires a comparer implementation to sort and to perform comparisons. The default comparer Comparer<T>.Default checks whether the key type TKey implements System.IComparable<T> and uses that implementation, if available. If not, Comparer<T>.Default checks whether the key type TKey implements System.IComparable. If the key type TKey does not implement either interface, you can specify a System.Collections.Generic.IComparer<T> implementation in a constructor overload that accepts a comparer parameter.
The capacity of a SortedList<TKey,TValue> is the number of elements the SortedList<TKey,TValue> can hold. As elements are added to a SortedList<TKey,TValue>, the capacity is automatically increased as required by reallocating the internal array. The capacity can be decreased by calling TrimExcess or by setting the Capacity property explicitly. Decreasing the capacity reallocates memory and copies all the elements in the SortedList<TKey,TValue>.
.NET Framework only: For very large SortedList<TKey,TValue> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the enabled attribute of the <gcAllowVeryLargeObjects> configuration element to true in the run-time environment.
The foreach statement of the C# language (for each in C++, For Each in Visual Basic) returns an object of the type of the elements in the collection. Since the elements of the SortedList<TKey,TValue> are key/value pairs, the element type is not the type of the key or the type of the value. Instead, the element type is KeyValuePair<TKey,TValue>. For example:
C#Copy
foreach( KeyValuePair<int, string> kvp in mySortedList )
{
    Console.WriteLine("Key = {0}, Value = {1}", kvp.Key, kvp.Value);
}
The foreach statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.
Constructors
Expand table
SortedList<TKey,TValue>()
Initializes a new instance of the SortedList<TKey,TValue> class that is empty, has the default initial capacity, and uses the default IComparer<T>.

SortedList<TKey,TValue>(IComparer<TKey>)
Initializes a new instance of the SortedList<TKey,TValue> class that is empty, has the default initial capacity, and uses the specified IComparer<T>.

SortedList<TKey,TValue>(IDictionary<TKey,TValue>)
Initializes a new instance of the SortedList<TKey,TValue> class that contains elements copied from the specified IDictionary<TKey,TValue>, has sufficient capacity to accommodate the number of elements copied, and uses the default IComparer<T>.

SortedList<TKey,TValue>(IDictionary<TKey,TValue>, IComparer<TKey>)
Initializes a new instance of the SortedList<TKey,TValue> class that contains elements copied from the specified IDictionary<TKey,TValue>, has sufficient capacity to accommodate the number of elements copied, and uses the specified IComparer<T>.

SortedList<TKey,TValue>(Int32)
Initializes a new instance of the SortedList<TKey,TValue> class that is empty, has the specified initial capacity, and uses the default IComparer<T>.

SortedList<TKey,TValue>(Int32, IComparer<TKey>)
Initializes a new instance of the SortedList<TKey,TValue> class that is empty, has the specified initial capacity, and uses the specified IComparer<T>.

Properties
Expand table
Capacity
Gets or sets the number of elements that the SortedList<TKey,TValue> can contain.

Comparer
Gets the IComparer<T> for the sorted list.

Count
Gets the number of key/value pairs contained in the SortedList<TKey,TValue>.

Item[TKey]
Gets or sets the value associated with the specified key.
Keys
Gets a collection containing the keys in the SortedList<TKey,TValue>, in sorted order.

Values
Gets a collection containing the values in the SortedList<TKey,TValue>.

Methods
Expand table
Add(TKey, TValue)
Adds an element with the specified key and value into the SortedList<TKey,TValue>.

Clear()
Removes all elements from the SortedList<TKey,TValue>.

ContainsKey(TKey)
Determines whether the SortedList<TKey,TValue> contains a specific key.

ContainsValue(TValue)
Determines whether the SortedList<TKey,TValue> contains a specific value.

Equals(Object)
Determines whether the specified object is equal to the current object.
(Inherited from Object)

GetEnumerator()
Returns an enumerator that iterates through the SortedList<TKey,TValue>.

GetHashCode()
Serves as the default hash function.
(Inherited from Object)

GetType()
Gets the Type of the current instance.
(Inherited from Object)

IndexOfKey(TKey)
Searches for the specified key and returns the zero-based index within the entire SortedList<TKey,TValue>.

IndexOfValue(TValue)
Searches for the specified value and returns the zero-based index of the first occurrence within the entire SortedList<TKey,TValue>.

MemberwiseClone()
Creates a shallow copy of the current Object.
(Inherited from Object)

Remove(TKey)
Removes the element with the specified key from the SortedList<TKey,TValue>.

RemoveAt(Int32)
Removes the element at the specified index of the SortedList<TKey,TValue>.

ToString()
Returns a string that represents the current object.
(Inherited from Object)

TrimExcess()
Sets the capacity to the actual number of elements in the SortedList<TKey,TValue>, if that number is less than 90 percent of current capacity.
TryGetValue(TKey, TValue)
Gets the value associated with the specified key.
Explicit Interface Implementations
Expand table
ICollection.CopyTo(Array, Int32)
Copies the elements of the ICollection to an Array, starting at a particular Array index.

ICollection.IsSynchronized
Gets a value indicating whether access to the ICollection is synchronized (thread safe).
ICollection.SyncRoot
Gets an object that can be used to synchronize access to the ICollection.

ICollection<KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey,TValue>)
Adds a key/value pair to the ICollection<T>.

ICollection<KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey,TValue>)
Determines whether the ICollection<T> contains a specific element.
ICollection<KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey,TValue>[], Int32)
Copies the elements of the ICollection<T> to an Array, starting at a particular Array index.

ICollection<KeyValuePair<TKey,TValue>>.IsReadOnly
Gets a value indicating whether the ICollection<T> is read-only.
ICollection<KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey,TValue>)
Removes the first occurrence of a specific key/value pair from the ICollection<T>.

IDictionary.Add(Object, Object)
Adds an element with the provided key and value to the IDictionary.

IDictionary.Contains(Object)
Determines whether the IDictionary contains an element with the specified key.
IDictionary.GetEnumerator()
Returns an IDictionaryEnumerator for the IDictionary.

IDictionary.IsFixedSize
Gets a value indicating whether the IDictionary has a fixed size.

IDictionary.IsReadOnly
Gets a value indicating whether the IDictionary is read-only.

IDictionary.Item[Object]
Gets or sets the element with the specified key.
IDictionary.Keys
Gets an ICollection containing the keys of the IDictionary.

IDictionary.Remove(Object)
Removes the element with the specified key from the IDictionary.

IDictionary.Values
Gets an ICollection containing the values in the IDictionary.

IDictionary<TKey,TValue>.Keys
Gets an ICollection<T> containing the keys of the IDictionary<TKey,TValue>.

IDictionary<TKey,TValue>.Values
Gets an ICollection<T> containing the values in the IDictionary<TKey,TValue>.

IEnumerable.GetEnumerator()
Returns an enumerator that iterates through a collection.
IEnumerable<KeyValuePair<TKey,TValue>>.GetEnumerator()
Returns an enumerator that iterates through a collection.
IReadOnlyDictionary<TKey,TValue>.Keys
Gets an enumerable collection that contains the keys in the read-only dictionary.
IReadOnlyDictionary<TKey,TValue>.Values
Gets an enumerable collection that contains the values in the read-only dictionary.
Extension Methods
Expand table
CopyToDataTable<T>(IEnumerable<T>)
Returns a DataTable that contains copies of the DataRow objects, given an input IEnumerable<T> object where the generic parameter T is DataRow.

CopyToDataTable<T>(IEnumerable<T>, DataTable, LoadOption)
Copies DataRow objects to the specified DataTable, given an input IEnumerable<T> object where the generic parameter T is DataRow.

CopyToDataTable<T>(IEnumerable<T>, DataTable, LoadOption, FillErrorEventHandler)
Copies DataRow objects to the specified DataTable, given an input IEnumerable<T> object where the generic parameter T is DataRow.

Aggregate<TSource>(IEnumerable<TSource>, Func<TSource,TSource,TSource>)
Applies an accumulator function over a sequence.
Aggregate<TSource,TAccumulate>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate,TSource,TAccumulate>)
Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.
Aggregate<TSource,TAccumulate,TResult>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate,TSource,TAccumulate>, Func<TAccumulate,TResult>)
Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.
All<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Determines whether all elements of a sequence satisfy a condition.
Any<TSource>(IEnumerable<TSource>)
Determines whether a sequence contains any elements.
Any<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Determines whether any element of a sequence satisfies a condition.
Append<TSource>(IEnumerable<TSource>, TSource)
Appends a value to the end of the sequence.
AsEnumerable<TSource>(IEnumerable<TSource>)
Returns the input typed as IEnumerable<T>.

Average<TSource>(IEnumerable<TSource>, Func<TSource,Decimal>)
Computes the average of a sequence of Decimal values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Double>)
Computes the average of a sequence of Double values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Int32>)
Computes the average of a sequence of Int32 values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Int64>)
Computes the average of a sequence of Int64 values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Decimal>>)
Computes the average of a sequence of nullable Decimal values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Double>>)
Computes the average of a sequence of nullable Double values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int32>>)
Computes the average of a sequence of nullable Int32 values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int64>>)
Computes the average of a sequence of nullable Int64 values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Single>>)
Computes the average of a sequence of nullable Single values that are obtained by invoking a transform function on each element of the input sequence.
Average<TSource>(IEnumerable<TSource>, Func<TSource,Single>)
Computes the average of a sequence of Single values that are obtained by invoking a transform function on each element of the input sequence.
Cast<TResult>(IEnumerable)
Casts the elements of an IEnumerable to the specified type.
Concat<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)
Concatenates two sequences.
Contains<TSource>(IEnumerable<TSource>, TSource)
Determines whether a sequence contains a specified element by using the default equality comparer.
Contains<TSource>(IEnumerable<TSource>, TSource, IEqualityComparer<TSource>)
Determines whether a sequence contains a specified element by using a specified IEqualityComparer<T>.

Count<TSource>(IEnumerable<TSource>)
Returns the number of elements in a sequence.
Count<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns a number that represents how many elements in the specified sequence satisfy a condition.
DefaultIfEmpty<TSource>(IEnumerable<TSource>)
Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.
DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource)
Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.
Distinct<TSource>(IEnumerable<TSource>)
Returns distinct elements from a sequence by using the default equality comparer to compare values.
Distinct<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>)
Returns distinct elements from a sequence by using a specified IEqualityComparer<T> to compare values.
ElementAt<TSource>(IEnumerable<TSource>, Int32)
Returns the element at a specified index in a sequence.
ElementAtOrDefault<TSource>(IEnumerable<TSource>, Int32)
Returns the element at a specified index in a sequence or a default value if the index is out of range.
Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)
Produces the set difference of two sequences by using the default equality comparer to compare values.
Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)
Produces the set difference of two sequences by using the specified IEqualityComparer<T> to compare values.
First<TSource>(IEnumerable<TSource>)
Returns the first element of a sequence.
First<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the first element in a sequence that satisfies a specified condition.
FirstOrDefault<TSource>(IEnumerable<TSource>)
Returns the first element of a sequence, or a default value if the sequence contains no elements.
FirstOrDefault<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
GroupBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
Groups the elements of a sequence according to a specified key selector function.
GroupBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>, IEqualityComparer<TKey>)
Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.
GroupBy<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>)
Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.
GroupBy<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>, IEqualityComparer<TKey>)
Groups the elements of a sequence according to a key selector function. The keys are compared by using a comparer and each group's elements are projected by using a specified function.
GroupBy<TSource,TKey,TResult>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TKey,IEnumerable<TSource>,TResult>)
Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.
GroupBy<TSource,TKey,TResult>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TKey,IEnumerable<TSource>,TResult>, IEqualityComparer<TKey>)
Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The keys are compared by using a specified comparer.
GroupBy<TSource,TKey,TElement,TResult>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>, Func<TKey,IEnumerable<TElement>,TResult>)
Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.
GroupBy<TSource,TKey,TElement,TResult>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource,TElement>, Func<TKey,IEnumerable<TElement>, TResult>, IEqualityComparer<TKey>)
Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Key values are compared by using a specified comparer, and the elements of each group are projected by using a specified function.
GroupJoin<TOuter,TInner,TKey,TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,IEnumerable<TInner>, TResult>)
Correlates the elements of two sequences based on equality of keys and groups the results. The default equality comparer is used to compare keys.
GroupJoin<TOuter,TInner,TKey,TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,IEnumerable<TInner>, TResult>, IEqualityComparer<TKey>)
Correlates the elements of two sequences based on key equality and groups the results. A specified IEqualityComparer<T> is used to compare keys.
Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)
Produces the set intersection of two sequences by using the default equality comparer to compare values.
Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)
Produces the set intersection of two sequences by using the specified IEqualityComparer<T> to compare values.
Join<TOuter,TInner,TKey,TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,TInner,TResult>)
Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
Join<TOuter,TInner,TKey,TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,TInner,TResult>, IEqualityComparer<TKey>)
Correlates the elements of two sequences based on matching keys. A specified IEqualityComparer<T> is used to compare keys.
Last<TSource>(IEnumerable<TSource>)
Returns the last element of a sequence.
Last<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the last element of a sequence that satisfies a specified condition.
LastOrDefault<TSource>(IEnumerable<TSource>)
Returns the last element of a sequence, or a default value if the sequence contains no elements.
LastOrDefault<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the last element of a sequence that satisfies a condition or a default value if no such element is found.
LongCount<TSource>(IEnumerable<TSource>)
Returns an Int64 that represents the total number of elements in a sequence.
LongCount<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns an Int64 that represents how many elements in a sequence satisfy a condition.
Max<TSource>(IEnumerable<TSource>)
Returns the maximum value in a generic sequence.
Max<TSource>(IEnumerable<TSource>, Func<TSource,Decimal>)
Invokes a transform function on each element of a sequence and returns the maximum Decimal value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Double>)
Invokes a transform function on each element of a sequence and returns the maximum Double value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Int32>)
Invokes a transform function on each element of a sequence and returns the maximum Int32 value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Int64>)
Invokes a transform function on each element of a sequence and returns the maximum Int64 value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Decimal>>)
Invokes a transform function on each element of a sequence and returns the maximum nullable Decimal value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Double>>)
Invokes a transform function on each element of a sequence and returns the maximum nullable Double value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int32>>)
Invokes a transform function on each element of a sequence and returns the maximum nullable Int32 value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int64>>)
Invokes a transform function on each element of a sequence and returns the maximum nullable Int64 value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Single>>)
Invokes a transform function on each element of a sequence and returns the maximum nullable Single value.

Max<TSource>(IEnumerable<TSource>, Func<TSource,Single>)
Invokes a transform function on each element of a sequence and returns the maximum Single value.

Max<TSource,TResult>(IEnumerable<TSource>, Func<TSource,TResult>)
Invokes a transform function on each element of a generic sequence and returns the maximum resulting value.
Min<TSource>(IEnumerable<TSource>)
Returns the minimum value in a generic sequence.
Min<TSource>(IEnumerable<TSource>, Func<TSource,Decimal>)
Invokes a transform function on each element of a sequence and returns the minimum Decimal value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Double>)
Invokes a transform function on each element of a sequence and returns the minimum Double value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Int32>)
Invokes a transform function on each element of a sequence and returns the minimum Int32 value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Int64>)
Invokes a transform function on each element of a sequence and returns the minimum Int64 value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Decimal>>)
Invokes a transform function on each element of a sequence and returns the minimum nullable Decimal value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Double>>)
Invokes a transform function on each element of a sequence and returns the minimum nullable Double value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int32>>)
Invokes a transform function on each element of a sequence and returns the minimum nullable Int32 value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int64>>)
Invokes a transform function on each element of a sequence and returns the minimum nullable Int64 value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Single>>)
Invokes a transform function on each element of a sequence and returns the minimum nullable Single value.

Min<TSource>(IEnumerable<TSource>, Func<TSource,Single>)
Invokes a transform function on each element of a sequence and returns the minimum Single value.

Min<TSource,TResult>(IEnumerable<TSource>, Func<TSource,TResult>)
Invokes a transform function on each element of a generic sequence and returns the minimum resulting value.
OfType<TResult>(IEnumerable)
Filters the elements of an IEnumerable based on a specified type.
OrderBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
Sorts the elements of a sequence in ascending order according to a key.
OrderBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>, IComparer<TKey>)
Sorts the elements of a sequence in ascending order by using a specified comparer.
OrderByDescending<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
Sorts the elements of a sequence in descending order according to a key.
OrderByDescending<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>, IComparer<TKey>)
Sorts the elements of a sequence in descending order by using a specified comparer.
Prepend<TSource>(IEnumerable<TSource>, TSource)
Adds a value to the beginning of the sequence.
Reverse<TSource>(IEnumerable<TSource>)
Inverts the order of the elements in a sequence.
Select<TSource,TResult>(IEnumerable<TSource>, Func<TSource,TResult>)
Projects each element of a sequence into a new form.
Select<TSource,TResult>(IEnumerable<TSource>, Func<TSource,Int32,TResult>)
Projects each element of a sequence into a new form by incorporating the element's index.
SelectMany<TSource,TResult>(IEnumerable<TSource>, Func<TSource,IEnumerable<TResult>>)
Projects each element of a sequence to an IEnumerable<T> and flattens the resulting sequences into one sequence.
SelectMany<TSource,TResult>(IEnumerable<TSource>, Func<TSource,Int32,IEnumerable<TResult>>)
Projects each element of a sequence to an IEnumerable<T>, and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.
SelectMany<TSource,TCollection,TResult>(IEnumerable<TSource>, Func<TSource,IEnumerable<TCollection>>, Func<TSource,TCollection,TResult>)
Projects each element of a sequence to an IEnumerable<T>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.
SelectMany<TSource,TCollection,TResult>(IEnumerable<TSource>, Func<TSource,Int32,IEnumerable<TCollection>>, Func<TSource,TCollection,TResult>)
Projects each element of a sequence to an IEnumerable<T>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein. The index of each source element is used in the intermediate projected form of that element.
SequenceEqual<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)
Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.
SequenceEqual<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)
Determines whether two sequences are equal by comparing their elements by using a specified IEqualityComparer<T>.

Single<TSource>(IEnumerable<TSource>)
Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.
Single<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.
SingleOrDefault<TSource>(IEnumerable<TSource>)
Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.
SingleOrDefault<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.
Skip<TSource>(IEnumerable<TSource>, Int32)
Bypasses a specified number of elements in a sequence and then returns the remaining elements.
SkipWhile<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
SkipWhile<TSource>(IEnumerable<TSource>, Func<TSource,Int32,Boolean>)
Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Decimal>)
Computes the sum of the sequence of Decimal values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Double>)
Computes the sum of the sequence of Double values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Int32>)
Computes the sum of the sequence of Int32 values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Int64>)
Computes the sum of the sequence of Int64 values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Decimal>>)
Computes the sum of the sequence of nullable Decimal values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Double>>)
Computes the sum of the sequence of nullable Double values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int32>>)
Computes the sum of the sequence of nullable Int32 values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Int64>>)
Computes the sum of the sequence of nullable Int64 values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Nullable<Single>>)
Computes the sum of the sequence of nullable Single values that are obtained by invoking a transform function on each element of the input sequence.
Sum<TSource>(IEnumerable<TSource>, Func<TSource,Single>)
Computes the sum of the sequence of Single values that are obtained by invoking a transform function on each element of the input sequence.
Take<TSource>(IEnumerable<TSource>, Int32)
Returns a specified number of contiguous elements from the start of a sequence.
TakeWhile<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Returns elements from a sequence as long as a specified condition is true.
TakeWhile<TSource>(IEnumerable<TSource>, Func<TSource,Int32,Boolean>)
Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.
ToArray<TSource>(IEnumerable<TSource>)
Creates an array from a IEnumerable<T>.

ToDictionary<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
Creates a Dictionary<TKey,TValue> from an IEnumerable<T> according to a specified key selector function.
ToDictionary<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>, IEqualityComparer<TKey>)
Creates a Dictionary<TKey,TValue> from an IEnumerable<T> according to a specified key selector function and key comparer.
ToDictionary<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>)
Creates a Dictionary<TKey,TValue> from an IEnumerable<T> according to specified key selector and element selector functions.
ToDictionary<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>, IEqualityComparer<TKey>)
Creates a Dictionary<TKey,TValue> from an IEnumerable<T> according to a specified key selector function, a comparer, and an element selector function.
ToHashSet<TSource>(IEnumerable<TSource>)
Creates a HashSet<T> from an IEnumerable<T>.

ToHashSet<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>)
Creates a HashSet<T> from an IEnumerable<T> using the comparer to compare keys.
ToList<TSource>(IEnumerable<TSource>)
Creates a List<T> from an IEnumerable<T>.

ToLookup<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
Creates a Lookup<TKey,TElement> from an IEnumerable<T> according to a specified key selector function.
ToLookup<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>, IEqualityComparer<TKey>)
Creates a Lookup<TKey,TElement> from an IEnumerable<T> according to a specified key selector function and key comparer.
ToLookup<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>)
Creates a Lookup<TKey,TElement> from an IEnumerable<T> according to specified key selector and element selector functions.
ToLookup<TSource,TKey,TElement>(IEnumerable<TSource>, Func<TSource,TKey>, Func<TSource,TElement>, IEqualityComparer<TKey>)
Creates a Lookup<TKey,TElement> from an IEnumerable<T> according to a specified key selector function, a comparer and an element selector function.
Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)
Produces the set union of two sequences by using the default equality comparer.
Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)
Produces the set union of two sequences by using a specified IEqualityComparer<T>.

Where<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
Filters a sequence of values based on a predicate.
Where<TSource>(IEnumerable<TSource>, Func<TSource,Int32,Boolean>)
Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.
Zip<TFirst,TSecond,TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst,TSecond,TResult>)
Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results.
AsParallel(IEnumerable)
Enables parallelization of a query.
AsParallel<TSource>(IEnumerable<TSource>)
Enables parallelization of a query.
AsQueryable(IEnumerable)
Converts an IEnumerable to an IQueryable.

AsQueryable<TElement>(IEnumerable<TElement>)
Converts a generic IEnumerable<T> to a generic IQueryable<T>.

Ancestors<T>(IEnumerable<T>)
Returns a collection of elements that contains the ancestors of every node in the source collection.
Ancestors<T>(IEnumerable<T>, XName)
Returns a filtered collection of elements that contains the ancestors of every node in the source collection. Only elements that have a matching XName are included in the collection.
DescendantNodes<T>(IEnumerable<T>)
Returns a collection of the descendant nodes of every document and element in the source collection.
Descendants<T>(IEnumerable<T>)
Returns a collection of elements that contains the descendant elements of every element and document in the source collection.
Descendants<T>(IEnumerable<T>, XName)
Returns a filtered collection of elements that contains the descendant elements of every element and document in the source collection. Only elements that have a matching XName are included in the collection.
Elements<T>(IEnumerable<T>)
Returns a collection of the child elements of every element and document in the source collection.
Elements<T>(IEnumerable<T>, XName)
Returns a filtered collection of the child elements of every element and document in the source collection. Only elements that have a matching XName are included in the collection.
InDocumentOrder<T>(IEnumerable<T>)
Returns a collection of nodes that contains all nodes in the source collection, sorted in document order.
Nodes<T>(IEnumerable<T>)
Returns a collection of the child nodes of every document and element in the source collection.
Remove<T>(IEnumerable<T>)
Removes every node in the source collection from its parent node.
Applies to
Product	Versions
.NET	Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7, 8, 9
.NET Framework	2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1
.NET Standard	1.3, 1.4, 1.6, 2.0, 2.1
UWP	10.0
Thread Safety
Public static (Shared in Visual Basic) members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
A SortedList<TKey,TValue> can support multiple readers concurrently, as long as the collection is not modified. Even so, enumerating through a collection is intrinsically not a thread-safe procedure. To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration. To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.
C# - Dictionary<TKey, TValue>
The Dictionary<TKey, TValue> is a generic collection that stores key-value pairs in no particular order.
Dictionary Characteristics
•	Dictionary<TKey, TValue> stores key-value pairs.
•	Comes under System.Collections.Generic namespace.
•	Implements IDictionary<TKey, TValue> interface.
•	Keys must be unique and cannot be null.
•	Values can be null or duplicate.
•	Values can be accessed by passing associated key in the indexer e.g. myDictionary[key]
•	Elements are stored as KeyValuePair<TKey, TValue> objects.
Creating a Dictionary
You can create the Dictionary<TKey, TValue> object by passing the type of keys and values it can store. The following example shows how to create a dictionary and add key-value pairs.
Example: Create Dictionary and Add Elements
IDictionary<int, string> numberNames = new Dictionary<int, string>();
numberNames.Add(1,"One"); //adding a key/value using the Add() method
numberNames.Add(2,"Two");
numberNames.Add(3,"Three");

//The following throws run-time exception: key already added.
//numberNames.Add(3, "Three"); 

foreach(KeyValuePair<int, string> kvp in numberNames)
    Console.WriteLine("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
		
//creating a dictionary using collection-initializer syntax
var cities = new Dictionary<string, string>(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};
		
foreach(var kvp in cities)
    Console.WriteLine("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
Try it
In the above example, numberNames is a Dictionary<int, string> type dictionary, so it can store int keys and string values. In the same way, cities is a Dictionary<string, string> type dictionary, so it can store string keys and string values. Dictionary cannot include duplicate or null keys, whereas values can be duplicated or null. Keys must be unique otherwise, it will throw a runtime exception.
2.5M
96
Entity Framework Core Quiz
Access Dictionary Elements
The Dictionary can be accessed using indexer. Specify a key to get the associated value. You can also use the ElementAt() method to get a KeyValuePair from the specified index.
Example: Access Dictionary Elements
var cities = new Dictionary<string, string>(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};

Console.WriteLine(cities["UK"]); //prints value of UK key
Console.WriteLine(cities["USA"]);//prints value of USA key
//Console.WriteLine(cities["France"]); // run-time exception: Key does not exist

//use ContainsKey() to check for an unknown key
if(cities.ContainsKey("France")){  
    Console.WriteLine(cities["France"]);
}

//use TryGetValue() to get a value of unknown key
string result;

if(cities.TryGetValue("France", out result))
{
    Console.WriteLine(result);
}

//use ElementAt() to retrieve key-value pair using index
for (int i = 0; i < cities.Count; i++)
{
    Console.WriteLine("Key: {0}, Value: {1}", 
                                            cities.ElementAt(i).Key, 
                                            cities.ElementAt(i).Value);
}
Try it
Update Dictionary
Update the value of a key by specifying a key in the indexer. It will throw the KeyNotFoundException if a key does not exist in the dictionary, therefore use the ContainsKey() method before accessing unknown keys.
Example: Update Dictionary Elements
var cities = new Dictionary<string, string>(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};

cities["UK"] = "Liverpool, Bristol"; // update value of UK key
cities["USA"] = "Los Angeles, Boston"; // update value of USA key
//cities["France"] = "Paris"; //throws run-time exception: KeyNotFoundException

if(cities.ContainsKey("France")){
    cities["France"] = "Paris";
}
Try it
Remove Elements in Dictionary
The Remove() method deletes an existing key-value pair from a dictionary. The Clear() method deletes all the elements of the dictionary.
Example: Remove Dictionary Elements
var cities = new Dictionary<string, string>(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};

cities.Remove("UK"); // removes UK 
//cities.Remove("France"); //throws run-time exception: KeyNotFoundException

if(cities.ContainsKey("France")){ // check key before removing it
    cities.Remove("France");
}

cities.Clear(); //removes all elements
Try it
Dictionary Class Hierarchy
The following diagram illustrates the generic Dictionary class hierarchy.
 
Learn about Dictionary methods and properties on docs.microsoft.com.
C# - Hashtable
The Hashtable is a non-generic collection that stores key-value pairs, similar to generic Dictionary<TKey, TValue> collection. It optimizes lookups by computing the hash code of each key and stores it in a different bucket internally and then matches the hash code of the specified key at the time of accessing values.
Hashtable Characteristics
•	Hashtable stores key-value pairs.
•	Comes under System.Collections namespace.
•	Implements IDictionary interface.
•	Keys must be unique and cannot be null.
•	Values can be null or duplicate.
•	Values can be accessed by passing associated key in the indexer e.g. myHashtable[key]
•	Elements are stored as DictionaryEntry objects.
Creating a Hashtable
The following example demonstrates creating a Hashtable and adding elements.
Example: Create and Add Elements
Hashtable numberNames = new Hashtable();
numberNames.Add(1,"One"); //adding a key/value using the Add() method
numberNames.Add(2,"Two");
numberNames.Add(3,"Three");

//The following throws run-time exception: key already added.
//numberNames.Add(3, "Three"); 

foreach(DictionaryEntry de in numberNames)
    Console.WriteLine("Key: {0}, Value: {1}", de.Key, de.Value);
		
//creating a Hashtable using collection-initializer syntax
var cities = new Hashtable(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};
		
foreach(DictionaryEntry de in cities)
    Console.WriteLine("Key: {0}, Value: {1}", de.Key, de.Value);
Try it
The Hashtable collection can include all the elements of Dictionary, as shown below.
Example: Add Dictionary in Hashtable
Dictionary<int, string> dict = new Dictionary<int, string>();
dict.Add(1, "one");
dict.Add(2, "two");
dict.Add(3, "three");

Hashtable ht = new Hashtable(dict);
Try it
2.5M
96
Entity Framework Core Quiz
Update Hashtable
You can retrieve the value of an existing key from the Hashtable by passing a key in indexer. The Hashtable is a non-generic collection, so you must type cast values while retrieving it.
Example: Update Hashtable
//creating a Hashtable using collection-initializer syntax
var cities = new Hashtable(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};
    
string citiesOfUK = (string) cities["UK"]; //cast to string
string citiesOfUSA = (string) cities["USA"]; //cast to string

Console.WriteLine(citiesOfUK);
Console.WriteLine(citiesOfUSA);

cities["UK"] = "Liverpool, Bristol"; // update value of UK key
cities["USA"] = "Los Angeles, Boston"; // update value of USA key

if(!cities.ContainsKey("France")){
    cities["France"] = "Paris";
}
Try it
Remove Elements in Hashtable
The Remove() method removes the key-value that match with the specified in the Hashtable. It throws the KeyNotfoundException if the specified key not found in the Hashtable, so check for an existing key using the ContainsKey() method before removing.
Use the Clear() method to remove all the elements in one shot.
Example: Remove Elements from Hashtable
var cities = new Hashtable(){
	{"UK", "London, Manchester, Birmingham"},
	{"USA", "Chicago, New York, Washington"},
	{"India", "Mumbai, New Delhi, Pune"}
};

cities.Remove("UK"); // removes UK 
//cities.Remove("France"); //throws run-time exception: KeyNotFoundException

if(cities.ContainsKey("France")){ // check key before removing it
    cities.Remove("France");
}

cities.Clear(); //removes all elements
Try it
Hashtable Class Hierarchy
The following diagram illustrates the Hashtable class hierarchy.
 C# Hashtable
 Further Reading
•	Difference between Hashtable and Dictionary
•	Hashtable Properties and Methods.
•	Difference between Hashtable and Dictionary
•	C#
•	 
•	By TutorialsTeacher
•	 
•	 05 Feb 2015
•	________________________________________
•	In C#, Hashtables and Dictionaries are two commonly used collection type for storing and retrieving key-value pairs.
•	The following example demonstrates creating a Hashtable and adding elements.
•	Example: Create and Add Elements
•	Hashtable numberNames = new Hashtable();
•	numberNames.Add(1,"One"); //adding a key/value using the Add() method
•	numberNames.Add(2,"Two");
•	numberNames.Add(3,"Three");
•	
•	//The following throws run-time exception: key already added.
•	//numberNames.Add(3, "Three"); 
•	
•	foreach(DictionaryEntry de in numberNames)
•	        Console.WriteLine("Key: {0}, Value: {1}", de.Key, de.Value);
•	Try it
•	A Dictionary can be created by passing the type of keys and values it can store.
•	Example: Create Dictionary and Add Elements
•	IDictionary<int, string> numberNames = new Dictionary<int, string>();
•	numberNames.Add(1,"One"); //adding a key/value using the Add() method
•	numberNames.Add(2,"Two");
•	numberNames.Add(3,"Three");
•	
•	//The following throws run-time exception: key already added.
•	//numberNames.Add(3, "Three"); 
•	
•	foreach(KeyValuePair<int, string> kvp in numberNames)
•	        Console.WriteLine("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
•	Try it
•	Hashtable vs Dictionary
•	The following table lists the differences between Hashtable and Dictionary in C#.
Hashtable	Dictionary
Hashtable is included in the System.Collections namespace.	Dictionary is included in the System.Collections.Generic namespace.
Hashtable is a loosely typed (non-generic) collection, this means it stores key-value pairs of any data types.	Dictionary is a generic collection. So it can store key-value pairs of specific data types.
Hashtable is thread safe.	Only public static members are thread safe in Dictionary.
Hashtable returns null if we try to find a key which does not exist.	Dictionary throws an exception if we try to find a key which does not exist.
Data retrieval is slower than the dictionary collection because of boxing-unboxing.	Data retrieval is faster than Hashtable because it is a type safe so no need of boxing-unboxing.
•	It is recommended to use the Dictionary than the Hashtable collection in C#.
•	Visit Hashtable or Dictionary in the C# tutorials section for more information.
Hashtable Class
•	Reference
Feedback
Definition
Namespace:
System.Collections
Assembly:
mscorlib.dll
Represents a collection of key/value pairs that are organized based on the hash code of the key.
C#Copy
[System.Serializable]
[System.Runtime.InteropServices.ComVisible(true)]
public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
Inheritance
Object
Hashtable
Derived
System.Configuration.SettingsAttributeDictionary
System.Configuration.SettingsContext
System.Data.PropertyCollection
System.Printing.IndexedProperties.PrintPropertyDictionary
Attributes
SerializableAttribute ComVisibleAttribute
Implements
ICollection  IDictionary  IEnumerable  ICloneable  IDeserializationCallback  ISerializable
Examples
The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.
C#Copy
using System;
using System.Collections;

class Example
{
    public static void Main()
    {
        // Create a new hash table.
        //
        Hashtable openWith = new Hashtable();

        // Add some elements to the hash table. There are no
        // duplicate keys, but some of the values are duplicates.
        openWith.Add("txt", "notepad.exe");
        openWith.Add("bmp", "paint.exe");
        openWith.Add("dib", "paint.exe");
        openWith.Add("rtf", "wordpad.exe");

        // The Add method throws an exception if the new key is
        // already in the hash table.
        try
        {
            openWith.Add("txt", "winword.exe");
        }
        catch
        {
            Console.WriteLine("An element with Key = \"txt\" already exists.");
        }

        // The Item property is the default property, so you
        // can omit its name when accessing elements.
        Console.WriteLine("For key = \"rtf\", value = {0}.", openWith["rtf"]);

        // The default Item property can be used to change the value
        // associated with a key.
        openWith["rtf"] = "winword.exe";
        Console.WriteLine("For key = \"rtf\", value = {0}.", openWith["rtf"]);

        // If a key does not exist, setting the default Item property
        // for that key adds a new key/value pair.
        openWith["doc"] = "winword.exe";

        // ContainsKey can be used to test keys before inserting
        // them.
        if (!openWith.ContainsKey("ht"))
        {
            openWith.Add("ht", "hypertrm.exe");
            Console.WriteLine("Value added for key = \"ht\": {0}", openWith["ht"]);
        }

        // When you use foreach to enumerate hash table elements,
        // the elements are retrieved as KeyValuePair objects.
        Console.WriteLine();
        foreach( DictionaryEntry de in openWith )
        {
            Console.WriteLine("Key = {0}, Value = {1}", de.Key, de.Value);
        }

        // To get the values alone, use the Values property.
        ICollection valueColl = openWith.Values;

        // The elements of the ValueCollection are strongly typed
        // with the type that was specified for hash table values.
        Console.WriteLine();
        foreach( string s in valueColl )
        {
            Console.WriteLine("Value = {0}", s);
        }

        // To get the keys alone, use the Keys property.
        ICollection keyColl = openWith.Keys;

        // The elements of the KeyCollection are strongly typed
        // with the type that was specified for hash table keys.
        Console.WriteLine();
        foreach( string s in keyColl )
        {
            Console.WriteLine("Key = {0}", s);
        }

        // Use the Remove method to remove a key/value pair.
        Console.WriteLine("\nRemove(\"doc\")");
        openWith.Remove("doc");

        if (!openWith.ContainsKey("doc"))
        {
            Console.WriteLine("Key \"doc\" is not found.");
        }
    }
}

/* This code example produces the following output:

An element with Key = "txt" already exists.
For key = "rtf", value = wordpad.exe.
For key = "rtf", value = winword.exe.
Value added for key = "ht": hypertrm.exe

Key = dib, Value = paint.exe
Key = txt, Value = notepad.exe
Key = ht, Value = hypertrm.exe
Key = bmp, Value = paint.exe
Key = rtf, Value = winword.exe
Key = doc, Value = winword.exe

Value = paint.exe
Value = notepad.exe
Value = hypertrm.exe
Value = paint.exe
Value = winword.exe
Value = winword.exe

Key = dib
Key = txt
Key = ht
Key = bmp
Key = rtf
Key = doc

Remove("doc")
Key "doc" is not found.
 */
PowerShellCopy
# Create new hash table using PowerShell syntax
$OpenWith = @{}

# Add one element to the hash table using the Add method
$OpenWith.Add('txt', 'notepad.exe')

# Add three eleements using PowerShell syntax three different ways
$OpenWith.dib = 'paint.exe'

$KeyBMP = 'bmp'
$OpenWith[$KeyBMP] = 'paint.exe'

$OpenWith += @{'rtf' = 'wordpad.exe'}

# Display hash table
"There are {0} in the `$OpenWith hash table as follows:" -f $OpenWith.Count
''

# Display hashtable properties
'Count of items in the hashtable  : {0}' -f $OpenWith.Count
'Is hashtable fixed size?         : {0}' -f $OpenWith.IsFixedSize
'Is hashtable read-only?          : {0}' -f $OpenWith.IsReadonly
'Is hashtabale synchronised?      : {0}' -f $OpenWith.IsSynchronized
''
'Keys in hashtable:'
$OpenWith.Keys
''
'Values in hashtable:'
$OpenWith.Values
''

<#
This script produces the following output:

There are 4 in the $OpenWith hash table as follows:

Name                           Value                                                                            
----                           -----                                                                            
txt                            notepad.exe                                                                      
dib                            paint.exe                                                                        
bmp                            paint.exe                                                                        
rtf                            wordpad.exe                                                                      

Count of items in the hashtable  : 4
Is hashtable fixed size?         : False
Is hashtable read-only?          : False
Is hashtabale synchronised?      : False

Keys in hashtable:
txt
dib
bmp
rtf

Values in hashtable:
notepad.exe
paint.exe
paint.exe
wordpad.exe
#>
Remarks
Each element is a key/value pair stored in a DictionaryEntry object. A key cannot be null, but a value can be.
 Important
We don't recommend that you use the Hashtable class for new development. Instead, we recommend that you use the generic Dictionary<TKey,TValue> class. For more information, see Non-generic collections shouldn't be used on GitHub.
The objects used as keys by a Hashtable are required to override the Object.GetHashCode method (or the IHashCodeProvider interface) and the Object.Equals method (or the IComparer interface). The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the Hashtable might behave incorrectly. For example, when creating a Hashtable, you must use the CaseInsensitiveHashCodeProvider class (or any case-insensitive IHashCodeProvider implementation) with the CaseInsensitiveComparer class (or any case-insensitive IComparer implementation).
Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the Hashtable. An alternative is to use a Hashtable constructor with an IEqualityComparer parameter. If key equality were simply reference equality, the inherited implementation of Object.GetHashCode and Object.Equals would suffice.
Key objects must be immutable as long as they are used as keys in the Hashtable.
When an element is added to the Hashtable, the element is placed into a bucket based on the hash code of the key. Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.
The load factor of a Hashtable determines the maximum ratio of elements to buckets. Smaller load factors cause faster average lookup times at the cost of increased memory consumption. The default load factor of 1.0 generally provides the best balance between speed and size. A different load factor can also be specified when the Hashtable is created.
As elements are added to a Hashtable, the actual load factor of the Hashtable increases. When the actual load factor reaches the specified load factor, the number of buckets in the Hashtable is automatically increased to the smallest prime number that is larger than twice the current number of Hashtable buckets.
Each key object in the Hashtable must provide its own hash function, which can be accessed by calling GetHash. However, any object implementing IHashCodeProvider can be passed to a Hashtable constructor, and that hash function is used for all objects in the table.
The capacity of a Hashtable is the number of elements the Hashtable can hold. As elements are added to a Hashtable, the capacity is automatically increased as required through reallocation.
.NET Framework only: For very large Hashtable objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the enabled attribute of the <gcAllowVeryLargeObjects> configuration element to true in the run-time environment.
The foreach statement of the C# language (For Each in Visual Basic) returns an object of the type of the elements in the collection. Since each element of the Hashtable is a key/value pair, the element type is not the type of the key or the type of the value. Instead, the element type is DictionaryEntry. For example:
C#Copy
foreach(DictionaryEntry de in myHashtable)
{
    // ...
}
The foreach statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.
Because serializing and deserializing an enumerator for a Hashtable can cause the elements to become reordered, it is not possible to continue enumeration without calling the Reset method.
 Note
Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the Equals method.
Constructors
Expand table
Hashtable()
Initializes a new, empty instance of the Hashtable class using the default initial capacity, load factor, hash code provider, and comparer.
Hashtable(IDictionary)
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to the new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.
Hashtable(IDictionary, IEqualityComparer)
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to a new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified IEqualityComparer object.

Hashtable(IDictionary, IHashCodeProvider, IComparer)
Obsolete.
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to the new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer. This API is obsolete. For an alternative, see Hashtable(IDictionary, IEqualityComparer).

Hashtable(IDictionary, Single)
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to the new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.
Hashtable(IDictionary, Single, IEqualityComparer)
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to the new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the specified load factor and IEqualityComparer object.

Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)
Obsolete.
Initializes a new instance of the Hashtable class by copying the elements from the specified dictionary to the new Hashtable object. The new Hashtable object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.
Hashtable(IEqualityComparer)
Initializes a new, empty instance of the Hashtable class using the default initial capacity and load factor, and the specified IEqualityComparer object.

Hashtable(IHashCodeProvider, IComparer)
Obsolete.
Initializes a new, empty instance of the Hashtable class using the default initial capacity and load factor, and the specified hash code provider and comparer.
Hashtable(Int32)
Initializes a new, empty instance of the Hashtable class using the specified initial capacity, and the default load factor, hash code provider, and comparer.
Hashtable(Int32, IEqualityComparer)
Initializes a new, empty instance of the Hashtable class using the specified initial capacity and IEqualityComparer, and the default load factor.

Hashtable(Int32, IHashCodeProvider, IComparer)
Obsolete.
Initializes a new, empty instance of the Hashtable class using the specified initial capacity, hash code provider, comparer, and the default load factor.
Hashtable(Int32, Single)
Initializes a new, empty instance of the Hashtable class using the specified initial capacity and load factor, and the default hash code provider and comparer.
Hashtable(Int32, Single, IEqualityComparer)
Initializes a new, empty instance of the Hashtable class using the specified initial capacity, load factor, and IEqualityComparer object.

Hashtable(Int32, Single, IHashCodeProvider, IComparer)
Obsolete.
Initializes a new, empty instance of the Hashtable class using the specified initial capacity, load factor, hash code provider, and comparer.
Hashtable(SerializationInfo, StreamingContext)
Initializes a new, empty instance of the Hashtable class that is serializable using the specified SerializationInfo and StreamingContext objects.

Properties
Expand table
comparer
Obsolete.
Gets or sets the IComparer to use for the Hashtable.

Count
Gets the number of key/value pairs contained in the Hashtable.

EqualityComparer
Gets the IEqualityComparer to use for the Hashtable.

hcp
Obsolete.
Gets or sets the object that can dispense hash codes.
IsFixedSize
Gets a value indicating whether the Hashtable has a fixed size.

IsReadOnly
Gets a value indicating whether the Hashtable is read-only.

IsSynchronized
Gets a value indicating whether access to the Hashtable is synchronized (thread safe).

Item[Object]
Gets or sets the value associated with the specified key.
Keys
Gets an ICollection containing the keys in the Hashtable.

SyncRoot
Gets an object that can be used to synchronize access to the Hashtable.

Values
Gets an ICollection containing the values in the Hashtable.

Methods
Expand table
Add(Object, Object)
Adds an element with the specified key and value into the Hashtable.

Clear()
Removes all elements from the Hashtable.

Clone()
Creates a shallow copy of the Hashtable.

Contains(Object)
Determines whether the Hashtable contains a specific key.

ContainsKey(Object)
Determines whether the Hashtable contains a specific key.

ContainsValue(Object)
Determines whether the Hashtable contains a specific value.

CopyTo(Array, Int32)
Copies the Hashtable elements to a one-dimensional Array instance at the specified index.

Equals(Object)
Determines whether the specified object is equal to the current object.
(Inherited from Object)

GetEnumerator()
Returns an IDictionaryEnumerator that iterates through the Hashtable.

GetHash(Object)
Returns the hash code for the specified key.
GetHashCode()
Serves as the default hash function.
(Inherited from Object)

GetObjectData(SerializationInfo, StreamingContext)
Implements the ISerializable interface and returns the data needed to serialize the Hashtable.

GetType()
Gets the Type of the current instance.
(Inherited from Object)

KeyEquals(Object, Object)
Compares a specific Object with a specific key in the Hashtable.

MemberwiseClone()
Creates a shallow copy of the current Object.
(Inherited from Object)

OnDeserialization(Object)
Implements the ISerializable interface and raises the deserialization event when the deserialization is complete.
Remove(Object)
Removes the element with the specified key from the Hashtable.

Synchronized(Hashtable)
Returns a synchronized (thread-safe) wrapper for the Hashtable.

ToString()
Returns a string that represents the current object.
(Inherited from Object)

Explicit Interface Implementations
Expand table
IEnumerable.GetEnumerator()
Returns an enumerator that iterates through a collection.
Extension Methods
Expand table
Cast<TResult>(IEnumerable)
Casts the elements of an IEnumerable to the specified type.

OfType<TResult>(IEnumerable)
Filters the elements of an IEnumerable based on a specified type.

AsParallel(IEnumerable)
Enables parallelization of a query.
AsQueryable(IEnumerable)
Converts an IEnumerable to an IQueryable.

Applies to
Product	Versions
.NET	Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7, 8, 9
.NET Framework	1.1, 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1
.NET Standard	2.0, 2.1
UWP	10.0
Thread Safety
Hashtable is thread safe for use by multiple reader threads and a single writing thread. It is thread safe for multi-thread use when only one of the threads perform write (update) operations, which allows for lock-free reads provided that the writers are serialized to the Hashtable. To support multiple writers all operations on the Hashtable must be done through the wrapper returned by the Synchronized(Hashtable) method, provided that there are no threads reading the Hashtable object.
Enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.
C# - Stack<T>
Stack is a special type of collection that stores elements in LIFO style (Last In First Out). C# includes the generic Stack<T> and non-generic Stack collection classes. It is recommended to use the generic Stack<T> collection.
Stack is useful to store temporary data in LIFO style, and you might want to delete an element after retrieving its value.
Stack<T> Characteristics
•	Stack<T> is Last In First Out collection.
•	It comes under System.Collection.Generic namespace.
•	Stack<T> can contain elements of the specified type. It provides compile-time type checking and doesn't perform boxing-unboxing because it is generic.
•	Elements can be added using the Push() method. Cannot use collection-initializer syntax.
•	Elements can be retrieved using the Pop() and the Peek() methods. It does not support an indexer.
Creating a Stack
You can create an object of the Stack<T> by specifying a type parameter for the type of elements it can store. The following example creates and adds elements in the Stack<T> using the Push() method. Stack allows null (for reference types) and duplicate values.
Example: Create and Add Elements in Stack
Stack<int> myStack = new Stack<int>();
myStack.Push(1);
myStack.Push(2);
myStack.Push(3);
myStack.Push(4);

foreach (var item in myStack)
     Console.Write(item + ","); //prints 4,3,2,1, 
Try it
You can also create a Stack from an array, as shown below.
Example: Create and Add Elements in Stack
int[] arr = new int[]{ 1, 2, 3, 4};
Stack<int> myStack = new Stack<int>(arr);

foreach (var item in myStack)
     Console.Write(item + ","); //prints 4,3,2,1, 
Try it
Stack<T> Properties and Methods:
Property	Usage
Count	Returns the total count of elements in the Stack.
Method	Usage
Push(T)	Inserts an item at the top of the stack.
Peek()
Returns the top item from the stack.
Pop()
Removes and returns items from the top of the stack.
Contains(T)
Checks whether an item exists in the stack or not.
Clear()	Removes all items from the stack.
Pop()
The Pop() method returns the last element and removes it from a stack. If a stack is empty, then it will throw the InvalidOperationException. So, always check for the number of elements in a stack before calling the Pop() method.
Example: Access Stack using Pop()
Stack<int> myStack = new Stack<int>();
myStack.Push(1);
myStack.Push(2);
myStack.Push(3);
myStack.Push(4);

Console.Write("Number of elements in Stack: {0}", myStack.Count);

while (myStack.Count > 0)
     Console.Write(myStack.Pop() + ",");

Console.Write("Number of elements in Stack: {0}", myStack.Count);
Try it
Output:
Number of elements in Stack: 4
4,3,2,1,
Number of elements in Stack: 0
Peek()
The Peek() method returns the lastly added value from the stack but does not remove it. Calling the Peek() method on an empty stack will throw the InvalidOperationException. So, always check for elements in the stack before retrieving elements using the Peek() method.
Example: Retrieve Elements usign Peek()
Stack<int> myStack = new Stack<int>();
myStack.Push(1);
myStack.Push(2);
myStack.Push(3);
myStack.Push(4);

Console.Write("Number of elements in Stack: {0}", myStack.Count);// prints 4

if(myStack.Count > 0){
     Console.WriteLine(myStack.Peek()); // prints 4
     Console.WriteLine(myStack.Peek()); // prints 4
}

Console.Write("Number of elements in Stack: {0}", myStack.Count);// prints 4
Try it
Contains()
The Contains() method checks whether the specified element exists in a Stack collection or not. It returns true if it exists, otherwise false.
Example: Contains()
Stack<int> myStack = new Stack<int>();
myStack.Push(1);
myStack.Push(2);
myStack.Push(3);
myStack.Push(4);

myStack.Contains(2); // returns true
myStack.Contains(10); // returns false

C# - Queue<T>
Queue is a special type of collection that stores the elements in FIFO style (First In First Out), exactly opposite of the Stack<T> collection. It contains the elements in the order they were added. C# includes generic Queue<T> and non-generic Queue collection. It is recommended to use the generic Queue<T> collection.
Queue<T> Characteristics
•	Queue<T> is FIFO (First In First Out) collection.
•	It comes under System.Collection.Generic namespace.
•	Queue<T> can contain elements of the specified type. It provides compile-time type checking and doesn't perform boxing-unboxing because it is generic.
•	Elements can be added using the Enqueue() method. Cannot use collection-initializer syntax.
•	Elements can be retrieved using the Dequeue() and the Peek() methods. It does not support an indexer.
The following figure illustrates the Queue collection:
 
Creating a Queue
You can create an object of the Queue<T> by specifying a type parameter for the type of elements it can store. The following example creates and adds elements in the Queue<T> using the Enqueue() method. A Queue collection allows null (for reference types) and duplicate values.
Example: Create and Add Elements in the Queue
Queue<int> callerIds = new Queue<int>();
callerIds.Enqueue(1);
callerIds.Enqueue(2);
callerIds.Enqueue(3);
callerIds.Enqueue(4);

foreach(var id in callerIds)
    Console.Write(id); //prints 1234
Try it
Queue<T> Properties and Methods
Property	Usage
Count	Returns the total count of elements in the Queue.
Method	Usage
Enqueue(T)	Adds an item into the queue.
Dequeue	Returns an item from the beginning of the queue and removes it from the queue.
Peek()	Returns an first item from the queue without removing it.
Contains(T)	Checks whether an item is in the queue or not
Clear()	Removes all the items from the queue.
2.5M
96
Entity Framework Core Quiz
Retrieve Elements from a Queue
The Dequeue() and the Peek() method is used to retrieve the first element in a queue collection. The Dequeue() removes and returns the first element from a queue because the queue stores elements in FIFO order. Calling the Dequeue() method on an empty queue will throw the InvalidOperation exception. So, always check that the total count of a queue is greater than zero before calling it.
Example: Reading Queue
Queue<string> strQ = new Queue<string>();
strQ.Enqueue("H");
strQ.Enqueue("e");
strQ.Enqueue("l");
strQ.Enqueue("l");
strQ.Enqueue("o");

Console.WriteLine("Total elements: {0}", strQ.Count); //prints 5

while (strQ.Count > 0)
    Console.WriteLine(strQ.Dequeue()); //prints Hello

Console.WriteLine("Total elements: {0}", strQ.Count); //prints 0
Try it
The Peek() method always returns the first item from a queue collection without removing it from the queue. Calling the Peek() method on an empty queue will throw a run-time exception InvalidOperationException.
Example: Peek()
Queue<string> strQ = new Queue<string>();
strQ.Enqueue("H");
strQ.Enqueue("e");
strQ.Enqueue("l");
strQ.Enqueue("l");
strQ.Enqueue("o");

Console.WriteLine("Total elements: {0}", strQ.Count); //prints 5

if(strQ.Count > 0){
    Console.WriteLine(strQ.Peek()); //prints H
    Console.WriteLine(strQ.Peek()); //prints H
}

Console.WriteLine("Total elements: {0}", strQ.Count); //prints 5
Try it
Contains()
The Contains() method checks whether an item exists in a queue or not. It returns true if the specified item exists, otherwise returns false.
Contains() Signature: bool Contains(object obj);
Example: Contains()
Queue<int> callerIds = new Queue<int>();
callerIds.Enqueue(1);
callerIds.Enqueue(2);
callerIds.Enqueue(3);
callerIds.Enqueue(4);

callerIds.Contains(2); //true
callerIds.Contains(10); //false

C# - Tuple
The Tuple<T> class was introduced in .NET Framework 4.0. A tuple is a data structure that contains a sequence of elements of different data types. It can be used where you want to have a data structure to hold an object with properties, but you don't want to create a separate type for it.
Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>
The following example creates a tuple with three elements:
Tuple<int, string, string> person = 
            new Tuple <int, string, string>(1, "Steve", "Jobs");
In the above example, we created an instance of the Tuple that holds a person's record. We specified a type for each element and passed values to the constructor. Specifying the type of each element is cumbersome. C# includes a static helper class Tuple, which returns an instance of the Tuple<T> without specifying each element's type, as shown below.
var person = Tuple.Create(1, "Steve", "Jobs");
A tuple can only include a maximum of eight elements. It gives a compiler error when you try to include more than eight elements.
var numbers = Tuple.Create(1, 2, 3, 4, 5, 6, 7, 8);
Accessing Tuple Elements
A tuple elements can be accessed with Item<elementNumber> properties, e.g., Item1, Item2, Item3, and so on up to Item7 property. The Item1 property returns the first element, Item2 returns the second element, and so on. The last element (the 8th element) will be returned using the Rest property.
Example: Accessing Tuple Elements
var person = Tuple.Create(1, "Steve", "Jobs");
person.Item1; // returns 1
person.Item2; // returns "Steve"
person.Item3; // returns "Jobs"


var numbers = Tuple.Create("One", 2, 3, "Four", 5, "Six", 7, 8);
numbers.Item1; // returns "One"
numbers.Item2; // returns 2
numbers.Item3; // returns 3
numbers.Item4; // returns "Four"
numbers.Item5; // returns 5
numbers.Item6; // returns "Six"
numbers.Item7; // returns 7
numbers.Rest; // returns (8)
numbers.Rest.Item1; // returns 8
Try it
Generally, the 8th position is for the nested tuple, which you can access using the Rest property.
Nested Tuples
If you want to include more than eight elements in a tuple, you can do that by nesting another tuple object as the eighth element. The last nested tuple can be accessed using the Rest property. To access the nested tuple's element, use the Rest.Item1.Item<elelementNumber> property.
Example: Nested Tuple
var numbers = Tuple.Create(1, 2, 3, 4, 5, 6, 7, Tuple.Create(8, 9, 10, 11, 12, 13));
numbers.Item1; // returns 1
numbers.Item7; // returns 7
numbers.Rest.Item1; //returns (8, 9, 10, 11, 12, 13)
numbers.Rest.Item1.Item1; //returns 8
numbers.Rest.Item1.Item2; //returns 9
Try it
You can include the nested tuple object anywhere in the sequence. However, it is recommended to place the nested tuple at the end of the sequence so that it can be accessed using the Rest property.
Example: Nested Tuple
var numbers = Tuple.Create(1, 2, Tuple.Create(3, 4, 5, 6, 7,  8), 9, 10, 11, 12, 13 );
numbers.Item1; // returns 1
numbers.Item2; // returns 2
numbers.Item3; // returns (3, 4, 5, 6, 7,  8)
numbers.Item3.Item1; // returns 3
numbers.Item4; // returns 9
numbers.Rest.Item1; //returns 13
Try it
Tuple as a Method Parameter
A method can have a tuple as a parameter.
static void Main(string[] args)
{
            var person = Tuple.Create(1, "Steve", "Jobs");
    DisplayTuple(person);
}

static void DisplayTuple(Tuple<int,string,string> person)
{
    Console.WriteLine($"Id = { person.Item1}");
    Console.WriteLine($"First Name = { person.Item2}");
    Console.WriteLine($"Last Name = { person.Item3}");
}
Tuple as a Return Type
A Tuple can be return from a method.
static void Main(string[] args)
{
            var person = GetPerson();
}

static Tuple<int, string, string> GetPerson() 
{
            return Tuple.Create(1, "Bill", "Gates");
}
Usage of Tuple
Tuples can be used in the following scenarios:
1.	When you want to return multiple values from a method without using ref or out parameters.
2.	When you want to pass multiple values to a method through a single parameter.
3.	When you want to hold a database record or some values temporarily without creating a separate class.
Tuple Limitations:
1.	The Tuple is a reference type and not a value type. It allocates on heap and could result in CPU intensive operations.
2.	The Tuple is limited to include eight elements. You need to use nested tuples if you need to store more elements. However, this may result in ambiguity.
3.	The Tuple elements can be accessed using properties with a name pattern Item<elementNumber>, which does not make sense.
C# 7 includes ValueTuple to overcome Tuple's limitations and makes it even easier to work with Tuple. Learn about it in the next chapter.
C# - ValueTuple
C# 7.0 (.NET Framework 4.7) introduced the ValueTuple structure, which is a value type representation of the Tuple.
The ValueTuple is only available in .NET Framework 4.7. If you don't see ValueTuple in your project, then you need to install the ValueTuple. (.NET Framework 4.7 or higher, or .NET Standard Library 2.0 or higher already includes ValueTuple.)
To install the ValueTuple package, right-click on the project in the solution explorer and select Manage NuGet Packages... This will open the NuGet Package Manager. Click the Browse tab, search for ValueTuple in the search box, and select the System.ValueTuple package, as shown below.
 
ValueTuple Initialization
It is easy to create and initialize the ValueTuple. It can be created and initialized using parentheses () and specifying the values in it.
var person = (1, "Bill", "Gates");
    
//equivalent Tuple
//var person = Tuple.Create(1, "Bill", "Gates");
The ValueTuple can also be initialized by specifying the type of each element, as shown below.
Example: ValueTuple
 Copy
ValueTuple<int, string, string> person = (1, "Bill", "Gates");
person.Item1;  // returns 1
person.Item2;   // returns "Bill"
person.Item3;   // returns "Gates"
Try it
The following is a short way of declaring types for each member.
Example: ValueTuple
 Copy

(int, string, string) person = (1, "James", "Bond");
person.Item1;  // returns 1
person.Item2;   // returns "James"
person.Item3;   // returns "Bond"
Try it
Note that we have not used var in the above tuple initialization statement; instead, we provided the type of each member values inside the brackets.
Tuple requires at least two values. The following is NOT a tuple.
var number = (1);  // int type, NOT a tuple
var numbers = (1,2); //valid tuple
Unlike Tuple, a ValueTuple can include more than eight values.
var numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14); 
Named Members
We can assign names to the ValueTuple properties instead of having the default property names like Item1, Item2 and so on.
Example: Named Members of ValueTuple
 Copy
(int Id, string FirstName, string LastName) person = (1, "Bill", "Gates");
person.Id;   // returns 1
person.FirstName;  // returns "Bill"
person.LastName; // returns "Gates"
Try it
We can also assign member names on the right side with values, as below.
var person = (Id:1, FirstName:"Bill", LastName: "Gates");
Please note that we can provide member names either on the left or right sides but not on both sides. The left side has precedence over the right side. The following will ignore names on the right side.
// PersonId, FName, LName will be ignored.
(int Id, string FirstName, string LastName) person = (PersonId:1, FName:"Bill", LName: "Gates");

// PersonId, FirstName, LastName will be ignored. It will have the default names: Item1, Item2, Item3.
(string, string, int) person = (PersonId:1, FName:"Bill", LName: "Gates");
We can also assign variables as member values.
string firstName = "Bill", lastName = "Gates";
var per = (FirstName: firstName, LastName: lastName);
ValueTuple as Parameter
The ValueType can also be a parameter type or return type of a method. The following method accepts a ValueTuple type parameter.
Example: ValueTuple As Parameter
 Copy
static void Main(string[] args)
{
    DisplayTuple((1, "Bill", "Gates"));
}

static void DisplayTuple((int, string, string) person)
{
    Console.WriteLine("{0}, {1}, {2}", person.Item1, person.Item2, person.Item3);
}
Try it
The following returns a ValueTuple from the method.
Example: ValueTuple As Return Type
 Copy
static void Main(string[] args)
{
    var person = GetPerson();
    Console.WriteLine("{0}, {1}, {2}", person.Item1, person.Item2, person.Item3);
}

static (int, string, string) GetPerson() 
{
    return (1, "Bill", "Gates");
}
Try it
You can also specify member names for a ValueTuple returned from the method.
Example: ValueTuple As Return Type
 Copy
static void Main(string[] args)
{
    var person = GetPerson();
    Console.WriteLine("{0}, {1}, {2}", person.Id, person.FirstName, person.LastName);
}

static (int Id, string FirstName, string LastName) GetPerson() 
{
    return (Id:1, FirstName: "Bill", LastName: "Gates");
}
Try it
Deconstruction
Individual members of a ValueTuple can be retrieved by deconstructing it. A deconstructing declaration syntax splits a ValueTuple into its parts and assigns those parts individually to fresh variables.
Example: Deconstruct ValueTuple
 Copy
static void Main(string[] args)
{
    // change property names
    (int PersonId, string FName, string LName) = GetPerson();
}
static (int, string, string) GetPerson() 
{
    return (Id:1, FirstName: "Bill", LastName: "Gates");
}
Try it
We can also use var instead of explicit data type names.
Example: Deconstruct ValueTuple
 Copy
static void Main(string[] args)
{
    // use var as datatype
    (var PersonId, var FName, var LName) = GetPerson();
}
static (int, string, string) GetPerson() 
{
    return (Id:1, FirstName: "Bill", LastName: "Gates");
}
ValueTuple also allows "discards" in deconstruction for the members you are not going to use.
// use discard _ for the unused member LName
(var id, var FName, _) = GetPerson(); 

Built-in Exception Classes in C#
Here you will learn about the built-in exception classes in C#.
C# .NET includes built-in exception classes for every possible error. The Exception class is the base class of all the exception classes.
The following is a hierarchy of exception classes in .NET:
 Exception Classes in .NET
In the above figure, the Exception class is the base class of the SystemException and ApplicationException classes. The SystemException class is the base class for all the built-in exception classes in .NET Framework.
The ApplicationException was recommended to be base class for all your custom exceptions classes (The custom exeception class should be created if non of the system exception classes can be used and you need new exception class for business rule violations or for other application related errors). It was meant to differentiates between exceptions defined by applications versus exceptions defined by the system. However, Microsoft now recommends to derive custom exception classes from the Exception class rather than the ApplicationException class .
The following figure shows how the NullReferenceException is thrown in Visual Studio debug mode when you access a null object property at runtime.
 NullReferenceException
Built-in Exception Classes
The following table lists important built-in exception classes in .NET.
Exception Class	Description
ArgumentException
Raised when a non-null argument that is passed to a method is invalid.
ArgumentNullException
Raised when null argument is passed to a method.
ArgumentOutOfRangeException
Raised when the value of an argument is outside the range of valid values.
DivideByZeroException
Raised when an integer value is divide by zero.
FileNotFoundException
Raised when a physical file does not exist at the specified location.
FormatException
Raised when a value is not in an appropriate format to be converted from a string by a conversion method such as Parse.
IndexOutOfRangeException
Raised when an array index is outside the lower or upper bounds of an array or collection.
InvalidOperationException
Raised when a method call is invalid in an object's current state.
KeyNotFoundException
Raised when the specified key for accessing a member in a collection is not exists.
NotSupportedException
Raised when a method or operation is not supported.
NullReferenceException
Raised when program access members of null object.
OverflowException
Raised when an arithmetic, casting, or conversion operation results in an overflow.
OutOfMemoryException
Raised when a program does not get enough memory to execute the code.
StackOverflowException
Raised when a stack in memory overflows.
TimeoutException
The time interval allotted to an operation has expired.
When an error occurs, either the application code or the default handler handles the exception. Learn how to handle the excetion in the next section.
Exception Handling in C#
Here, you will learn about exception handling in C# using try, catch, and finally blocks.
Exceptions in the application must be handled to prevent crashing of the program and unexpected result, log exceptions and continue with other functionalities. C# provides built-in support to handle the exception using try, catch & finally blocks.
Syntax:
try
{
    // put the code here that may raise exceptions
}
catch
{
    // handle exception here
}
finally
{
    // final cleanup code
}
try block: Any suspected code that may raise exceptions should be put inside a try{ } block. During the execution, if an exception occurs, the flow of the control jumps to the first matching catch block.
catch block: The catch block is an exception handler block where you can perform some action such as logging and auditing an exception. The catch block takes a parameter of an exception type using which you can get the details of an exception.
finally block: The finally block will always be executed whether an exception raised or not. Usually, a finally block should be used to release resources, e.g., to close any stream or file objects that were opened in the try block.
The following may throw an exception if you enter a non-numeric character.
Example: C# Program
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Enter a number: ");

        var num = int.Parse(Console.ReadLine());

        Console.WriteLine($"Squre of {num} is {num * num}");
    }
}
Try it
2.5M
96
Entity Framework Core Quiz
To handle the possible exceptions in the above example, wrap the code inside a try block and handle the exception in the catch block, as shown below.
Example: Exception handling using try-catch blocks
class Program
{
    static void Main(string[] args)
    {
        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch
        {
            Console.Write("Error occurred.");
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }
    }
}
Try it
In the above example, we wrapped this code inside a try block. If an exception occurs inside a try block, then the program will jump to the catch block. Inside a catch block, we display a message to instruct the user about his mistake, and in the finally block, we display a message about what to do after running a program.
 Note:
A try block must be followed by catch or finally or both blocks. The try block without a catch or finally block will give a compile-time error.
Ideally, a catch block should include a parameter of a built-in or custom exception class to get an error detail. The following includes the Exception type parameter that catches all types of exceptions.
Example: Exception handling using try catch block
class Program
{
    static void Main(string[] args)
    {
        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch(Exception ex)
        {
            Console.Write("Error info:" + ex.Message);
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }
    }
}
Exception Filters
You can use multiple catch blocks with the different exception type parameters. This is called exception filters. Exception filters are useful when you want to handle different types of exceptions in different ways.
Example: Exception Filters
class Program
{
    static void Main(string[] args)
    {
        Console.Write("Please enter a number to divide 100: ");
        
        try
        {
            int num = int.Parse(Console.ReadLine());

            int result = 100 / num;

            Console.WriteLine("100 / {0} = {1}", num, result);
        }
        catch(DivideByZeroException ex)
        {
            Console.Write("Cannot divide by zero. Please try again.");
        }
        catch(InvalidOperationException ex)
        {
            Console.Write("Invalid operation. Please try again.");
        }
        catch(FormatException  ex)
        {
            Console.Write("Not a valid format. Please try again.");
        }
        catch(Exception  ex)
        {
            Console.Write("Error occurred! Please try again.");
        }
    }

}
Try it
In the above example, we have specified multiple catch blocks with different exception types. We can display an appropriate message to the user, depending upon the error, so the user does not repeat the same mistake again.
 Note:
Multiple catch blocks with the same exception type are not allowed. A catch block with the base Exception type must be the last block.
Invalid catch Block
A parameterless catch block and a catch block with the Exception parameter are not allowed in the same try-catch statements, because they both do the same thing.
Example: Invalid catch
try
{
    //code that may raise an exception
}
catch //cannot have both catch and catch(Exception ex)
{ 
    Console.WriteLine("Exception occurred");
}
catch(Exception ex) //cannot have both catch and catch(Exception ex)
{
    Console.WriteLine("Exception occurred");
}
Also, parameterless catch block catch{ } or general catch block catch(Exception ex){ } must be the last block. The compiler will give an error if you have other catch blocks after a catch{ } or catch(Exception ex) block.
Example: Invalid catch
try
{
    //code that may raise an exception
}
catch
{ 
    // this catch block must be last block
}
catch (NullReferenceException nullEx)
{
    Console.WriteLine(nullEx.Message);
}
catch (InvalidCastException inEx)
{
    Console.WriteLine(inEx.Message);
}
finally Block
The finally block is an optional block and should come after a try or catch block. The finally block will always be executed whether or not an exception occurred. The finally block generally used for cleaning-up code e.g., disposing of unmanaged objects.
Example: finally Block
static void Main(string[] args)
{
    FileInfo file = null;

    try
    {
        Console.Write("Enter a file name to write: ");
        string fileName = Console.ReadLine();
        file = new FileInfo(fileName);
        file.AppendText("Hello World!")
    }
    catch(Exception ex)
    {
        Console.WriteLine("Error occurred: {0}", ex.Message );
    }
    finally
    {
        // clean up file object here;
        file = null;
    }
}
 Note:
Multiple finally blocks are not allowed. Also, the finally block cannot have the return, continue, or break keywords. It doesn't let control to leave the finally block.
Nested try-catch
C# allows nested try-catch blocks. When using nested try-catch blocks, an exception will be caught in the first matching catch block that follows the try block where an exception occurred.
Example: Nested try-catch
static void Main(string[] args)
{
    var divider = 0;

    try
    {
        try
        {
            var result = 100/divider;
        }
        catch
        {
            Console.WriteLine("Inner catch");
        }
    }
    catch
    {
        Console.WriteLine("Outer catch");
    }
}
  
Try it
Output:
Inner catch
An inner catch block will be executed in the above example because it is the first catch block that handles all exception types.
If there isn't an inner catch block that matches with raised exception type, then the control will flow to the outer catch block until it finds an appropriate exception filter. Consider the following example.
Example: Nested try-catch
static void Main(string[] args)
{
    var divider = 0;

    try
    {
        try
        {
            var result = 100/divider;
        }
        catch(NullReferenceException ex)
        {
            Console.WriteLine("Inner catch");
        }
    }
    catch
    {
        Console.WriteLine("Outer catch");
    }
}
  
Try it
Output:
Outer catch
In the above example, an exception of type DivideByZeroException will be raised. Because an inner catch block handles only the NullReferenceTypeException, it will be handle by an outer catch block.
C# - throw keyword
We have seen in the previous section how to handle exceptions which are automatically raised by CLR. Here, we will see how to raise an exception manually.
An exception can be raised manually by using the throw keyword. Any type of exceptions which is derived from Exception class can be raised using the throw keyword.
Example: throw an exception
static void Main(string[] args)
{
    Student std = null;

    try
    {
        PrintStudentName(std);
    }
    catch(Exception ex)
    {
        Console.WriteLine(ex.Message );
    }                      

    Console.ReadKey();
}

private static void PrintStudentName( Student std)
{
    if (std  == null)
        throw new NullReferenceException("Student object is null.");
        
    Console.WriteLine(std.StudentName);
}
Try it
Output:
Student object is null.
In the above example, PrintStudentName() method raises NullReferenceException if Student object is null.
Please notice that throw creates an object of any valid exception type using the new keyword. The throw keyword cannot be used with any other type which does not derive from the Exception class.
5
Re-throwing an Exception
You can also re-throw an exception from the catch block to pass on to the caller and let the caller handle it the way they want. The following example re-throws an exception.
Example: throw an exception
static void Main(string[] args)
{
    try
    {
        Method1();
    }
    catch(Exception ex)
    {
        Console.WriteLine(ex.StackTrace);
    }                      
}

static void Method1()
{
    try
    {
        Method2();
    }
    catch(Exception ex)
    {
        throw;
    } 
}

static void Method2()
{
    string str = null;
    try
    {
        Console.WriteLine(str[0]);
    }
    catch(Exception ex)
    {
        throw;
    } 
}
Try it
In the above example, an exception occurs in Method2(). The catch block simply throws that exception using only throw keyword (not throw e). This will be handled in catch block in Method1() where it again re-throw the same exception and finally it is being handled in the Main() method. The stack trace of this exception will give you the full detail of where exactly this exception occurred.
If you re-throw an exception using exception parameter then it will not preserve the original exception and creates a new exception. The following example demonstrates this.
Example: throw an exception
static void Main(string[] args)
{
    try
    {
        Method1();
    }
    catch(Exception ex)
    {
        Console.WriteLine(ex.StackTrace);
    }                      
}

static void Method1()
{
    try
    {
        Method2();
    }
    catch(Exception ex)
    {
        throw ex;
    } 
}

static void Method2()
{
    string str = null;
    try
    {
        Console.WriteLine(str[0]);
    }
    catch(Exception ex)
    {
        throw;
    } 
}
Try it
In the above example, exception caught in the Main() method will display stack trace from Method1 and Main method. It will not display Method1 in stack trace as we re-throw exception in Method1() using throw ex. So, never throw an exception using throw <exception parameter>.
Learn how to create custom exception type in the next section.
Custom Exception Type in C#
C# includes the built-in exception types such as NullReferenceException, MemoryOverflowException, etc. However, you often like to raise an exception when the business rule of your application gets violated. So, for this, you can create a custom exception class by deriving the ApplicationException class.
The .Net framework includes ApplicationException class since .Net v1.0. It was designed to use as a base class for the custom exception class. However, Microsoft now recommends Exception class to create a custom exception class. You should not throw an ApplicationException exception in your code, and you should not catch an ApplicationException exception unless you intend to re-throw the original exception.
For example, create InvalidStudentNameException class in a school application, which does not allow any special character or numeric value in a name of any of the students.
Example: ApplicationException
class Student
{
    public int StudentID { get; set; }
    public string StudentName { get; set; }
}

[Serializable]
class InvalidStudentNameException : Exception
{
    public InvalidStudentNameException() {  }

    public InvalidStudentNameException(string name)
        : base(String.Format("Invalid Student Name: {0}", name))
    {

    }
}
Now, you can raise InvalidStudentNameException in your program whenever the name contains special characters or numbers. Use the throw keyword to raise an exception.
Example: throw custom exception
class Program
{
    static void Main(string[] args)
    {
        Student newStudent = null;
          
        try
        {               
            newStudent = new Student();
            newStudent.StudentName = "James007";
            
            ValidateStudent(newStudent);
        }
        catch(InvalidStudentNameException ex)
        {
            Console.WriteLine(ex.Message );
        }
          

        Console.ReadKey();
    }

    private static void ValidateStudent(Student std)
    {
        Regex regex = new Regex("^[a-zA-Z]+$");

        if (!regex.IsMatch(std.StudentName))
             throw new InvalidStudentNameException(std.StudentName);
            
    }
}
Output:
Invalid Student Name: James000
Thus, you can create custom exception classes to differentiate from system exceptions.
C# Questions & Answers
Start C# Skill Test
C# - Delegates
What if we want to pass a function as a parameter? How does C# handles the callback functions or event handler? The answer is - delegate.
The delegate is a reference type data type that defines the method signature. You can define variables of delegate, just like other data type, that can refer to any method with the same signature as the delegate.
There are three steps involved while working with delegates:
1.	Declare a delegate
2.	Create an instance and reference a method
3.	Invoke a delegate
A delegate can be declared using the delegate keyword followed by a function signature, as shown below.
Delegate Syntax
[access modifier] delegate [return type] [delegate name]([parameters])
The following declares a delegate named MyDelegate.
Example: Declare a Delegate
public delegate void MyDelegate(string msg);
Above, we have declared a delegate MyDelegate with a void return type and a string parameter. A delegate can be declared outside of the class or inside the class. Practically, it should be declared out of the class.
After declaring a delegate, we need to set the target method or a lambda expression. We can do it by creating an object of the delegate using the new keyword and passing a method whose signature matches the delegate signature.
Example: Set Delegate Target
public delegate void MyDelegate(string msg); // declare a delegate

// set target method
MyDelegate del = new MyDelegate(MethodA);
// or 
MyDelegate del = MethodA; 
// or set lambda expression 
MyDelegate del = (string msg) =>  Console.WriteLine(msg);

// target method
static void MethodA(string message)
{
    Console.WriteLine(message);
}
You can set the target method by assigning a method directly without creating an object of delegate e.g., MyDelegate del = MethodA.
After setting a target method, a delegate can be invoked using the Invoke() method or using the () operator.
Example: Invoke a Delegate
del.Invoke("Hello World!");
// or 
del("Hello World!");
The following is a full example of a delegate.
Example: Delegate
public delegate void MyDelegate(string msg); //declaring a delegate

class Program
{
    static void Main(string[] args)
    {
        MyDelegate del = ClassA.MethodA;
        del("Hello World");

        del = ClassB.MethodB;
        del("Hello World");

        del = (string msg) => Console.WriteLine("Called lambda expression: " + msg);
        del("Hello World");
    }
}

class ClassA
{
    static void MethodA(string message)
    {
        Console.WriteLine("Called ClassA.MethodA() with parameter: " + message);
    }
}

class ClassB
{
    static void MethodB(string message)
    {
        Console.WriteLine("Called ClassB.MethodB() with parameter: " + message);
    }
}
Try it
The following image illustrates the delegate.
 C# Delegate
Passing Delegate as a Parameter
A method can have a parameter of the delegate type, as shown below.
Example: Delegate
public delegate void MyDelegate(string msg); //declaring a delegate

class Program
{
    static void Main(string[] args)
    {
        MyDelegate del = ClassA.MethodA;
        InvokeDelegate(del);

        del = ClassB.MethodB;
        InvokeDelegate(del);

        del = (string msg) => Console.WriteLine("Called lambda expression: " + msg);
        InvokeDelegate(del);
    }

    static void InvokeDelegate(MyDelegate del) // MyDelegate type parameter
    {
        del("Hello World");
    }
}

class ClassA
{
    static void MethodA(string message)
    {
        Console.WriteLine("Called ClassA.MethodA() with parameter: " + message);
    }
}

class ClassB
{
    static void MethodB(string message)
    {
        Console.WriteLine("Called ClassB.MethodB() with parameter: " + message);
    }
}
Try it
 Note:
In .NET, Func and Action types are built-in generic delegates that should be used for most common delegates instead of creating new custom delegates.
Multicast Delegate
The delegate can point to multiple methods. A delegate that points multiple methods is called a multicast delegate. The "+" or "+=" operator adds a function to the invocation list, and the "-" and "-=" operator removes it.
Example: Multicast Delegate
public delegate void MyDelegate(string msg); //declaring a delegate

class Program
{
    static void Main(string[] args)
    {
        MyDelegate del1 = ClassA.MethodA;
        MyDelegate del2 = ClassB.MethodB;

        MyDelegate del = del1 + del2; // combines del1 + del2
        del("Hello World");

        MyDelegate del3 = (string msg) => Console.WriteLine("Called lambda expression: " + msg);
        del += del3; // combines del1 + del2 + del3
        del("Hello World");

        del = del - del2; // removes del2
        del("Hello World");

        del -= del1 // removes del1
        del("Hello World");
    }
}

class ClassA
{
    static void MethodA(string message)
    {
        Console.WriteLine("Called ClassA.MethodA() with parameter: " + message);
    }
}

class ClassB
{
    static void MethodB(string message)
    {
        Console.WriteLine("Called ClassB.MethodB() with parameter: " + message);
    }
}
Try it
The addition and subtraction operators always work as part of the assignment: del1 += del2; is exactly equivalent to del1 = del1+del2; and likewise for subtraction.
If a delegate returns a value, then the last assigned target method's value will be return when a multicast delegate called.
Example: Multicast Delegate Returning a Value
public delegate int MyDelegate(); //declaring a delegate

class Program
{
    static void Main(string[] args)
    {
        MyDelegate del1 = ClassA.MethodA;
        MyDelegate del2 = ClassB.MethodB;

        MyDelegate del = del1 + del2; 
        Console.WriteLine(del());// returns 200
    }
}

class ClassA
{
    static int MethodA()
    {
        return 100;
    }
}

class ClassB
{
    static int MethodB()
    {
        return 200;
    }
}
Try it
Generic Delegate
A generic delegate can be defined the same way as a delegate but using generic type parameters or return type. The generic type must be specified when you set a target method.
For example, consider the following generic delegate that is used for int and string parameters.
Example: Generic Delegate
public delegate T add<T>(T param1, T param2); // generic delegate

class Program
{
    static void Main(string[] args)
    {
        add<int> sum = Sum;
        Console.WriteLine(sum(10, 20));

        add<string> con = Concat;
        Console.WriteLine(conct("Hello ","World!!"));
    }

    public static int Sum(int val1, int val2)
    {
        return val1 + val2;
    }

    public static string Concat(string str1, string str2)
    {
        return str1 + str2;
    }
}
Try it
Delegate is also used to declare an Event and an Anonymous Method.
Learn more about delegate here.
  Points to Remember :
1.	Delegate is the reference type data type that defines the signature.
2.	Delegate type variable can refer to any method with the same signature as the delegate.
3.	Syntax: [access modifier] delegate [return type] [delegate name]([parameters])
4.	A target method's signature must match with delegate signature.
5.	Delegates can be invoke like a normal function or Invoke() method.
6.	Multiple methods can be assigned to the delegate using "+" or "+=" operator and removed using "-" or "-=" operator. It is called multicast delegate.
7.	If a multicast delegate returns a value then it returns the value from the last assigned target method.
8.	Delegate is used to declare an event and anonymous methods in C#.
C# - Func Delegate
C# includes built-in generic delegate types Func and Action, so that you don't need to define custom delegates manually in most cases.
Func is a generic delegate included in the System namespace. It has zero or more input parameters and one out parameter. The last parameter is considered as an out parameter.
The Func delegate that takes one input parameter and one out parameter is defined in the System namespace, as shown below:
Signature: Func
namespace System
{    
    public delegate TResult Func<in T, out TResult>(T arg);
}
The last parameter in the angle brackets <> is considered the return type, and the remaining parameters are considered input parameter types, as shown in the following figure.
 Func delegate
A Func delegate with two input parameters and one out parameters will be represented as shown below.
 Func delegate
The following Func delegate takes two input parameters of int type and returns a value of int type:
Func<int, int, int> sum;
You can assign any method to the above func delegate that takes two int parameters and returns an int value.
Example: Func
class Program
{
    static int Sum(int x, int y)
    {
        return x + y;
    }

    static void Main(string[] args)
    {
        Func<int,int, int> add = Sum;

        int result = add(10, 10);

        Console.WriteLine(result); 
    }
}
Try it
Output:
20
A Func delegate type can include 0 to 16 input parameters of different types. However, it must include an out parameter for the result. For example, the following Func delegate doesn't have any input parameter, and it includes only an out parameter.
Example: Func with Zero Input Parameter
Func<int> getRandomNumber;
1
C# Func with an Anonymous Method
You can assign an anonymous method to the Func delegate by using the delegate keyword.
Example: Func with Anonymous Method
Func<int> getRandomNumber = delegate()
                            {
                                Random rnd = new Random();
                                return rnd.Next(1, 100);
                            };
Func with Lambda Expression
A Func delegate can also be used with a lambda expression, as shown below:
Example: Func with lambda expression
Func<int> getRandomNumber = () => new Random().Next(1, 100);

//Or 

Func<int, int, int>  Sum  = (x, y) => x + y;
Try it
  Points to Remember :
1.	Func is built-in delegate type.
2.	Func delegate type must return a value.
3.	Func delegate type can have zero to 16 input parameters.
4.	Func delegate does not allow ref and out parameters.
5.	Func delegate type can be used with an anonymous method or lambda expression.
C# - Action Delegate
Action is a delegate type defined in the System namespace. An Action type delegate is the same as Func delegate except that the Action delegate doesn't return a value. In other words, an Action delegate can be used with a method that has a void return type.
For example, the following delegate prints an int value.
Example: C# Delegate
public delegate void Print(int val);

static void ConsolePrint(int i)
{
    Console.WriteLine(i);
}

static void Main(string[] args)
{           
    Print prnt = ConsolePrint;
    prnt(10);
}
Output:
10
You can use an Action delegate instead of defining the above Print delegate, for example:
Example: Action delegate
static void ConsolePrint(int i)
{
    Console.WriteLine(i);
}

static void Main(string[] args)
{
    Action<int> printActionDel = ConsolePrint;
    printActionDel(10);
}
Try it
You can initialize an Action delegate using the new keyword or by directly assigning a method:
Action<int> printActionDel = ConsolePrint;

//Or

Action<int> printActionDel = new Action<int>(ConsolePrint);
An Action delegate can take up to 16 input parameters of different types.
An Anonymous method can also be assigned to an Action delegate, for example:
Example: Anonymous method with Action delegate
static void Main(string[] args)
{
    Action<int> printActionDel = delegate(int i)
                                {
                                    Console.WriteLine(i);
                                };

    printActionDel(10);
}
Try it
Output:
10
A Lambda expression also can be used with an Action delegate:
Example: Lambda expression with Action delegate
static void Main(string[] args)
{

    Action<int> printActionDel = i => Console.WriteLine(i);
       
    printActionDel(10);
}
Try it
Thus, you can use any method that doesn't return a value with Action delegate types.
Advantages of Action and Func Delegates
1.	Easy and quick to define delegates.
2.	Makes code short.
3.	Compatible type throughout the application.
  Points to Remember :
1.	Action delegate is same as func delegate except that it does not return anything. Return type must be void.
2.	Action delegate can have 0 to 16 input parameters.
3.	Action delegate can be used with anonymous methods or lambda expressions.
C# - Predicate Delegate
Predicate is the delegate like Func and Action delegates. It represents a method containing a set of criteria and checks whether the passed parameter meets those criteria. A predicate delegate methods must take one input parameter and return a boolean - true or false.
The Predicate delegate is defined in the System namespace, as shown below:
Predicate signature: public delegate bool Predicate<in T>(T obj);
Same as other delegate types, Predicate can also be used with any method, anonymous method, or lambda expression.
Example: Predicate delegate
static bool IsUpperCase(string str)
{
    return str.Equals(str.ToUpper());
}

static void Main(string[] args)
{
    Predicate<string> isUpper = IsUpperCase;

    bool result = isUpper("hello world!!");

    Console.WriteLine(result);
}
Try it
Output:
false
An anonymous method can also be assigned to a Predicate delegate type as shown below.
Example: Predicate delegate with anonymous method
static void Main(string[] args)
{
    Predicate<string> isUpper = delegate(string s) { return s.Equals(s.ToUpper());};
    bool result = isUpper("hello world!!");
}
Try it
A lambda expression can also be assigned to a Predicate delegate type as shown below.
Example: Predicate delegate with lambda expression
static void Main(string[] args)
{
    Predicate<string> isUpper = s => s.Equals(s.ToUpper());
    bool result = isUpper("hello world!!");
}
Try it
  Points to Remember:
1.	Predicate delegate takes one input parameter and boolean return type.
2.	Anonymous method and Lambda expression can be assigned to the predicate delegate.
C# - Predicate Delegate
Predicate is the delegate like Func and Action delegates. It represents a method containing a set of criteria and checks whether the passed parameter meets those criteria. A predicate delegate methods must take one input parameter and return a boolean - true or false.
The Predicate delegate is defined in the System namespace, as shown below:
Predicate signature: public delegate bool Predicate<in T>(T obj);
Same as other delegate types, Predicate can also be used with any method, anonymous method, or lambda expression.
Example: Predicate delegate
static bool IsUpperCase(string str)
{
    return str.Equals(str.ToUpper());
}

static void Main(string[] args)
{
    Predicate<string> isUpper = IsUpperCase;

    bool result = isUpper("hello world!!");

    Console.WriteLine(result);
}
Try it
Output:
false
An anonymous method can also be assigned to a Predicate delegate type as shown below.
Example: Predicate delegate with anonymous method
static void Main(string[] args)
{
    Predicate<string> isUpper = delegate(string s) { return s.Equals(s.ToUpper());};
    bool result = isUpper("hello world!!");
}
Try it
A lambda expression can also be assigned to a Predicate delegate type as shown below.
Example: Predicate delegate with lambda expression
static void Main(string[] args)
{
    Predicate<string> isUpper = s => s.Equals(s.ToUpper());
    bool result = isUpper("hello world!!");
}
Try it
  Points to Remember:
1.	Predicate delegate takes one input parameter and boolean return type.
2.	Anonymous method and Lambda expression can be assigned to the predicate delegate.
C# - Events
An event is a notification sent by an object to signal the occurrence of an action. Events in .NET follow the observer design pattern.
The class who raises events is called Publisher, and the class who receives the notification is called Subscriber. There can be multiple subscribers of a single event. Typically, a publisher raises an event when some action occurred. The subscribers, who are interested in getting a notification when an action occurred, should register with an event and handle it.
In C#, an event is an encapsulated delegate. It is dependent on the delegate. The delegate defines the signature for the event handler method of the subscriber class.
The following figure illustrates the event in C#.
 Event Publisher & Subscriber
2.5M
96 
Entity Framework Core Quiz
Declare an Event
An event can be declared in two steps:
1.	Declare a delegate.
2.	Declare a variable of the delegate with event keyword.
The following example shows how to declare an event in publisher class.
Example: Declaring an Event
public delegate void Notify();  // delegate
                    
public class ProcessBusinessLogic
{
    public event Notify ProcessCompleted; // event

}
In the above example, we declared a delegate Notify and then declared an event ProcessCompleted of delegate type Notify using "event" keyword in the ProcessBusinessLogic class. Thus, the ProcessBusinessLogic class is called the publisher. The Notify delegate specifies the signature for the ProcessCompleted event handler. It specifies that the event handler method in subscriber class must have a void return type and no parameters.
Now, let's see how to raise the ProcessCompleted event. Consider the following implementation.
Example: Raising an Event
public delegate void Notify();  // delegate
                    
public class ProcessBusinessLogic
{
    public event Notify ProcessCompleted; // event

    public void StartProcess()
    {
        Console.WriteLine("Process Started!");
        // some code here..
        OnProcessCompleted();
    }

    protected virtual void OnProcessCompleted() //protected virtual method
    {
        //if ProcessCompleted is not null then call delegate
        ProcessCompleted?.Invoke(); 
    }
}
Above, the StartProcess() method calls the method onProcessCompleted() at the end, which raises an event. Typically, to raise an event, protected and virtual method should be defined with the name On<EventName>. Protected and virtual enable derived classes to override the logic for raising the event. However, A derived class should always call the On<EventName> method of the base class to ensure that registered delegates receive the event.
The OnProcessCompleted() method invokes the delegate using ProcessCompleted?.Invoke();. This will call all the event handler methods registered with the ProcessCompleted event.
The subscriber class must register to ProcessCompleted event and handle it with the method whose signature matches Notify delegate, as shown below.
Example: Consume an Event
class Program
{
    public static void Main()
    {
        ProcessBusinessLogic bl = new ProcessBusinessLogic();
        bl.ProcessCompleted += bl_ProcessCompleted; // register with an event
        bl.StartProcess();
    }

    // event handler
    public static void bl_ProcessCompleted()
    {
        Console.WriteLine("Process Completed!");
    }
}
Try it
Above, the Program class is a subscriber of the ProcessCompleted event. It registers with the event using += operator. Remember, this is the same way we add methods in the invocation list of multicast delegate. The bl_ProcessCompleted() method handles the event because it matches the signature of the Notify delegate.
Built-in EventHandler Delegate
.NET Framework includes built-in delegate types EventHandler and EventHandler<TEventArgs> for the most common events. Typically, any event should include two parameters: the source of the event and event data. Use the EventHandler delegate for all events that do not include event data. Use EventHandler<TEventArgs> delegate for events that include data to be sent to handlers.
The example shown above can use EventHandler delegate without declaring a custom Notify delegate, as shown below.
Example: EventHandler
class Program
{
    public static void Main()
    {
        ProcessBusinessLogic bl = new ProcessBusinessLogic();
        bl.ProcessCompleted += bl_ProcessCompleted; // register with an event
        bl.StartProcess();
    }

    // event handler
    public static void bl_ProcessCompleted(object sender, EventArgs e)
    {
        Console.WriteLine("Process Completed!");
    }
}

public class ProcessBusinessLogic
{
    // declaring an event using built-in EventHandler
    public event EventHandler ProcessCompleted; 

    public void StartProcess()
    {
        Console.WriteLine("Process Started!");
        // some code here..
        OnProcessCompleted(EventArgs.Empty); //No event data
    }

    protected virtual void OnProcessCompleted(EventArgs e)
    {
        ProcessCompleted?.Invoke(this, e);
    }
}
Try it
In the above example, the event handler bl_ProcessCompleted() method includes two parameters that match with EventHandler delegate. Also, passing this as a sender and EventArgs.Empty, when we raise an event using Invoke() in the OnProcessCompleted() method. Because we don't need any data for our event, it just notifies subscribers about the completion of the process, and so we passed EventArgs.Empty.
Passing an Event Data
Most events send some data to the subscribers. The EventArgs class is the base class for all the event data classes. .NET includes many built-in event data classes such as SerialDataReceivedEventArgs. It follows a naming pattern of ending all event data classes with EventArgs. You can create your custom class for event data by deriving EventArgs class.
Use EventHandler<TEventArgs> to pass data to the handler, as shown below.
Example: Passing Event Data
class Program
{
    public static void Main()
    {
        ProcessBusinessLogic bl = new ProcessBusinessLogic();
        bl.ProcessCompleted += bl_ProcessCompleted; // register with an event
        bl.StartProcess();
    }

    // event handler
    public static void bl_ProcessCompleted(object sender, bool IsSuccessful)
    {
        Console.WriteLine("Process " + (IsSuccessful? "Completed Successfully": "failed"));
    }
}

public class ProcessBusinessLogic
{
    // declaring an event using built-in EventHandler
    public event EventHandler<bool> ProcessCompleted; 

    public void StartProcess()
    {
        try
        {
            Console.WriteLine("Process Started!");
			
            // some code here..

            OnProcessCompleted(true);
        }
        catch(Exception ex)
        {
            OnProcessCompleted(false);
        }
    }

    protected virtual void OnProcessCompleted(bool IsSuccessful)
    {
        ProcessCompleted?.Invoke(this, IsSuccessful);
    }
}
Try it
In the above example, we are passing a single boolean value to the handlers that indicate whether the process completed successfully or not.
If you want to pass more than one value as event data, then create a class deriving from the EventArgs base class, as shown below.
Example: Custom EventArgs Class
class ProcessEventArgs : EventArgs
{
    public bool IsSuccessful { get; set; }
    public DateTime CompletionTime { get; set; }
}
The following example shows how to pass custom ProcessEventArgs class to the handlers.
Example: Passing Custom EventArgs
class Program
{
    public static void Main()
    {
        ProcessBusinessLogic bl = new ProcessBusinessLogic();
        bl.ProcessCompleted += bl_ProcessCompleted; // register with an event
        bl.StartProcess();
    }

    // event handler
    public static void bl_ProcessCompleted(object sender, ProcessEventArgs e)
    {
        Console.WriteLine("Process " + (e.IsSuccessful? "Completed Successfully": "failed"));
        Console.WriteLine("Completion Time: " + e.CompletionTime.ToLongDateString());
    }
}

public class ProcessBusinessLogic
{
    // declaring an event using built-in EventHandler
    public event EventHandler<ProcessEventArgs> ProcessCompleted; 

    public void StartProcess()
    {
        var data = new ProcessEventArgs();
		
        try
        {
            Console.WriteLine("Process Started!");
			
            // some code here..
            
            data.IsSuccessful = true;
            data.CompletionTime = DateTime.Now;
            OnProcessCompleted(data);
        }
        catch(Exception ex)
        {
            data.IsSuccessful = false;
            data.CompletionTime = DateTime.Now;
            OnProcessCompleted(data);
        }
    }

    protected virtual void OnProcessCompleted(ProcessEventArgs e)
    {
        ProcessCompleted?.Invoke(this, e);
    }
}
Try it
Thus, you can create, raise, register, and handle events in C#.
Learn What is the difference between delegate and event in C#?.
  Points to Remember :
1.	An event is a wrapper around a delegate. It depends on the delegate.
2.	Use "event" keyword with delegate type variable to declare an event.
3.	Use built-in delegate EventHandler or EventHandler<TEventArgs> for common events.
4.	The publisher class raises an event, and the subscriber class registers for an event and provides the event-handler method.
5.	Name the method which raises an event prefixed with "On" with the event name.
6.	The signature of the handler method must match the delegate signature.
7.	Register with an event using the += operator. Unsubscribe it using the -= operator. Cannot use the = operator.
8.	Pass event data using EventHandler<TEventArgs>.
9.	Derive EventArgs base class to create custom event data class.
10.	Events can be declared static, virtual, sealed, and abstract.
11.	An Interface can include the event as a member.
12.	Event handlers are invoked synchronously if there are multiple subscribers.
13.	Covariance and Contravariance in C#
14.	Covariance and contravariance allow us to be flexible when dealing with class hierarchy.
15.	Consider the following class hierarchy before we learn about covariance and contravariance:
16.	Example: Class Hierarchy
17.	public class Small
18.	{ 
19.	
20.	}
21.	public class Big: Small
22.	{
23.	
24.	}
25.	public class Bigger : Big
26.	{ 
27.	    
28.	}
29.	As per the above example classes, small is a base class for big and big is a base class for bigger. The point to remember here is that a derived class will always have something more than a base class, so the base class is relatively smaller than the derived class.
30.	Now, consider the following initialization:
31.	 Class initialization
32.	As you can see above, a base class can hold a derived class but a derived class cannot hold a base class. In other word, an instance can accept big even if it demands small, but it cannot accept small if it demands big.
33.	Now, let's learn about covariance and contravariance.
34.	 
35.	2
36.	Covariance in C#
37.	Covariance enables you to pass a derived type where a base type is expected. Co-variance is like variance of the same kind. The base class and other derived classes are considered to be the same kind of class that adds extra functionalities to the base type. So covariance allows you to use a derived class where a base class is expected (rule: can accept big if small is expected).
38.	Covariance can be applied on delegate, generic, array, interface, etc.
39.	Covariance with Delegate
40.	Covariance in delegates allows flexiblity in the return type of delegate methods.
41.	Example: Covariance with Delegate
42.	public delegate Small covarDel(Big mc);
43.	
44.	public class Program
45.	{
46.	    public static Big Method1(Big bg)
47.	    {
48.	        Console.WriteLine("Method1");
49.	    
50.	        return new Big();
51.	    }
52.	    public static Small Method2(Big bg)
53.	    {
54.	        Console.WriteLine("Method2");
55.	    
56.	        return new Small();
57.	    }
58.	        
59.	    public static void Main(string[] args)
60.	    {
61.	        covarDel del = Method1;
62.	
63.	        Small sm1 = del(new Big());
64.	
65.	        del= Method2;
66.	        Small sm2 = del(new Big());
67.	    }
68.	}
69.	Try it
70.	Output:
71.	Method1
Method2
72.	As you can see in the above example, delegate expects a return type of small (base class) but we can still assign Method1 that returns Big (derived class) and also Method2 that has same signature as delegate expects.
73.	Thus, covariance allows you to assign a method to the delegate that has a less derived return type.
74.	C# Contravariance
75.	Contravariance is applied to parameters. Contravariance allows a method with the parameter of a base class to be assigned to a delegate that expects the parameter of a derived class.
76.	Continuing with the example above, add Method3 that has a different parameter type than delegate:
77.	Example: Contravariance with Delegate
78.	delegate Small covarDel(Big mc);
79.	
80.	class Program
81.	{
82.	    static Big Method1(Big bg)
83.	    {
84.	        Console.WriteLine("Method1");
85.	        return new Big();
86.	    }
87.	    static Small Method2(Big bg)
88.	    {
89.	        Console.WriteLine("Method2");
90.	        return new Small();
91.	    }
92.	
93.	    static Small Method3(Small sml)
94.	    {
95.	        Console.WriteLine("Method3");
96.	        
97.	        return new Small();
98.	    }
99.	    static void Main(string[] args)
100.	    {
101.	        covarDel del = Method1;
102.	        del += Method2;
103.	        del += Method3;
104.	
105.	        Small sm = del(new Big());
106.	}
107.	Output:
108.	Method1
Method2
Method3
109.	As you can see, Method3 has a parameter of Small class whereas delegate expects a parameter of Big class. Still, you can use Method3 with the delegate.
110.	You can also use covariance and contravariance in the same method as shown below.
111.	Example: Covariance and Contravariance
112.	delegate Small covarDel(Big mc);
113.	
114.	class Program
115.	{
116.	
117.	    static Big Method4(Small sml)
118.	    {
119.	        Console.WriteLine("Method3");
120.	    
121.	        return new Big();
122.	    }
123.	
124.	    static void Main(string[] args)
125.	    {
126.	        covarDel del = Method4;
127.	    
128.	        Small sm = del(new Big());
129.	    }
130.	}
131.	Output:
132.	Method4
C# - Extension Method
Extension methods, as the name suggests, are additional methods. Extension methods allow you to inject additional methods without modifying, deriving or recompiling the original class, struct or interface. Extension methods can be added to your own custom class, .NET framework classes, or third party classes or interfaces.
In the following example, IsGreaterThan() is an extension method for int type, which returns true if the value of the int variable is greater than the supplied integer parameter.
Example: Extension Method
int i = 10;

bool result = i.IsGreaterThan(100); //returns false 

The IsGreaterThan() method is not a method of int data type (Int32 struct). It is an extension method written by the programmer for the int data type. The IsGreaterThan() extension method will be available throughout the application by including the namespace in which it has been defined.
The extension methods have a special symbol in intellisense of the visual studio, so that you can easily differentiate between class methods and extension methods.
 Extension Method Symbol in visual studio intellisense
Now let's see how to write an extension method.
 LINQ is built upon extension methods that operate on IEnumerable and IQeryable type.
An extension method is actually a special kind of static method defined in a static class. To define an extension method, first of all, define a static class.
For example, we have created an IntExtensions class under the ExtensionMethods namespace in the following example. The IntExtensions class will contain all the extension methods applicable to int data type. (You may use any name for namespace and class.)
Example: Create a Class for Extension Methods
namespace ExtensionMethods
{
    public static class IntExtensions
    {

    }
}
Now, define a static method as an extension method where the first parameter of the extension method specifies the type on which the extension method is applicable. We are going to use this extension method on int type. So the first parameter must be int preceded with the this modifier.
For example, the IsGreaterThan() method operates on int, so the first parameter would be, this int i.
Example: Define an Extension Method
namespace ExtensionMethods
{
    public static class IntExtensions
     {
        public static bool IsGreaterThan(this int i, int value)
        {
            return i > value;
        }
    }
}
Now, you can include the ExtensionMethods namespace wherever you want to use this extension method.
Example: Extension method
using ExtensionMethods;

class Program
{
    static void Main(string[] args)
    {
        int i = 10;

        bool result = i.IsGreaterThan(100); 

        Console.WriteLine(result);
    }
}
Try it
Output:
false
 Note:
The only difference between a regular static method and an extension method is that the first parameter of the extension method specifies the type that it is going to operator on, preceded by the this keyword.
  Points to Remember :
1.	Extension methods are additional custom methods which were originally not included with the class.
2.	Extension methods can be added to custom, .NET Framework or third party classes, structs or interfaces.
3.	The first parameter of the extension method must be of the type for which the extension method is applicable, preceded by the this keyword.
4.	Extension methods can be used anywhere in the application by including the namespace of the extension method.
C# - Stream
C# includes following standard IO (Input/Output) classes to read/write from different sources like files, memory, network, isolated storage, etc.
Stream: System.IO.Stream is an abstract class that provides standard methods to transfer bytes (read, write, etc.) to the source. It is like a wrapper class to transfer bytes. Classes that need to read/write bytes from a particular source must implement the Stream class.
The following classes inherit Stream class to provide the functionality to Read/Write bytes from a particular source:
FileStream reads or writes bytes from/to a physical file, whether it is a .txt, .exe, .jpg, or any other file. FileStream is derived from the Stream class.
MemoryStream: MemoryStream reads or writes bytes that are stored in memory.
BufferedStream: BufferedStream reads or writes bytes from other Streams to improve certain I/O operations' performance.
NetworkStream: NetworkStream reads or writes bytes from a network socket.
PipeStream: PipeStream reads or writes bytes from different processes.
CryptoStream: CryptoStream is for linking data streams to cryptographic transformations.
The following diagram shows the hierarchy of stream classes:
 Stream Classes Hierarchy
Stream Readers and Writers
StreamReader: StreamReader is a helper class for reading characters from a Stream by converting bytes into characters using an encoded value. It can be used to read strings (characters) from different Streams like FileStream, MemoryStream, etc.
StreamWriter: StreamWriter is a helper class for writing a string to a Stream by converting characters into bytes. It can be used to write strings to different Streams such as FileStream, MemoryStream, etc.
BinaryReader: BinaryReader is a helper class for reading primitive datatype from bytes.
BinaryWriter: BinaryWriter writes primitive types in binary.
 Stream IO
The above image shows that FileStream reads bytes from a physical file, and then StreamReader reads strings by converting those bytes to strings. In the same way, the StreamWriter takes a string and converts it into bytes and writes to the FileStream, and then the FileStream writes the bytes to a physical file. So, the FileStream deals with bytes, where as StreamReader and StreamWriter deals with strings.
  Points to Remember :
1.	Stream is an abstract class for transfering bytes from different sources. It is base class for all other class that reads\writes bytes to different sources.
2.	FileStream class provides reading and writing functionality of bytes to physical file.
3.	Reader & writer classes provides functionality to read bytes from Stream classes (FileStream, MemoryStream etc) and converts bytes into appropriate encoding.
4.	StreamReader provides a helper method to read string from FileStream by converting bytes into strings. StreamWriter provides a helper method to write string to FileStream by converting strings into bytes.
Learn how to read/write to the File system in the next section.
Working with Files & Directories in C#
C# provides the following classes to work with the File system. They can be used to access directories, access files, open files for reading or writing, create a new file or move existing files from one location to another, etc.
Class Name	Usage
File
File is a static class that provides different functionalities like copy, create, move, delete, open for reading or /writing, encrypt or decrypt, check if a file exists, append lines or text to a file's content, get last access time, etc.
FileInfo
The FileInfo class provides the same functionality as a static File class. You have more control on how you do read/write operations on a file by writing code manually for reading or writing bytes from a file.
Directory
Directory is a static class that provides functionality for creating, moving, deleting and accessing subdirectories.
DirectoryInfo
DirectoryInfo provides instance methods for creating, moving, deleting and accessing subdirectories.
Path
Path is a static class that provides functionality such as retrieving the extension of a file, changing the extension of a file, retrieving the absolute physical path, and other path related functionalities.
File
C# includes static File class to perform I/O operation on physical file system. The static File class includes various utility method to interact with physical file of any type e.g. binary, text etc.
Use this static File class to perform some quick operation on physical file. It is not recommended to use File class for multiple operations on multiple files at the same time due to performance reasons. Use FileInfo class in that scenario.
Important Methods of Static File Class
Method	Usage
AppendAllLines	Appends lines to a file, and then closes the file. If the specified file does not exist, this method creates a file, writes the specified lines to the file, and then closes the file.
AppendAllText	Opens a file, appends the specified string to the file, and then closes the file. If the file does not exist, this method creates a file, writes the specified string to the file, then closes the file.
AppendText	Creates a StreamWriter that appends UTF-8 encoded text to an existing file, or to a new file if the specified file does not exist.
Copy	Copies an existing file to a new file. Overwriting a file of the same name is not allowed.
Create	Creates or overwrites a file in the specified path.
CreateText	Creates or opens a file for writing UTF-8 encoded text.
Decrypt	Decrypts a file that was encrypted by the current account using the Encrypt method.
Delete	Deletes the specified file.
Encrypt	Encrypts a file so that only the account used to encrypt the file can decrypt it.
Exists	Determines whether the specified file exists.
GetAccessControl	Gets a FileSecurity object that encapsulates the access control list (ACL) entries for a specified file.
Move	Moves a specified file to a new location, providing the option to specify a new file name.
Open	Opens a FileStream on the specified path with read/write access.
ReadAllBytes	Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
ReadAllLines	Opens a text file, reads all lines of the file, and then closes the file.
ReadAllText	Opens a text file, reads all lines of the file, and then closes the file.
Replace	Replaces the contents of a specified file with the contents of another file, deleting the original file, and creating a backup of the replaced file.
WriteAllBytes	Creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is overwritten.
WriteAllLines	Creates a new file, writes a collection of strings to the file, and then closes the file.
WriteAllText	Creates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is overwritten.
Append Text Lines
Use AppendAllLines() method to append multiple text lines to the specified file as shown below.
Example: Append all text lines to a file
string dummyLines = "This is first line." + Environment.NewLine +
                    "This is second line." + Environment.NewLine +
                    "This is third line.";

//Opens DummyFile.txt and append lines. If file is not exists then create and open.
File.AppendAllLines(@"C:\DummyFile.txt", dummyLines.Split(Environment.NewLine.ToCharArray()).ToList<string>());
Append String
Use File.AppendAllText() method to append string to a file in single line of code as shown below.
Example: Append string to a file
//Opens DummyFile.txt and append Text. If file is not exists then create and open.
File.AppendAllText(@"C:\ DummyFile.txt", "This is File testing");
Overwrite Text
Use File.WriteAllText() method to write texts to the file. Please note that it will not append text but overwrite existing texts.
Example: Overwrite existing texts
//Opens DummyFile.txt and write texts. If file is not exists then create and open.
File.WriteAllText(@"C:\DummyFile.txt", "This is dummy text");
The following example shows how to perform different operations using static File class.
Example: Multiple File operations
//Check whether file is exists or not at particular location
bool isFileExists = File.Exists(@"C:\ DummyFile.txt"); // returns false

//Copy DummyFile.txt as new file DummyFileNew.txt
File.Copy(@"C:\DummyFile.txt", @"D:\NewDummyFile.txt");

//Get when the file was accessed last time 
DateTime lastAccessTime = File.GetLastAccessTime(@"C:\DummyFile.txt");

//get when the file was written last time
DateTime lastWriteTime = File.GetLastWriteTime(@"C:\DummyFile.txt");

// Move file to new location
File.Move(@"C:\DummyFile.txt", @"D:\DummyFile.txt");

//Open file and returns FileStream for reading bytes from the file
FileStream fs = File.Open(@"D:\DummyFile.txt", FileMode.OpenOrCreate);

//Open file and return StreamReader for reading string from the file
StreamReader sr = File.OpenText(@"D:\DummyFile.txt");
    
//Delete file
File.Delete(@"C:\DummyFile.txt");
Thus, it is easy to work with physical file using static File class. However, if you want more flexibility then use FileInfo class. The same way, use static Directory class to work with physical directories.
Visit MSDN to know all the methods of the static File class.
  Points to Remember :
1.	File is a static class to read\write from physical file with less coding.
2.	Static File class provides functionalities such as create, read\write, copy, move, delete and others for physical files.
3.	Static Directory class provides functionalities such as create, copy, move, delete etc for physical directories with less coding.
4.	FileInfo and DirectoryInfo class provides same functionality as static File and Directory class.
5.	C# - FileInfo
6.	Here, you will learn how to use FileInfo class to perform read/write operation on physical files.
7.	The FileInfo class provides the same functionality as the static File class but you have more control on read/write operations on files by writing code manually for reading or writing bytes from a file.
8.	Important Properties and Methods of FileInfo:
Property	Usage
Directory	Gets an instance of the parent directory.
DirectoryName	Gets a string representing the directory's full path.
Exists	Gets a value indicating whether a file exists.
Extension	Gets the string representing the extension part of the file.
FullName	Gets the full path of the directory or file.
IsReadOnly	Gets or sets a value that determines if the current file is read only.
LastAccessTime	Gets or sets the time the current file or directory was last accessed
LastWriteTime	Gets or sets the time when the current file or directory was last written to
Length	Gets the size, in bytes, of the current file.
Name	Gets the name of the file.
Method	Usage
AppendText	Creates a StreamWriter that appends text to the file represented by this instance of the FileInfo.
CopyTo	Copies an existing file to a new file, disallowing the overwriting of an existing file.
Create	Creates a file.
CreateText	Creates a StreamWriter that writes a new text file.
Decrypt	Decrypts a file that was encrypted by the current account using the Encrypt method.
Delete	Deletes the specified file.
Encrypt	Encrypts a file so that only the account used to encrypt the file can decrypt it.
GetAccessControl	Gets a FileSecurity object that encapsulates the access control list (ACL) entries for a specified file.
MoveTo	Moves a specified file to a new location, providing the option to specify a new file name.
Open	Opens a in the specified FileMode.
OpenRead	Creates a read-only FileStream.
OpenText	Creates a StreamReader with UTF8 encoding that reads from an existing text file.
OpenWrite	Creates a write-only FileStream.
Replace	Replaces the contents of a specified file with the file described by the current FileInfo object, deleting the original file, and creating a backup of the replaced file.
ToString	Returns a path as string.
10.	2.5M
11.	96
12.	Entity Framework Core Quiz
13.	The following example shows how to read bytes from a file manually and then convert them to a string using UTF8 encoding:
14.	Example: Read file using FileInfo class
15.	//Create object of FileInfo for specified path            
16.	FileInfo fi = new FileInfo(@"D:\DummyFile.txt");
17.	
18.	//Open file for Read\Write
19.	FileStream fs = fi.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite); 
20.	
21.	//create byte array of same size as FileStream length
22.	byte[] fileBytes = new byte[fs.Length];
23.	
24.	//define counter to check how much bytes to read. Decrease the counter as you read each byte
25.	int numBytesToRead = (int)fileBytes.Length;
26.	
27.	//Counter to indicate number of bytes already read
28.	int numBytesRead = 0;
29.	
30.	//iterate till all the bytes read from FileStream
31.	while (numBytesToRead > 0)
32.	{
33.	    int n = fs.Read(fileBytes, numBytesRead, numBytesToRead);
34.	        
35.	    if (n == 0)
36.	        break;
37.	
38.	    numBytesRead += n;
39.	    numBytesToRead -= n;
40.	}
41.	
42.	//Once you read all the bytes from FileStream, you can convert it into string using UTF8 encoding
43.	string filestring = Encoding.UTF8.GetString(fileBytes);
44.	As you have seen in the above code, you have to write lot of code for reading/writing a string from a FileSream. The same read/write operation can be done easily using StreamReader and StreamWriter.
45.	The following example shows how StreamReader makes it easy to read strings from a file:
46.	Example: Read file using StreamReader
47.	//Create object of FileInfo for specified path            
48.	FileInfo fi = new FileInfo(@"D:\DummyFile.txt");
49.	        
50.	//Open file for Read\Write
51.	FileStream fs = fi.Open(FileMode.OpenOrCreate, FileAccess.Read , FileShare.Read); 
52.	
53.	//Create object of StreamReader by passing FileStream object on which it needs to operates on
54.	StreamReader sr = new StreamReader(fs);
55.	
56.	//Use ReadToEnd method to read all the content from file
57.	string fileContent = sr.ReadToEnd();
58.	
59.	//Close StreamReader object after operation
60.	sr.Close();
61.	fs.Close();
62.	Notice that fi.Open() has three parameters: The first parameter is FileMode for creating and opening a file if it does not exist; the second parameter, FileAccess, is to indicate a Read operation; and the third parameter is to share the file for reading with other users while the file is open.
63.	The following example shows how StreamWriter makes it easy to write strings to a File:
64.	Example: Write texts to file using StreamWriter
65.	//Create object of FileInfo for specified path            
66.	FileInfo fi = new FileInfo(@"D:\DummyFile.txt");
67.	        
68.	//Open file for Read\Write
69.	FileStream fs = fi.Open(FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read ); 
70.	
71.	//Create StreamWriter object to write string to FileSream
72.	StreamWriter sw = new StreamWriter(fs);
73.	sw.WriteLine("Another line from streamwriter");
74.	sw.Close();
75.	Read and Write operations are not possible on the same FileStream object simultaneously. If you are already reading from a file, create a separate FileStream object to write to the same file, as shown below:
76.	Example: StreamReader & StreamWriter
77.	//Create FileInfo object for DummyFile.txt
78.	FileInfo fi = new FileInfo(@"D:\DummyFile.txt");
79.	
80.	//open DummyFile.txt for read operation
81.	FileStream fsToRead = fi.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite , FileShare.ReadWrite); 
82.	
83.	//open DummyFile.txt for write operation
84.	FileStream fsToWrite = fi.Open(FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite); 
85.	          
86.	//get the StreamReader
87.	
88.	StreamReader sr = new StreamReader(fsToRead);
89.	//read all texts using StreamReader object
90.	string fileContent = sr.ReadToEnd();
91.	sr.Close();
92.	
93.	//get the StreamWriter
94.	StreamWriter sw = new StreamWriter(fsToWrite);
95.	//write some text using StreamWriter
96.	sw.WriteLine("Another line from streamwriter");
97.	sw.Close();
98.	
99.	//close all Stream objects
100.	fsToRead.Close();
101.	fsToWrite.Close();
102.	Thus you can use FileInfo, StreamReader and StreamWriter class to read/write contents from physical file.
FileInfo Class
•	Reference
Feedback
Definition
Namespace:
System.IO
Assembly:
System.Runtime.dll
Provides properties and instance methods for the creation, copying, deletion, moving, and opening of files, and aids in the creation of FileStream objects. This class cannot be inherited.
C#Copy
public sealed class FileInfo : System.IO.FileSystemInfo
Inheritance
Object
MarshalByRefObject
FileSystemInfo
FileInfo
Examples
The following example demonstrates some of the main members of the FileInfo class.
When the properties are first retrieved, FileInfo calls the Refresh method and caches information about the file. On subsequent calls, you must call Refresh to get the latest copy of the information.
C#Copy
using System;
using System.IO;

class Test
{
    
    public static void Main()
    {
        string path = Path.GetTempFileName();
        var fi1 = new FileInfo(path);

        // Create a file to write to.
        using (StreamWriter sw = fi1.CreateText())
        {
            sw.WriteLine("Hello");
            sw.WriteLine("And");
            sw.WriteLine("Welcome");
        }	

        // Open the file to read from.
        using (StreamReader sr = fi1.OpenText())
        {
            var s = "";
            while ((s = sr.ReadLine()) != null)
            {
                Console.WriteLine(s);
            }
        }

        try
        {
            string path2 = Path.GetTempFileName();
            var fi2 = new FileInfo(path2);

            // Ensure that the target does not exist.
            fi2.Delete();

            // Copy the file.
            fi1.CopyTo(path2);
            Console.WriteLine($"{path} was copied to {path2}.");

            // Delete the newly created file.
            fi2.Delete();
            Console.WriteLine($"{path2} was successfully deleted.");
        }
        catch (Exception e)
        {
            Console.WriteLine($"The process failed: {e.ToString()}");
        }
    }
}
This example produces output similar to the following.
Copy
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
Remarks
Use the FileInfo class for typical operations such as copying, moving, renaming, creating, opening, deleting, and appending to files.
If you are performing multiple operations on the same file, it can be more efficient to use FileInfo instance methods instead of the corresponding static methods of the File class, because a security check will not always be necessary.
Many of the FileInfo methods return other I/O types when you create or open files. You can use these other types to further manipulate a file. For more information, see specific FileInfo members such as Open, OpenRead, OpenText, CreateText, or Create.
By default, full read/write access to new files is granted to all users.
The following table describes the enumerations that are used to customize the behavior of various FileInfo methods.
Expand table
Enumeration	Description
FileAccess
Specifies read and write access to a file.
FileShare
Specifies the level of access permitted for a file that is already in use.
FileMode
Specifies whether the contents of an existing file are preserved or overwritten, and whether requests to create an existing file cause an exception.
 Note
In members that accept a path as an input string, that path must be well-formed or an exception is raised. For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class. Therefore, the path is malformed and an exception is raised. Similarly, a path or a combination of paths cannot be fully qualified twice. For example, "c:\temp c:\windows" also raises an exception in most cases. Ensure that your paths are well-formed when using methods that accept a path string.
In members that accept a path, the path can refer to a file or just a directory. The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:
•	"c:\\MyDir\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.
•	"c:\\MyDir" in C#, or "c:\MyDir" in Visual Basic.
•	"MyDir\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.
•	"\\\\MyServer\\MyShare" in C#, or "\\MyServer\MyShare" in Visual Basic.
The FileInfo class provides the following properties that enable you to retrieve information about a file. For an example of how to use each property, see the property pages.
•	The Directory property retrieves an object that represents the parent directory of a file.
•	The DirectoryName property retrieves the full path of the parent directory of a file.
•	The Exists property checks for the presence of a file before operating on it.
•	The IsReadOnly property retrieves or sets a value that specifies whether a file can be modified.
•	The Length retrieves the size of a file.
•	The Name retrieves the name of a file.
Constructors
Expand table
FileInfo(String)
Initializes a new instance of the FileInfo class, which acts as a wrapper for a file path.

Fields
Expand table
FullPath
Represents the fully qualified path of the directory or file.
(Inherited from FileSystemInfo)

OriginalPath
The path originally specified by the user, whether relative or absolute.
(Inherited from FileSystemInfo)

Properties
Expand table
Attributes
Gets or sets the attributes for the current file or directory.
(Inherited from FileSystemInfo)

CreationTime
Gets or sets the creation time of the current file or directory.
(Inherited from FileSystemInfo)

CreationTimeUtc
Gets or sets the creation time, in coordinated universal time (UTC), of the current file or directory.
(Inherited from FileSystemInfo)

Directory
Gets an instance of the parent directory.
DirectoryName
Gets a string representing the directory's full path.
Exists
Gets a value indicating whether a file exists.
Extension
Gets the extension part of the file name, including the leading dot . even if it is the entire file name, or an empty string if no extension is present.
(Inherited from FileSystemInfo)

FullName
Gets the full path of the directory or file.
(Inherited from FileSystemInfo)

IsReadOnly
Gets or sets a value that determines if the current file is read only.
LastAccessTime
Gets or sets the time the current file or directory was last accessed.
(Inherited from FileSystemInfo)

LastAccessTimeUtc
Gets or sets the time, in coordinated universal time (UTC), that the current file or directory was last accessed.
(Inherited from FileSystemInfo)

LastWriteTime
Gets or sets the time when the current file or directory was last written to.
(Inherited from FileSystemInfo)

LastWriteTimeUtc
Gets or sets the time, in coordinated universal time (UTC), when the current file or directory was last written to.
(Inherited from FileSystemInfo)

Length
Gets the size, in bytes, of the current file.
LinkTarget
Gets the target path of the link located in FullName, or null if this FileSystemInfo instance doesn't represent a link.
(Inherited from FileSystemInfo)

Name
Gets the name of the file.
UnixFileMode
Gets or sets the Unix file mode for the current file or directory.
(Inherited from FileSystemInfo)

Methods
Expand table
AppendText()
Creates a StreamWriter that appends text to the file represented by this instance of the FileInfo.

CopyTo(String)
Copies an existing file to a new file, disallowing the overwriting of an existing file.
CopyTo(String, Boolean)
Copies an existing file to a new file, allowing the overwriting of an existing file.
Create()
Creates a file.
CreateAsSymbolicLink(String)
Creates a symbolic link located in FullName that points to the specified pathToTarget.
(Inherited from FileSystemInfo)

CreateObjRef(Type)
Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.
(Inherited from MarshalByRefObject)

CreateText()
Creates a StreamWriter that writes a new text file.

Decrypt()
Decrypts a file that was encrypted by the current account using the Encrypt() method.

Delete()
Permanently deletes a file.
Encrypt()
Encrypts a file so that only the account used to encrypt the file can decrypt it.
Equals(Object)
Determines whether the specified object is equal to the current object.
(Inherited from Object)

GetHashCode()
Serves as the default hash function.
(Inherited from Object)

GetLifetimeService()
Obsolete.
Retrieves the current lifetime service object that controls the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

GetObjectData(SerializationInfo, StreamingContext)
Obsolete.
Sets the SerializationInfo object with the file name and additional exception information.
(Inherited from FileSystemInfo)

GetType()
Gets the Type of the current instance.
(Inherited from Object)

InitializeLifetimeService()
Obsolete.
Obtains a lifetime service object to control the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

MemberwiseClone()
Creates a shallow copy of the current Object.
(Inherited from Object)

MemberwiseClone(Boolean)
Creates a shallow copy of the current MarshalByRefObject object.
(Inherited from MarshalByRefObject)

MoveTo(String)
Moves a specified file to a new location, providing the option to specify a new file name.
MoveTo(String, Boolean)
Moves a specified file to a new location, providing the options to specify a new file name and to overwrite the destination file if it already exists.
Open(FileMode)
Opens a file in the specified mode.
Open(FileMode, FileAccess)
Opens a file in the specified mode with read, write, or read/write access.
Open(FileMode, FileAccess, FileShare)
Opens a file in the specified mode with read, write, or read/write access and the specified sharing option.
Open(FileStreamOptions)
Initializes a new instance of the FileStream class with the specified creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, additional file options and the allocation size.
OpenRead()
Creates a read-only FileStream.

OpenText()
Creates a StreamReader with UTF8 encoding that reads from an existing text file.
OpenWrite()
Creates a write-only FileStream.

Refresh()
Refreshes the state of the object.
(Inherited from FileSystemInfo)

Replace(String, String)
Replaces the contents of a specified file with the file described by the current FileInfo object, deleting the original file, and creating a backup of the replaced file.
Replace(String, String, Boolean)
Replaces the contents of a specified file with the file described by the current FileInfo object, deleting the original file, and creating a backup of the replaced file. Also specifies whether to ignore merge errors.
ResolveLinkTarget(Boolean)
Gets the target of the specified link.
(Inherited from FileSystemInfo)

ToString()
Returns the original path. Use the FullName or Name properties for the full path or file/directory name.
(Inherited from FileSystemInfo)

Extension Methods
Expand table
Create(FileInfo, FileMode, FileSystemRights, FileShare, Int32, FileOptions, FileSecurity)
Creates a new file stream, ensuring it is created with the specified properties and security settings.
GetAccessControl(FileInfo)
Returns the security information of a file.
GetAccessControl(FileInfo, AccessControlSections)
Returns the security information of a file.
SetAccessControl(FileInfo, FileSecurity)
Changes the security attributes of an existing file.
Applies to
Product	Versions
.NET	Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7, 8, 9
.NET Framework	1.1, 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1
.NET Standard	1.3, 1.4, 1.6, 2.0, 2.1
UWP	10.0
StreamReader Class
•	Reference
Feedback
Definition
Namespace:
System.IO
Assembly:
System.Runtime.dll
Implements a TextReader that reads characters from a byte stream in a particular encoding.
C#Copy
public class StreamReader : System.IO.TextReader
Inheritance
Object
MarshalByRefObject
TextReader
StreamReader
Examples
The following example uses an instance of StreamReader to read text from a file. The constructor used in this example is not supported for use in Windows Store Apps.
C#Copy
using System;
using System.IO;

class Test
{
    public static void Main()
    {
        try
        {
            // Create an instance of StreamReader to read from a file.
            // The using statement also closes the StreamReader.
            using (StreamReader sr = new StreamReader("TestFile.txt"))
            {
                string line;
                // Read and display lines from the file until the end of
                // the file is reached.
                while ((line = sr.ReadLine()) != null)
                {
                    Console.WriteLine(line);
                }
            }
        }
        catch (Exception e)
        {
            // Let the user know what went wrong.
            Console.WriteLine("The file could not be read:");
            Console.WriteLine(e.Message);
        }
    }
}
The following example instantiates a StreamReader object and calls its ReadAsync method to read a file asynchronously.
C#Copy
using System;
using System.IO;
using System.Threading.Tasks;

class Example
{
    static async Task Main()
    {
        await ReadAndDisplayFilesAsync();
    }

    static async Task ReadAndDisplayFilesAsync()
    {
        String filename = "TestFile1.txt";
        Char[] buffer;

        using (var sr = new StreamReader(filename)) {
            buffer = new Char[(int)sr.BaseStream.Length];
            await sr.ReadAsync(buffer, 0, (int)sr.BaseStream.Length);
        }

        Console.WriteLine(new String(buffer));
    }
}
// The example displays the following output:
//       This is the first line of text in a relatively short file.
//       This is the second line.
//       This is the third line.
//       This is the fourth and final line.
Remarks
StreamReader is designed for character input in a particular encoding, whereas the Stream class is designed for byte input and output. Use StreamReader for reading lines of information from a standard text file.
 Important
This type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a try/catch block. To dispose of it indirectly, use a language construct such as using (in C#) or Using (in Visual Basic). For more information, see the "Using an Object that Implements IDisposable" section in the IDisposable interface topic.
StreamReader defaults to UTF-8 encoding unless specified otherwise, instead of defaulting to the ANSI code page for the current system. UTF-8 handles Unicode characters correctly and provides consistent results on localized versions of the operating system. If you get the current character encoding using the CurrentEncoding property, the value is not reliable until after the first Read method, since encoding auto detection is not done until the first call to a Read method.
By default, a StreamReader is not thread safe. See TextReader.Synchronized for a thread-safe wrapper.
The Read(Char[], Int32, Int32) and Write(Char[], Int32, Int32) method overloads read and write the number of characters specified by the count parameter. These are to be distinguished from BufferedStream.Read and BufferedStream.Write, which read and write the number of bytes specified by the count parameter. Use the BufferedStream methods only for reading and writing an integral number of byte array elements.
 Note
When reading from a Stream, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.
For a list of common I/O tasks, see Common I/O Tasks.
Constructors
Expand table
StreamReader(Stream)
Initializes a new instance of the StreamReader class for the specified stream.

StreamReader(Stream, Boolean)
Initializes a new instance of the StreamReader class for the specified stream, with the specified byte order mark detection option.
StreamReader(Stream, Encoding)
Initializes a new instance of the StreamReader class for the specified stream, with the specified character encoding.
StreamReader(Stream, Encoding, Boolean)
Initializes a new instance of the StreamReader class for the specified stream, with the specified character encoding and byte order mark detection option.
StreamReader(Stream, Encoding, Boolean, Int32)
Initializes a new instance of the StreamReader class for the specified stream, with the specified character encoding, byte order mark detection option, and buffer size.
StreamReader(Stream, Encoding, Boolean, Int32, Boolean)
Initializes a new instance of the StreamReader class for the specified stream based on the specified character encoding, byte order mark detection option, and buffer size, and optionally leaves the stream open.
StreamReader(String)
Initializes a new instance of the StreamReader class for the specified file name.
StreamReader(String, Boolean)
Initializes a new instance of the StreamReader class for the specified file name, with the specified byte order mark detection option.
StreamReader(String, Encoding)
Initializes a new instance of the StreamReader class for the specified file name, with the specified character encoding.
StreamReader(String, Encoding, Boolean)
Initializes a new instance of the StreamReader class for the specified file name, with the specified character encoding and byte order mark detection option.
StreamReader(String, Encoding, Boolean, FileStreamOptions)
Initializes a new instance of the StreamReader class for the specified file path, with the specified character encoding, byte order mark detection option, and configured with the specified FileStreamOptions object.

StreamReader(String, Encoding, Boolean, Int32)
Initializes a new instance of the StreamReader class for the specified file name, with the specified character encoding, byte order mark detection option, and buffer size.
StreamReader(String, FileStreamOptions)
Initializes a new instance of the StreamReader class for the specified file path, using the default encoding, enabling detection of byte order marks at the beginning of the file, and configured with the specified FileStreamOptions object.

Fields
Expand table
Null
A StreamReader object around an empty stream.

Properties
Expand table
BaseStream
Returns the underlying stream.
CurrentEncoding
Gets the current character encoding that the current StreamReader object is using.

EndOfStream
Gets a value that indicates whether the current stream position is at the end of the stream.
Methods
Expand table
Close()
Closes the StreamReader object and the underlying stream, and releases any system resources associated with the reader.
CreateObjRef(Type)
Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.
(Inherited from MarshalByRefObject)

DiscardBufferedData()
Clears the internal buffer.
Dispose()
Releases all resources used by the TextReader object.
(Inherited from TextReader)

Dispose(Boolean)
Closes the underlying stream, releases the unmanaged resources used by the StreamReader, and optionally releases the managed resources.
Equals(Object)
Determines whether the specified object is equal to the current object.
(Inherited from Object)

GetHashCode()
Serves as the default hash function.
(Inherited from Object)

GetLifetimeService()
Obsolete.
Retrieves the current lifetime service object that controls the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

GetType()
Gets the Type of the current instance.
(Inherited from Object)

InitializeLifetimeService()
Obsolete.
Obtains a lifetime service object to control the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

MemberwiseClone()
Creates a shallow copy of the current Object.
(Inherited from Object)

MemberwiseClone(Boolean)
Creates a shallow copy of the current MarshalByRefObject object.
(Inherited from MarshalByRefObject)

Peek()
Returns the next available character but does not consume it.
Read()
Reads the next character from the input stream and advances the character position by one character.
Read(Char[], Int32, Int32)
Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index.
Read(Span<Char>)
Reads the characters from the current stream into a span.
ReadAsync(Char[], Int32, Int32)
Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.
ReadAsync(Memory<Char>, CancellationToken)
Asynchronously reads the characters from the current stream into a memory block.
ReadBlock(Char[], Int32, Int32)
Reads a specified maximum number of characters from the current stream and writes the data to a buffer, beginning at the specified index.
ReadBlock(Span<Char>)
Reads the characters from the current stream and writes the data to a buffer.
ReadBlockAsync(Char[], Int32, Int32)
Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.
ReadBlockAsync(Memory<Char>, CancellationToken)
Asynchronously reads the characters from the current stream and writes the data to a buffer.
ReadLine()
Reads a line of characters from the current stream and returns the data as a string.
ReadLineAsync()
Reads a line of characters asynchronously from the current stream and returns the data as a string.
ReadLineAsync(CancellationToken)
Reads a line of characters asynchronously from the current stream and returns the data as a string.
ReadToEnd()
Reads all characters from the current position to the end of the stream.
ReadToEndAsync()
Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.
ReadToEndAsync(CancellationToken)
Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.
ToString()
Returns a string that represents the current object.
(Inherited from Object)

StringWriter Class
•	Reference
Feedback
Definition
Namespace:
System.IO
Assembly:
System.Runtime.dll
Implements a TextWriter for writing information to a string. The information is stored in an underlying StringBuilder.
C#Copy
public class StringWriter : System.IO.TextWriter
Inheritance
Object
MarshalByRefObject
TextWriter
StringWriter
Examples
The following code example demonstrates the creation of a continuous paragraph from a group of double-spaced sentences, and then the conversion of the paragraph back to the original text.
C#Copy
using System;
using System.IO;

class StringRW
{
    static void Main()
    {
        string textReaderText = "TextReader is the abstract base " +
            "class of StreamReader and StringReader, which read " +
            "characters from streams and strings, respectively.\n\n" +

            "Create an instance of TextReader to open a text file " +
            "for reading a specified range of characters, or to " +
            "create a reader based on an existing stream.\n\n" +

            "You can also use an instance of TextReader to read " +
            "text from a custom backing store using the same " +
            "APIs you would use for a string or a stream.\n\n";

        Console.WriteLine("Original text:\n\n{0}", textReaderText);

        // From textReaderText, create a continuous paragraph
        // with two spaces between each sentence.
        string aLine, aParagraph = null;
        StringReader strReader = new StringReader(textReaderText);
        while(true)
        {
            aLine = strReader.ReadLine();
            if(aLine != null)
            {
                aParagraph = aParagraph + aLine + " ";
            }
            else
            {
                aParagraph = aParagraph + "\n";
                break;
            }
        }
        Console.WriteLine("Modified text:\n\n{0}", aParagraph);

        // Re-create textReaderText from aParagraph.
        int intCharacter;
        char convertedCharacter;
        StringWriter strWriter = new StringWriter();
        strReader = new StringReader(aParagraph);
        while(true)
        {
            intCharacter = strReader.Read();

            // Check for the end of the string
            // before converting to a character.
            if(intCharacter == -1) break;

            convertedCharacter = (char)intCharacter;
            if(convertedCharacter == '.')
            {
                strWriter.Write(".\n\n");

                // Bypass the spaces between sentences.
                strReader.Read();
                strReader.Read();
            }
            else
            {
                strWriter.Write(convertedCharacter);
            }
        }
        Console.WriteLine("\nOriginal text:\n\n{0}",
            strWriter.ToString());
    }
}
Remarks
StringWriter enables you to write to a string synchronously or asynchronously. You can write a character at a time with the Write(Char) or the WriteAsync(Char) method, a string at a time using the Write(String) or the WriteAsync(String) method. In addition, you can write a character, an array of characters or a string followed by the line terminator asynchronously with one of the WriteLineAsync methods.
 Note
This type implements the IDisposable interface, but does not actually have any resources to dispose. This means that disposing it by directly calling Dispose() or by using a language construct such as using (in C#) or Using (in Visual Basic) is not necessary.
The following table lists examples of other typical or related I/O tasks.
Expand table
To do this...	See the example in this topic...
Create a text file.	How to: Write Text to a File

Write to a text file.	How to: Write Text to a File

Read from a text file.	How to: Read Text from a File

Append text to a file.	How to: Open and Append to a Log File

File.AppendText

FileInfo.AppendText

Get the size of a file.	FileInfo.Length

Get the attributes of a file.	File.GetAttributes

Set the attributes of a file.	File.SetAttributes

Determine if a file exists.	File.Exists

Read from a binary file.	How to: Read and Write to a Newly Created Data File

Write to a binary file.	How to: Read and Write to a Newly Created Data File

Constructors
Expand table
StringWriter()
Initializes a new instance of the StringWriter class.

StringWriter(IFormatProvider)
Initializes a new instance of the StringWriter class with the specified format control.
StringWriter(StringBuilder)
Initializes a new instance of the StringWriter class that writes to the specified StringBuilder.

StringWriter(StringBuilder, IFormatProvider)
Initializes a new instance of the StringWriter class that writes to the specified StringBuilder and has the specified format provider.

Fields
Expand table
CoreNewLine
Stores the newline characters used for this TextWriter.
(Inherited from TextWriter)

Properties
Expand table
Encoding
Gets the Encoding in which the output is written.

FormatProvider
Gets an object that controls formatting.
(Inherited from TextWriter)

NewLine
Gets or sets the line terminator string used by the current TextWriter.
(Inherited from TextWriter)

Methods
Expand table
Close()
Closes the current StringWriter and the underlying stream.

CreateObjRef(Type)
Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.
(Inherited from MarshalByRefObject)

Dispose()
Releases all resources used by the TextWriter object.
(Inherited from TextWriter)

Dispose(Boolean)
Releases the unmanaged resources used by the StringWriter and optionally releases the managed resources.
DisposeAsync()
Asynchronously releases all resources used by the TextWriter object.
(Inherited from TextWriter)

Equals(Object)
Determines whether the specified object is equal to the current object.
(Inherited from Object)

Flush()
Clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
(Inherited from TextWriter)

FlushAsync()
Asynchronously clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
FlushAsync(CancellationToken)
Asynchronously clears all buffers for the current writer and causes any buffered data to be written to the underlying device.
(Inherited from TextWriter)

GetHashCode()
Serves as the default hash function.
(Inherited from Object)

GetLifetimeService()
Obsolete.
Retrieves the current lifetime service object that controls the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

GetStringBuilder()
Returns the underlying StringBuilder.

GetType()
Gets the Type of the current instance.
(Inherited from Object)

InitializeLifetimeService()
Obsolete.
Obtains a lifetime service object to control the lifetime policy for this instance.
(Inherited from MarshalByRefObject)

MemberwiseClone()
Creates a shallow copy of the current Object.
(Inherited from Object)

MemberwiseClone(Boolean)
Creates a shallow copy of the current MarshalByRefObject object.
(Inherited from MarshalByRefObject)

ToString()
Returns a string containing the characters written to the current StringWriter so far.
Write(Boolean)
Writes the text representation of a Boolean value to the text stream.
(Inherited from TextWriter)

Write(Char)
Writes a character to the string.
Write(Char[])
Writes a character array to the text stream.
(Inherited from TextWriter)

Write(Char[], Int32, Int32)
Writes a subarray of characters to the string.
Write(Decimal)
Writes the text representation of a decimal value to the text stream.
(Inherited from TextWriter)

Write(Double)
Writes the text representation of an 8-byte floating-point value to the text stream.
(Inherited from TextWriter)

Write(Int32)
Writes the text representation of a 4-byte signed integer to the text stream.
(Inherited from TextWriter)

Write(Int64)
Writes the text representation of an 8-byte signed integer to the text stream.
(Inherited from TextWriter)

Write(Object)
Writes the text representation of an object to the text stream by calling the ToString method on that object.
(Inherited from TextWriter)

Write(ReadOnlySpan<Char>)
Writes the string representation of a span of chars to the current string.
Write(Single)
Writes the text representation of a 4-byte floating-point value to the text stream.
(Inherited from TextWriter)

Write(String)
Writes a string to the current string.
Write(String, Object)
Writes a formatted string to the text stream, using the same semantics as the Format(String, Object) method.
(Inherited from TextWriter)

Write(String, Object, Object)
Writes a formatted string to the text stream using the same semantics as the Format(String, Object, Object) method.
(Inherited from TextWriter)

Write(String, Object, Object, Object)
Writes a formatted string to the text stream, using the same semantics as the Format(String, Object, Object, Object) method.
(Inherited from TextWriter)

Write(String, Object[])
Writes a formatted string to the text stream, using the same semantics as the Format(String, Object[]) method.
(Inherited from TextWriter)

Write(StringBuilder)
Writes the string representation of a string builder to the current string.
Write(UInt32)
Writes the text representation of a 4-byte unsigned integer to the text stream.
(Inherited from TextWriter)

Write(UInt64)
Writes the text representation of an 8-byte unsigned integer to the text stream.
(Inherited from TextWriter)

WriteAsync(Char)
Writes a character to the string asynchronously.
WriteAsync(Char[])
Writes a character array to the text stream asynchronously.
(Inherited from TextWriter)

WriteAsync(Char[], Int32, Int32)
Writes a subarray of characters to the string asynchronously.
WriteAsync(ReadOnlyMemory<Char>, CancellationToken)
Asynchronously writes a memory region of characters to the string.
WriteAsync(String)
Writes a string to the current string asynchronously.
WriteAsync(StringBuilder, CancellationToken)
Asynchronously writes the text representation of a string builder to the string.
WriteLine()
Writes a line terminator to the text stream.
(Inherited from TextWriter)

WriteLine(Boolean)
Writes the text representation of a Boolean value to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Char)
Writes a character to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Char[])
Writes an array of characters to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Char[], Int32, Int32)
Writes a subarray of characters to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Decimal)
Writes the text representation of a decimal value to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Double)
Writes the text representation of a 8-byte floating-point value to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Int32)
Writes the text representation of a 4-byte signed integer to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Int64)
Writes the text representation of an 8-byte signed integer to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(Object)
Writes the text representation of an object to the text stream, by calling the ToString method on that object, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(ReadOnlySpan<Char>)
Writes the text representation a span of characters to the string, followed by a line terminator.
WriteLine(Single)
Writes the text representation of a 4-byte floating-point value to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(String)
Writes a string to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(String, Object)
Writes a formatted string and a new line to the text stream, using the same semantics as the Format(String, Object) method.
(Inherited from TextWriter)

WriteLine(String, Object, Object)
Writes a formatted string and a new line to the text stream, using the same semantics as the Format(String, Object, Object) method.
(Inherited from TextWriter)

WriteLine(String, Object, Object, Object)
Writes out a formatted string and a new line to the text stream, using the same semantics as Format(String, Object).
(Inherited from TextWriter)

WriteLine(String, Object[])
Writes out a formatted string and a new line to the text stream, using the same semantics as Format(String, Object).
(Inherited from TextWriter)

WriteLine(StringBuilder)
Writes the text representation of a string builder to the string, followed by a line terminator.
WriteLine(UInt32)
Writes the text representation of a 4-byte unsigned integer to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLine(UInt64)
Writes the text representation of an 8-byte unsigned integer to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLineAsync()
Asynchronously writes a line terminator to the text stream.
(Inherited from TextWriter)

WriteLineAsync(Char)
Asynchronously writes a character to the string, followed by a line terminator.
WriteLineAsync(Char[])
Asynchronously writes an array of characters to the text stream, followed by a line terminator.
(Inherited from TextWriter)

WriteLineAsync(Char[], Int32, Int32)
asynchronously writes a subarray of characters to the string, followed by a line terminator.
WriteLineAsync(ReadOnlyMemory<Char>, CancellationToken)
Asynchronously writes the string representation of the memory region of characters to the current string, followed by a line terminator.
WriteLineAsync(String)
Asynchronously writes a string to the current string, followed by a line terminator.
WriteLineAsync(StringBuilder, CancellationToken)
Asynchronously writes the string representation of the string builder to the current string, followed by a line terminator.

Extension Methods
Expand table
ConfigureAwait(IAsyncDisposable, Boolean)
Configures how awaits on the tasks returned from an async disposable are performed.
C# - Object Initializer Syntax
C# 3.0 (.NET 3.5) introduced Object Initializer Syntax, a new way to initialize an object of a class or collection. Object initializers allow you to assign values to the fields or properties at the time of creating an object without invoking a constructor.
Example: Object Initializer Syntax
public class Student
{
    public int StudentID { get; set; }
    public string StudentName { get; set; }
    public int Age { get; set; }
    public string Address { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        Student std = new Student() { StudentID = 1, 
                                      StudentName = "Bill", 
                                      Age = 20, 
                                      Address = "New York"   
                                    };
    }
}
Try it
In the above example, Student class is defined without any constructors. In the Main() method, we have created Student object and assigned values to all or some properties in the curly bracket at the same time. This is called object initializer syntax.
The compiler compiles the above initializer into something like the following.
Example: Object Initializer Syntax at Compile time
Student __student = new Student();
__student.StudentID = 1;
__student.StudentName = "Bill";
__student.Age = 20;
__student.StandardID = 10;
__student.Address = "Test";

Student std = __student;
Collection Initializer Syntax
Collection can be initialized the same way as class objects using collection initializer syntax.
Example: Object initializer Syntax
var student1 = new Student() { StudentID = 1, StudentName = "John" };
var student2 = new Student() { StudentID = 2, StudentName = "Steve" };
var student3 = new Student() { StudentID = 3, StudentName = "Bill" } ;
var student4 = new Student() { StudentID = 3, StudentName = "Bill" };
var student5 = new Student() { StudentID = 5, StudentName = "Ron" };

IList<Student> studentList = new List<Student>() { 
                                                    student1, 
                                                    student2, 
                                                    student3, 
                                                    student4, 
                                                    student5 
                                                };
Try it
You can also initialize collections and objects at the same time.
Example: Collection initializer Syntax
IList<Student> studentList = new List<Student>() { 
                    new Student() { StudentID = 1, StudentName = "John"} ,
                    new Student() { StudentID = 2, StudentName = "Steve"} ,
                    new Student() { StudentID = 3, StudentName = "Bill"} ,
                    new Student() { StudentID = 3, StudentName = "Bill"} ,
                    new Student() { StudentID = 4, StudentName = "Ram" } ,
                    new Student() { StudentID = 5, StudentName = "Ron" } 
                };
Try it
You can also specify null as an element:
Example: Collection initializer Syntax
IList<Student> studentList = new List<Student>() { 
                                    new Student() { StudentID = 1, StudentName = "John"} ,
                                    null
                                };
Advantages of Initializers
•	Initializer syntax makes a code more readable, easy to add elements into the collection.
•	Useful in multi-threading.

